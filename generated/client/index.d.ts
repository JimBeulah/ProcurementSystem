
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Company
 * 
 */
export type Company = $Result.DefaultSelection<Prisma.$CompanyPayload>
/**
 * Model Client
 * 
 */
export type Client = $Result.DefaultSelection<Prisma.$ClientPayload>
/**
 * Model Project
 * 
 */
export type Project = $Result.DefaultSelection<Prisma.$ProjectPayload>
/**
 * Model ProjectMember
 * 
 */
export type ProjectMember = $Result.DefaultSelection<Prisma.$ProjectMemberPayload>
/**
 * Model BoqItem
 * 
 */
export type BoqItem = $Result.DefaultSelection<Prisma.$BoqItemPayload>
/**
 * Model BoqItemComponent
 * 
 */
export type BoqItemComponent = $Result.DefaultSelection<Prisma.$BoqItemComponentPayload>
/**
 * Model MaterialRequest
 * 
 */
export type MaterialRequest = $Result.DefaultSelection<Prisma.$MaterialRequestPayload>
/**
 * Model MaterialRequestItem
 * 
 */
export type MaterialRequestItem = $Result.DefaultSelection<Prisma.$MaterialRequestItemPayload>
/**
 * Model RFQ
 * 
 */
export type RFQ = $Result.DefaultSelection<Prisma.$RFQPayload>
/**
 * Model RFQItem
 * 
 */
export type RFQItem = $Result.DefaultSelection<Prisma.$RFQItemPayload>
/**
 * Model Supplier
 * 
 */
export type Supplier = $Result.DefaultSelection<Prisma.$SupplierPayload>
/**
 * Model Material
 * 
 */
export type Material = $Result.DefaultSelection<Prisma.$MaterialPayload>
/**
 * Model Unit
 * 
 */
export type Unit = $Result.DefaultSelection<Prisma.$UnitPayload>
/**
 * Model Category
 * 
 */
export type Category = $Result.DefaultSelection<Prisma.$CategoryPayload>
/**
 * Model Warehouse
 * 
 */
export type Warehouse = $Result.DefaultSelection<Prisma.$WarehousePayload>
/**
 * Model SupplierQuotation
 * 
 */
export type SupplierQuotation = $Result.DefaultSelection<Prisma.$SupplierQuotationPayload>
/**
 * Model QuotationItem
 * 
 */
export type QuotationItem = $Result.DefaultSelection<Prisma.$QuotationItemPayload>
/**
 * Model PurchaseOrder
 * 
 */
export type PurchaseOrder = $Result.DefaultSelection<Prisma.$PurchaseOrderPayload>
/**
 * Model PurchaseOrderItem
 * 
 */
export type PurchaseOrderItem = $Result.DefaultSelection<Prisma.$PurchaseOrderItemPayload>
/**
 * Model ReceivingReport
 * 
 */
export type ReceivingReport = $Result.DefaultSelection<Prisma.$ReceivingReportPayload>
/**
 * Model ReceivingItem
 * 
 */
export type ReceivingItem = $Result.DefaultSelection<Prisma.$ReceivingItemPayload>
/**
 * Model InventoryItem
 * 
 */
export type InventoryItem = $Result.DefaultSelection<Prisma.$InventoryItemPayload>
/**
 * Model WorkflowRule
 * 
 */
export type WorkflowRule = $Result.DefaultSelection<Prisma.$WorkflowRulePayload>
/**
 * Model SupplierInvoice
 * 
 */
export type SupplierInvoice = $Result.DefaultSelection<Prisma.$SupplierInvoicePayload>
/**
 * Model Disbursement
 * 
 */
export type Disbursement = $Result.DefaultSelection<Prisma.$DisbursementPayload>
/**
 * Model FinancialTransaction
 * 
 */
export type FinancialTransaction = $Result.DefaultSelection<Prisma.$FinancialTransactionPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  ADMIN: 'ADMIN',
  PROJECT_MANAGER: 'PROJECT_MANAGER',
  PROCUREMENT_OFFICER: 'PROCUREMENT_OFFICER',
  ENGINEER: 'ENGINEER',
  FINANCE: 'FINANCE',
  AUDITOR: 'AUDITOR',
  HEAD_OF_ADMIN: 'HEAD_OF_ADMIN',
  ENCODER: 'ENCODER',
  PURCHASER: 'PURCHASER',
  APPROVER: 'APPROVER',
  CASH_DISBURSEMENT: 'CASH_DISBURSEMENT',
  WAREHOUSE: 'WAREHOUSE',
  SITE_ENGINEER: 'SITE_ENGINEER'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const ResourceType: {
  MATERIAL: 'MATERIAL',
  LABOR: 'LABOR',
  EQUIPMENT: 'EQUIPMENT'
};

export type ResourceType = (typeof ResourceType)[keyof typeof ResourceType]


export const MrStatus: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED',
  PARTIALLY_FULFILLED: 'PARTIALLY_FULFILLED',
  FULFILLED: 'FULFILLED'
};

export type MrStatus = (typeof MrStatus)[keyof typeof MrStatus]


export const RfqStatus: {
  OPEN: 'OPEN',
  CLOSED: 'CLOSED',
  AWARDED: 'AWARDED'
};

export type RfqStatus = (typeof RfqStatus)[keyof typeof RfqStatus]


export const PoStatus: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  DECLINED: 'DECLINED',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED'
};

export type PoStatus = (typeof PoStatus)[keyof typeof PoStatus]


export const PaymentMethod: {
  CASH: 'CASH',
  CHECK: 'CHECK',
  ONLINE: 'ONLINE'
};

export type PaymentMethod = (typeof PaymentMethod)[keyof typeof PaymentMethod]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type ResourceType = $Enums.ResourceType

export const ResourceType: typeof $Enums.ResourceType

export type MrStatus = $Enums.MrStatus

export const MrStatus: typeof $Enums.MrStatus

export type RfqStatus = $Enums.RfqStatus

export const RfqStatus: typeof $Enums.RfqStatus

export type PoStatus = $Enums.PoStatus

export const PoStatus: typeof $Enums.PoStatus

export type PaymentMethod = $Enums.PaymentMethod

export const PaymentMethod: typeof $Enums.PaymentMethod

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.company`: Exposes CRUD operations for the **Company** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Companies
    * const companies = await prisma.company.findMany()
    * ```
    */
  get company(): Prisma.CompanyDelegate<ExtArgs>;

  /**
   * `prisma.client`: Exposes CRUD operations for the **Client** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clients
    * const clients = await prisma.client.findMany()
    * ```
    */
  get client(): Prisma.ClientDelegate<ExtArgs>;

  /**
   * `prisma.project`: Exposes CRUD operations for the **Project** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Projects
    * const projects = await prisma.project.findMany()
    * ```
    */
  get project(): Prisma.ProjectDelegate<ExtArgs>;

  /**
   * `prisma.projectMember`: Exposes CRUD operations for the **ProjectMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectMembers
    * const projectMembers = await prisma.projectMember.findMany()
    * ```
    */
  get projectMember(): Prisma.ProjectMemberDelegate<ExtArgs>;

  /**
   * `prisma.boqItem`: Exposes CRUD operations for the **BoqItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BoqItems
    * const boqItems = await prisma.boqItem.findMany()
    * ```
    */
  get boqItem(): Prisma.BoqItemDelegate<ExtArgs>;

  /**
   * `prisma.boqItemComponent`: Exposes CRUD operations for the **BoqItemComponent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BoqItemComponents
    * const boqItemComponents = await prisma.boqItemComponent.findMany()
    * ```
    */
  get boqItemComponent(): Prisma.BoqItemComponentDelegate<ExtArgs>;

  /**
   * `prisma.materialRequest`: Exposes CRUD operations for the **MaterialRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MaterialRequests
    * const materialRequests = await prisma.materialRequest.findMany()
    * ```
    */
  get materialRequest(): Prisma.MaterialRequestDelegate<ExtArgs>;

  /**
   * `prisma.materialRequestItem`: Exposes CRUD operations for the **MaterialRequestItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MaterialRequestItems
    * const materialRequestItems = await prisma.materialRequestItem.findMany()
    * ```
    */
  get materialRequestItem(): Prisma.MaterialRequestItemDelegate<ExtArgs>;

  /**
   * `prisma.rFQ`: Exposes CRUD operations for the **RFQ** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RFQS
    * const rFQS = await prisma.rFQ.findMany()
    * ```
    */
  get rFQ(): Prisma.RFQDelegate<ExtArgs>;

  /**
   * `prisma.rFQItem`: Exposes CRUD operations for the **RFQItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RFQItems
    * const rFQItems = await prisma.rFQItem.findMany()
    * ```
    */
  get rFQItem(): Prisma.RFQItemDelegate<ExtArgs>;

  /**
   * `prisma.supplier`: Exposes CRUD operations for the **Supplier** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Suppliers
    * const suppliers = await prisma.supplier.findMany()
    * ```
    */
  get supplier(): Prisma.SupplierDelegate<ExtArgs>;

  /**
   * `prisma.material`: Exposes CRUD operations for the **Material** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Materials
    * const materials = await prisma.material.findMany()
    * ```
    */
  get material(): Prisma.MaterialDelegate<ExtArgs>;

  /**
   * `prisma.unit`: Exposes CRUD operations for the **Unit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Units
    * const units = await prisma.unit.findMany()
    * ```
    */
  get unit(): Prisma.UnitDelegate<ExtArgs>;

  /**
   * `prisma.category`: Exposes CRUD operations for the **Category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.category.findMany()
    * ```
    */
  get category(): Prisma.CategoryDelegate<ExtArgs>;

  /**
   * `prisma.warehouse`: Exposes CRUD operations for the **Warehouse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Warehouses
    * const warehouses = await prisma.warehouse.findMany()
    * ```
    */
  get warehouse(): Prisma.WarehouseDelegate<ExtArgs>;

  /**
   * `prisma.supplierQuotation`: Exposes CRUD operations for the **SupplierQuotation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SupplierQuotations
    * const supplierQuotations = await prisma.supplierQuotation.findMany()
    * ```
    */
  get supplierQuotation(): Prisma.SupplierQuotationDelegate<ExtArgs>;

  /**
   * `prisma.quotationItem`: Exposes CRUD operations for the **QuotationItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuotationItems
    * const quotationItems = await prisma.quotationItem.findMany()
    * ```
    */
  get quotationItem(): Prisma.QuotationItemDelegate<ExtArgs>;

  /**
   * `prisma.purchaseOrder`: Exposes CRUD operations for the **PurchaseOrder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PurchaseOrders
    * const purchaseOrders = await prisma.purchaseOrder.findMany()
    * ```
    */
  get purchaseOrder(): Prisma.PurchaseOrderDelegate<ExtArgs>;

  /**
   * `prisma.purchaseOrderItem`: Exposes CRUD operations for the **PurchaseOrderItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PurchaseOrderItems
    * const purchaseOrderItems = await prisma.purchaseOrderItem.findMany()
    * ```
    */
  get purchaseOrderItem(): Prisma.PurchaseOrderItemDelegate<ExtArgs>;

  /**
   * `prisma.receivingReport`: Exposes CRUD operations for the **ReceivingReport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReceivingReports
    * const receivingReports = await prisma.receivingReport.findMany()
    * ```
    */
  get receivingReport(): Prisma.ReceivingReportDelegate<ExtArgs>;

  /**
   * `prisma.receivingItem`: Exposes CRUD operations for the **ReceivingItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReceivingItems
    * const receivingItems = await prisma.receivingItem.findMany()
    * ```
    */
  get receivingItem(): Prisma.ReceivingItemDelegate<ExtArgs>;

  /**
   * `prisma.inventoryItem`: Exposes CRUD operations for the **InventoryItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InventoryItems
    * const inventoryItems = await prisma.inventoryItem.findMany()
    * ```
    */
  get inventoryItem(): Prisma.InventoryItemDelegate<ExtArgs>;

  /**
   * `prisma.workflowRule`: Exposes CRUD operations for the **WorkflowRule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkflowRules
    * const workflowRules = await prisma.workflowRule.findMany()
    * ```
    */
  get workflowRule(): Prisma.WorkflowRuleDelegate<ExtArgs>;

  /**
   * `prisma.supplierInvoice`: Exposes CRUD operations for the **SupplierInvoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SupplierInvoices
    * const supplierInvoices = await prisma.supplierInvoice.findMany()
    * ```
    */
  get supplierInvoice(): Prisma.SupplierInvoiceDelegate<ExtArgs>;

  /**
   * `prisma.disbursement`: Exposes CRUD operations for the **Disbursement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Disbursements
    * const disbursements = await prisma.disbursement.findMany()
    * ```
    */
  get disbursement(): Prisma.DisbursementDelegate<ExtArgs>;

  /**
   * `prisma.financialTransaction`: Exposes CRUD operations for the **FinancialTransaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FinancialTransactions
    * const financialTransactions = await prisma.financialTransaction.findMany()
    * ```
    */
  get financialTransaction(): Prisma.FinancialTransactionDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Company: 'Company',
    Client: 'Client',
    Project: 'Project',
    ProjectMember: 'ProjectMember',
    BoqItem: 'BoqItem',
    BoqItemComponent: 'BoqItemComponent',
    MaterialRequest: 'MaterialRequest',
    MaterialRequestItem: 'MaterialRequestItem',
    RFQ: 'RFQ',
    RFQItem: 'RFQItem',
    Supplier: 'Supplier',
    Material: 'Material',
    Unit: 'Unit',
    Category: 'Category',
    Warehouse: 'Warehouse',
    SupplierQuotation: 'SupplierQuotation',
    QuotationItem: 'QuotationItem',
    PurchaseOrder: 'PurchaseOrder',
    PurchaseOrderItem: 'PurchaseOrderItem',
    ReceivingReport: 'ReceivingReport',
    ReceivingItem: 'ReceivingItem',
    InventoryItem: 'InventoryItem',
    WorkflowRule: 'WorkflowRule',
    SupplierInvoice: 'SupplierInvoice',
    Disbursement: 'Disbursement',
    FinancialTransaction: 'FinancialTransaction'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "company" | "client" | "project" | "projectMember" | "boqItem" | "boqItemComponent" | "materialRequest" | "materialRequestItem" | "rFQ" | "rFQItem" | "supplier" | "material" | "unit" | "category" | "warehouse" | "supplierQuotation" | "quotationItem" | "purchaseOrder" | "purchaseOrderItem" | "receivingReport" | "receivingItem" | "inventoryItem" | "workflowRule" | "supplierInvoice" | "disbursement" | "financialTransaction"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Company: {
        payload: Prisma.$CompanyPayload<ExtArgs>
        fields: Prisma.CompanyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompanyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompanyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          findFirst: {
            args: Prisma.CompanyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompanyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          findMany: {
            args: Prisma.CompanyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[]
          }
          create: {
            args: Prisma.CompanyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          createMany: {
            args: Prisma.CompanyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CompanyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          update: {
            args: Prisma.CompanyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          deleteMany: {
            args: Prisma.CompanyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompanyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CompanyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          aggregate: {
            args: Prisma.CompanyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompany>
          }
          groupBy: {
            args: Prisma.CompanyGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompanyGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompanyCountArgs<ExtArgs>
            result: $Utils.Optional<CompanyCountAggregateOutputType> | number
          }
        }
      }
      Client: {
        payload: Prisma.$ClientPayload<ExtArgs>
        fields: Prisma.ClientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClientFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClientFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          findFirst: {
            args: Prisma.ClientFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClientFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          findMany: {
            args: Prisma.ClientFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>[]
          }
          create: {
            args: Prisma.ClientCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          createMany: {
            args: Prisma.ClientCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ClientDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          update: {
            args: Prisma.ClientUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          deleteMany: {
            args: Prisma.ClientDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClientUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ClientUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          aggregate: {
            args: Prisma.ClientAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClient>
          }
          groupBy: {
            args: Prisma.ClientGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClientGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClientCountArgs<ExtArgs>
            result: $Utils.Optional<ClientCountAggregateOutputType> | number
          }
        }
      }
      Project: {
        payload: Prisma.$ProjectPayload<ExtArgs>
        fields: Prisma.ProjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findFirst: {
            args: Prisma.ProjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findMany: {
            args: Prisma.ProjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          create: {
            args: Prisma.ProjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          createMany: {
            args: Prisma.ProjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          update: {
            args: Prisma.ProjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          deleteMany: {
            args: Prisma.ProjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          aggregate: {
            args: Prisma.ProjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProject>
          }
          groupBy: {
            args: Prisma.ProjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectCountAggregateOutputType> | number
          }
        }
      }
      ProjectMember: {
        payload: Prisma.$ProjectMemberPayload<ExtArgs>
        fields: Prisma.ProjectMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectMemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectMemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload>
          }
          findFirst: {
            args: Prisma.ProjectMemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectMemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload>
          }
          findMany: {
            args: Prisma.ProjectMemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload>[]
          }
          create: {
            args: Prisma.ProjectMemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload>
          }
          createMany: {
            args: Prisma.ProjectMemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProjectMemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload>
          }
          update: {
            args: Prisma.ProjectMemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload>
          }
          deleteMany: {
            args: Prisma.ProjectMemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectMemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProjectMemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload>
          }
          aggregate: {
            args: Prisma.ProjectMemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjectMember>
          }
          groupBy: {
            args: Prisma.ProjectMemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectMemberCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectMemberCountAggregateOutputType> | number
          }
        }
      }
      BoqItem: {
        payload: Prisma.$BoqItemPayload<ExtArgs>
        fields: Prisma.BoqItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BoqItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoqItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BoqItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoqItemPayload>
          }
          findFirst: {
            args: Prisma.BoqItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoqItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BoqItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoqItemPayload>
          }
          findMany: {
            args: Prisma.BoqItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoqItemPayload>[]
          }
          create: {
            args: Prisma.BoqItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoqItemPayload>
          }
          createMany: {
            args: Prisma.BoqItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BoqItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoqItemPayload>
          }
          update: {
            args: Prisma.BoqItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoqItemPayload>
          }
          deleteMany: {
            args: Prisma.BoqItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BoqItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BoqItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoqItemPayload>
          }
          aggregate: {
            args: Prisma.BoqItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBoqItem>
          }
          groupBy: {
            args: Prisma.BoqItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<BoqItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.BoqItemCountArgs<ExtArgs>
            result: $Utils.Optional<BoqItemCountAggregateOutputType> | number
          }
        }
      }
      BoqItemComponent: {
        payload: Prisma.$BoqItemComponentPayload<ExtArgs>
        fields: Prisma.BoqItemComponentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BoqItemComponentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoqItemComponentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BoqItemComponentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoqItemComponentPayload>
          }
          findFirst: {
            args: Prisma.BoqItemComponentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoqItemComponentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BoqItemComponentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoqItemComponentPayload>
          }
          findMany: {
            args: Prisma.BoqItemComponentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoqItemComponentPayload>[]
          }
          create: {
            args: Prisma.BoqItemComponentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoqItemComponentPayload>
          }
          createMany: {
            args: Prisma.BoqItemComponentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BoqItemComponentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoqItemComponentPayload>
          }
          update: {
            args: Prisma.BoqItemComponentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoqItemComponentPayload>
          }
          deleteMany: {
            args: Prisma.BoqItemComponentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BoqItemComponentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BoqItemComponentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoqItemComponentPayload>
          }
          aggregate: {
            args: Prisma.BoqItemComponentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBoqItemComponent>
          }
          groupBy: {
            args: Prisma.BoqItemComponentGroupByArgs<ExtArgs>
            result: $Utils.Optional<BoqItemComponentGroupByOutputType>[]
          }
          count: {
            args: Prisma.BoqItemComponentCountArgs<ExtArgs>
            result: $Utils.Optional<BoqItemComponentCountAggregateOutputType> | number
          }
        }
      }
      MaterialRequest: {
        payload: Prisma.$MaterialRequestPayload<ExtArgs>
        fields: Prisma.MaterialRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MaterialRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MaterialRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialRequestPayload>
          }
          findFirst: {
            args: Prisma.MaterialRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MaterialRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialRequestPayload>
          }
          findMany: {
            args: Prisma.MaterialRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialRequestPayload>[]
          }
          create: {
            args: Prisma.MaterialRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialRequestPayload>
          }
          createMany: {
            args: Prisma.MaterialRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MaterialRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialRequestPayload>
          }
          update: {
            args: Prisma.MaterialRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialRequestPayload>
          }
          deleteMany: {
            args: Prisma.MaterialRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MaterialRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MaterialRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialRequestPayload>
          }
          aggregate: {
            args: Prisma.MaterialRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMaterialRequest>
          }
          groupBy: {
            args: Prisma.MaterialRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<MaterialRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.MaterialRequestCountArgs<ExtArgs>
            result: $Utils.Optional<MaterialRequestCountAggregateOutputType> | number
          }
        }
      }
      MaterialRequestItem: {
        payload: Prisma.$MaterialRequestItemPayload<ExtArgs>
        fields: Prisma.MaterialRequestItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MaterialRequestItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialRequestItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MaterialRequestItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialRequestItemPayload>
          }
          findFirst: {
            args: Prisma.MaterialRequestItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialRequestItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MaterialRequestItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialRequestItemPayload>
          }
          findMany: {
            args: Prisma.MaterialRequestItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialRequestItemPayload>[]
          }
          create: {
            args: Prisma.MaterialRequestItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialRequestItemPayload>
          }
          createMany: {
            args: Prisma.MaterialRequestItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MaterialRequestItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialRequestItemPayload>
          }
          update: {
            args: Prisma.MaterialRequestItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialRequestItemPayload>
          }
          deleteMany: {
            args: Prisma.MaterialRequestItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MaterialRequestItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MaterialRequestItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialRequestItemPayload>
          }
          aggregate: {
            args: Prisma.MaterialRequestItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMaterialRequestItem>
          }
          groupBy: {
            args: Prisma.MaterialRequestItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<MaterialRequestItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.MaterialRequestItemCountArgs<ExtArgs>
            result: $Utils.Optional<MaterialRequestItemCountAggregateOutputType> | number
          }
        }
      }
      RFQ: {
        payload: Prisma.$RFQPayload<ExtArgs>
        fields: Prisma.RFQFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RFQFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RFQPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RFQFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RFQPayload>
          }
          findFirst: {
            args: Prisma.RFQFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RFQPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RFQFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RFQPayload>
          }
          findMany: {
            args: Prisma.RFQFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RFQPayload>[]
          }
          create: {
            args: Prisma.RFQCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RFQPayload>
          }
          createMany: {
            args: Prisma.RFQCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RFQDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RFQPayload>
          }
          update: {
            args: Prisma.RFQUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RFQPayload>
          }
          deleteMany: {
            args: Prisma.RFQDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RFQUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RFQUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RFQPayload>
          }
          aggregate: {
            args: Prisma.RFQAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRFQ>
          }
          groupBy: {
            args: Prisma.RFQGroupByArgs<ExtArgs>
            result: $Utils.Optional<RFQGroupByOutputType>[]
          }
          count: {
            args: Prisma.RFQCountArgs<ExtArgs>
            result: $Utils.Optional<RFQCountAggregateOutputType> | number
          }
        }
      }
      RFQItem: {
        payload: Prisma.$RFQItemPayload<ExtArgs>
        fields: Prisma.RFQItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RFQItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RFQItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RFQItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RFQItemPayload>
          }
          findFirst: {
            args: Prisma.RFQItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RFQItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RFQItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RFQItemPayload>
          }
          findMany: {
            args: Prisma.RFQItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RFQItemPayload>[]
          }
          create: {
            args: Prisma.RFQItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RFQItemPayload>
          }
          createMany: {
            args: Prisma.RFQItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RFQItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RFQItemPayload>
          }
          update: {
            args: Prisma.RFQItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RFQItemPayload>
          }
          deleteMany: {
            args: Prisma.RFQItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RFQItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RFQItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RFQItemPayload>
          }
          aggregate: {
            args: Prisma.RFQItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRFQItem>
          }
          groupBy: {
            args: Prisma.RFQItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<RFQItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.RFQItemCountArgs<ExtArgs>
            result: $Utils.Optional<RFQItemCountAggregateOutputType> | number
          }
        }
      }
      Supplier: {
        payload: Prisma.$SupplierPayload<ExtArgs>
        fields: Prisma.SupplierFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SupplierFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SupplierFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          findFirst: {
            args: Prisma.SupplierFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SupplierFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          findMany: {
            args: Prisma.SupplierFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>[]
          }
          create: {
            args: Prisma.SupplierCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          createMany: {
            args: Prisma.SupplierCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SupplierDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          update: {
            args: Prisma.SupplierUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          deleteMany: {
            args: Prisma.SupplierDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SupplierUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SupplierUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          aggregate: {
            args: Prisma.SupplierAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSupplier>
          }
          groupBy: {
            args: Prisma.SupplierGroupByArgs<ExtArgs>
            result: $Utils.Optional<SupplierGroupByOutputType>[]
          }
          count: {
            args: Prisma.SupplierCountArgs<ExtArgs>
            result: $Utils.Optional<SupplierCountAggregateOutputType> | number
          }
        }
      }
      Material: {
        payload: Prisma.$MaterialPayload<ExtArgs>
        fields: Prisma.MaterialFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MaterialFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MaterialFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>
          }
          findFirst: {
            args: Prisma.MaterialFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MaterialFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>
          }
          findMany: {
            args: Prisma.MaterialFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>[]
          }
          create: {
            args: Prisma.MaterialCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>
          }
          createMany: {
            args: Prisma.MaterialCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MaterialDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>
          }
          update: {
            args: Prisma.MaterialUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>
          }
          deleteMany: {
            args: Prisma.MaterialDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MaterialUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MaterialUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>
          }
          aggregate: {
            args: Prisma.MaterialAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMaterial>
          }
          groupBy: {
            args: Prisma.MaterialGroupByArgs<ExtArgs>
            result: $Utils.Optional<MaterialGroupByOutputType>[]
          }
          count: {
            args: Prisma.MaterialCountArgs<ExtArgs>
            result: $Utils.Optional<MaterialCountAggregateOutputType> | number
          }
        }
      }
      Unit: {
        payload: Prisma.$UnitPayload<ExtArgs>
        fields: Prisma.UnitFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UnitFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UnitFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          findFirst: {
            args: Prisma.UnitFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UnitFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          findMany: {
            args: Prisma.UnitFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>[]
          }
          create: {
            args: Prisma.UnitCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          createMany: {
            args: Prisma.UnitCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UnitDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          update: {
            args: Prisma.UnitUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          deleteMany: {
            args: Prisma.UnitDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UnitUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UnitUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          aggregate: {
            args: Prisma.UnitAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUnit>
          }
          groupBy: {
            args: Prisma.UnitGroupByArgs<ExtArgs>
            result: $Utils.Optional<UnitGroupByOutputType>[]
          }
          count: {
            args: Prisma.UnitCountArgs<ExtArgs>
            result: $Utils.Optional<UnitCountAggregateOutputType> | number
          }
        }
      }
      Category: {
        payload: Prisma.$CategoryPayload<ExtArgs>
        fields: Prisma.CategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findFirst: {
            args: Prisma.CategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findMany: {
            args: Prisma.CategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          create: {
            args: Prisma.CategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          createMany: {
            args: Prisma.CategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          update: {
            args: Prisma.CategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          deleteMany: {
            args: Prisma.CategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          aggregate: {
            args: Prisma.CategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategory>
          }
          groupBy: {
            args: Prisma.CategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CategoryCountArgs<ExtArgs>
            result: $Utils.Optional<CategoryCountAggregateOutputType> | number
          }
        }
      }
      Warehouse: {
        payload: Prisma.$WarehousePayload<ExtArgs>
        fields: Prisma.WarehouseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WarehouseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WarehouseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload>
          }
          findFirst: {
            args: Prisma.WarehouseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WarehouseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload>
          }
          findMany: {
            args: Prisma.WarehouseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload>[]
          }
          create: {
            args: Prisma.WarehouseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload>
          }
          createMany: {
            args: Prisma.WarehouseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.WarehouseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload>
          }
          update: {
            args: Prisma.WarehouseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload>
          }
          deleteMany: {
            args: Prisma.WarehouseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WarehouseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WarehouseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload>
          }
          aggregate: {
            args: Prisma.WarehouseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWarehouse>
          }
          groupBy: {
            args: Prisma.WarehouseGroupByArgs<ExtArgs>
            result: $Utils.Optional<WarehouseGroupByOutputType>[]
          }
          count: {
            args: Prisma.WarehouseCountArgs<ExtArgs>
            result: $Utils.Optional<WarehouseCountAggregateOutputType> | number
          }
        }
      }
      SupplierQuotation: {
        payload: Prisma.$SupplierQuotationPayload<ExtArgs>
        fields: Prisma.SupplierQuotationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SupplierQuotationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierQuotationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SupplierQuotationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierQuotationPayload>
          }
          findFirst: {
            args: Prisma.SupplierQuotationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierQuotationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SupplierQuotationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierQuotationPayload>
          }
          findMany: {
            args: Prisma.SupplierQuotationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierQuotationPayload>[]
          }
          create: {
            args: Prisma.SupplierQuotationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierQuotationPayload>
          }
          createMany: {
            args: Prisma.SupplierQuotationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SupplierQuotationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierQuotationPayload>
          }
          update: {
            args: Prisma.SupplierQuotationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierQuotationPayload>
          }
          deleteMany: {
            args: Prisma.SupplierQuotationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SupplierQuotationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SupplierQuotationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierQuotationPayload>
          }
          aggregate: {
            args: Prisma.SupplierQuotationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSupplierQuotation>
          }
          groupBy: {
            args: Prisma.SupplierQuotationGroupByArgs<ExtArgs>
            result: $Utils.Optional<SupplierQuotationGroupByOutputType>[]
          }
          count: {
            args: Prisma.SupplierQuotationCountArgs<ExtArgs>
            result: $Utils.Optional<SupplierQuotationCountAggregateOutputType> | number
          }
        }
      }
      QuotationItem: {
        payload: Prisma.$QuotationItemPayload<ExtArgs>
        fields: Prisma.QuotationItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuotationItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuotationItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationItemPayload>
          }
          findFirst: {
            args: Prisma.QuotationItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuotationItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationItemPayload>
          }
          findMany: {
            args: Prisma.QuotationItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationItemPayload>[]
          }
          create: {
            args: Prisma.QuotationItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationItemPayload>
          }
          createMany: {
            args: Prisma.QuotationItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.QuotationItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationItemPayload>
          }
          update: {
            args: Prisma.QuotationItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationItemPayload>
          }
          deleteMany: {
            args: Prisma.QuotationItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuotationItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.QuotationItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationItemPayload>
          }
          aggregate: {
            args: Prisma.QuotationItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuotationItem>
          }
          groupBy: {
            args: Prisma.QuotationItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuotationItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuotationItemCountArgs<ExtArgs>
            result: $Utils.Optional<QuotationItemCountAggregateOutputType> | number
          }
        }
      }
      PurchaseOrder: {
        payload: Prisma.$PurchaseOrderPayload<ExtArgs>
        fields: Prisma.PurchaseOrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PurchaseOrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PurchaseOrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          findFirst: {
            args: Prisma.PurchaseOrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PurchaseOrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          findMany: {
            args: Prisma.PurchaseOrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>[]
          }
          create: {
            args: Prisma.PurchaseOrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          createMany: {
            args: Prisma.PurchaseOrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PurchaseOrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          update: {
            args: Prisma.PurchaseOrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          deleteMany: {
            args: Prisma.PurchaseOrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PurchaseOrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PurchaseOrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          aggregate: {
            args: Prisma.PurchaseOrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePurchaseOrder>
          }
          groupBy: {
            args: Prisma.PurchaseOrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<PurchaseOrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.PurchaseOrderCountArgs<ExtArgs>
            result: $Utils.Optional<PurchaseOrderCountAggregateOutputType> | number
          }
        }
      }
      PurchaseOrderItem: {
        payload: Prisma.$PurchaseOrderItemPayload<ExtArgs>
        fields: Prisma.PurchaseOrderItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PurchaseOrderItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PurchaseOrderItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderItemPayload>
          }
          findFirst: {
            args: Prisma.PurchaseOrderItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PurchaseOrderItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderItemPayload>
          }
          findMany: {
            args: Prisma.PurchaseOrderItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderItemPayload>[]
          }
          create: {
            args: Prisma.PurchaseOrderItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderItemPayload>
          }
          createMany: {
            args: Prisma.PurchaseOrderItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PurchaseOrderItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderItemPayload>
          }
          update: {
            args: Prisma.PurchaseOrderItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderItemPayload>
          }
          deleteMany: {
            args: Prisma.PurchaseOrderItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PurchaseOrderItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PurchaseOrderItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderItemPayload>
          }
          aggregate: {
            args: Prisma.PurchaseOrderItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePurchaseOrderItem>
          }
          groupBy: {
            args: Prisma.PurchaseOrderItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<PurchaseOrderItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.PurchaseOrderItemCountArgs<ExtArgs>
            result: $Utils.Optional<PurchaseOrderItemCountAggregateOutputType> | number
          }
        }
      }
      ReceivingReport: {
        payload: Prisma.$ReceivingReportPayload<ExtArgs>
        fields: Prisma.ReceivingReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReceivingReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceivingReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReceivingReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceivingReportPayload>
          }
          findFirst: {
            args: Prisma.ReceivingReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceivingReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReceivingReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceivingReportPayload>
          }
          findMany: {
            args: Prisma.ReceivingReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceivingReportPayload>[]
          }
          create: {
            args: Prisma.ReceivingReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceivingReportPayload>
          }
          createMany: {
            args: Prisma.ReceivingReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ReceivingReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceivingReportPayload>
          }
          update: {
            args: Prisma.ReceivingReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceivingReportPayload>
          }
          deleteMany: {
            args: Prisma.ReceivingReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReceivingReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReceivingReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceivingReportPayload>
          }
          aggregate: {
            args: Prisma.ReceivingReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReceivingReport>
          }
          groupBy: {
            args: Prisma.ReceivingReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReceivingReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReceivingReportCountArgs<ExtArgs>
            result: $Utils.Optional<ReceivingReportCountAggregateOutputType> | number
          }
        }
      }
      ReceivingItem: {
        payload: Prisma.$ReceivingItemPayload<ExtArgs>
        fields: Prisma.ReceivingItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReceivingItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceivingItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReceivingItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceivingItemPayload>
          }
          findFirst: {
            args: Prisma.ReceivingItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceivingItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReceivingItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceivingItemPayload>
          }
          findMany: {
            args: Prisma.ReceivingItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceivingItemPayload>[]
          }
          create: {
            args: Prisma.ReceivingItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceivingItemPayload>
          }
          createMany: {
            args: Prisma.ReceivingItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ReceivingItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceivingItemPayload>
          }
          update: {
            args: Prisma.ReceivingItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceivingItemPayload>
          }
          deleteMany: {
            args: Prisma.ReceivingItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReceivingItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReceivingItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceivingItemPayload>
          }
          aggregate: {
            args: Prisma.ReceivingItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReceivingItem>
          }
          groupBy: {
            args: Prisma.ReceivingItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReceivingItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReceivingItemCountArgs<ExtArgs>
            result: $Utils.Optional<ReceivingItemCountAggregateOutputType> | number
          }
        }
      }
      InventoryItem: {
        payload: Prisma.$InventoryItemPayload<ExtArgs>
        fields: Prisma.InventoryItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InventoryItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InventoryItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>
          }
          findFirst: {
            args: Prisma.InventoryItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InventoryItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>
          }
          findMany: {
            args: Prisma.InventoryItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>[]
          }
          create: {
            args: Prisma.InventoryItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>
          }
          createMany: {
            args: Prisma.InventoryItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.InventoryItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>
          }
          update: {
            args: Prisma.InventoryItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>
          }
          deleteMany: {
            args: Prisma.InventoryItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InventoryItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InventoryItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>
          }
          aggregate: {
            args: Prisma.InventoryItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInventoryItem>
          }
          groupBy: {
            args: Prisma.InventoryItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<InventoryItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.InventoryItemCountArgs<ExtArgs>
            result: $Utils.Optional<InventoryItemCountAggregateOutputType> | number
          }
        }
      }
      WorkflowRule: {
        payload: Prisma.$WorkflowRulePayload<ExtArgs>
        fields: Prisma.WorkflowRuleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkflowRuleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowRulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkflowRuleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowRulePayload>
          }
          findFirst: {
            args: Prisma.WorkflowRuleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowRulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkflowRuleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowRulePayload>
          }
          findMany: {
            args: Prisma.WorkflowRuleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowRulePayload>[]
          }
          create: {
            args: Prisma.WorkflowRuleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowRulePayload>
          }
          createMany: {
            args: Prisma.WorkflowRuleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.WorkflowRuleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowRulePayload>
          }
          update: {
            args: Prisma.WorkflowRuleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowRulePayload>
          }
          deleteMany: {
            args: Prisma.WorkflowRuleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkflowRuleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WorkflowRuleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowRulePayload>
          }
          aggregate: {
            args: Prisma.WorkflowRuleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkflowRule>
          }
          groupBy: {
            args: Prisma.WorkflowRuleGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkflowRuleGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkflowRuleCountArgs<ExtArgs>
            result: $Utils.Optional<WorkflowRuleCountAggregateOutputType> | number
          }
        }
      }
      SupplierInvoice: {
        payload: Prisma.$SupplierInvoicePayload<ExtArgs>
        fields: Prisma.SupplierInvoiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SupplierInvoiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierInvoicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SupplierInvoiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierInvoicePayload>
          }
          findFirst: {
            args: Prisma.SupplierInvoiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierInvoicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SupplierInvoiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierInvoicePayload>
          }
          findMany: {
            args: Prisma.SupplierInvoiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierInvoicePayload>[]
          }
          create: {
            args: Prisma.SupplierInvoiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierInvoicePayload>
          }
          createMany: {
            args: Prisma.SupplierInvoiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SupplierInvoiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierInvoicePayload>
          }
          update: {
            args: Prisma.SupplierInvoiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierInvoicePayload>
          }
          deleteMany: {
            args: Prisma.SupplierInvoiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SupplierInvoiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SupplierInvoiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierInvoicePayload>
          }
          aggregate: {
            args: Prisma.SupplierInvoiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSupplierInvoice>
          }
          groupBy: {
            args: Prisma.SupplierInvoiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<SupplierInvoiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.SupplierInvoiceCountArgs<ExtArgs>
            result: $Utils.Optional<SupplierInvoiceCountAggregateOutputType> | number
          }
        }
      }
      Disbursement: {
        payload: Prisma.$DisbursementPayload<ExtArgs>
        fields: Prisma.DisbursementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DisbursementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisbursementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DisbursementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisbursementPayload>
          }
          findFirst: {
            args: Prisma.DisbursementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisbursementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DisbursementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisbursementPayload>
          }
          findMany: {
            args: Prisma.DisbursementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisbursementPayload>[]
          }
          create: {
            args: Prisma.DisbursementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisbursementPayload>
          }
          createMany: {
            args: Prisma.DisbursementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DisbursementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisbursementPayload>
          }
          update: {
            args: Prisma.DisbursementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisbursementPayload>
          }
          deleteMany: {
            args: Prisma.DisbursementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DisbursementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DisbursementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisbursementPayload>
          }
          aggregate: {
            args: Prisma.DisbursementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDisbursement>
          }
          groupBy: {
            args: Prisma.DisbursementGroupByArgs<ExtArgs>
            result: $Utils.Optional<DisbursementGroupByOutputType>[]
          }
          count: {
            args: Prisma.DisbursementCountArgs<ExtArgs>
            result: $Utils.Optional<DisbursementCountAggregateOutputType> | number
          }
        }
      }
      FinancialTransaction: {
        payload: Prisma.$FinancialTransactionPayload<ExtArgs>
        fields: Prisma.FinancialTransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FinancialTransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialTransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FinancialTransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialTransactionPayload>
          }
          findFirst: {
            args: Prisma.FinancialTransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialTransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FinancialTransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialTransactionPayload>
          }
          findMany: {
            args: Prisma.FinancialTransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialTransactionPayload>[]
          }
          create: {
            args: Prisma.FinancialTransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialTransactionPayload>
          }
          createMany: {
            args: Prisma.FinancialTransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.FinancialTransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialTransactionPayload>
          }
          update: {
            args: Prisma.FinancialTransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialTransactionPayload>
          }
          deleteMany: {
            args: Prisma.FinancialTransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FinancialTransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FinancialTransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialTransactionPayload>
          }
          aggregate: {
            args: Prisma.FinancialTransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFinancialTransaction>
          }
          groupBy: {
            args: Prisma.FinancialTransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<FinancialTransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.FinancialTransactionCountArgs<ExtArgs>
            result: $Utils.Optional<FinancialTransactionCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    purchaseOrders: number
    poApprovals: number
    materialRequests: number
    mrApprovals: number
    rfqsCreated: number
    receivedItems: number
    disbursements: number
    projectMembers: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchaseOrders?: boolean | UserCountOutputTypeCountPurchaseOrdersArgs
    poApprovals?: boolean | UserCountOutputTypeCountPoApprovalsArgs
    materialRequests?: boolean | UserCountOutputTypeCountMaterialRequestsArgs
    mrApprovals?: boolean | UserCountOutputTypeCountMrApprovalsArgs
    rfqsCreated?: boolean | UserCountOutputTypeCountRfqsCreatedArgs
    receivedItems?: boolean | UserCountOutputTypeCountReceivedItemsArgs
    disbursements?: boolean | UserCountOutputTypeCountDisbursementsArgs
    projectMembers?: boolean | UserCountOutputTypeCountProjectMembersArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPurchaseOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseOrderWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPoApprovalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseOrderWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMaterialRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaterialRequestWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMrApprovalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaterialRequestWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRfqsCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RFQWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReceivedItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReceivingReportWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDisbursementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DisbursementWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProjectMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectMemberWhereInput
  }


  /**
   * Count Type ClientCountOutputType
   */

  export type ClientCountOutputType = {
    projects: number
  }

  export type ClientCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projects?: boolean | ClientCountOutputTypeCountProjectsArgs
  }

  // Custom InputTypes
  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientCountOutputType
     */
    select?: ClientCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
  }


  /**
   * Count Type ProjectCountOutputType
   */

  export type ProjectCountOutputType = {
    transactions: number
    inventory: number
    teamMembers: number
    boqItems: number
    purchaseOrders: number
    materialRequests: number
  }

  export type ProjectCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | ProjectCountOutputTypeCountTransactionsArgs
    inventory?: boolean | ProjectCountOutputTypeCountInventoryArgs
    teamMembers?: boolean | ProjectCountOutputTypeCountTeamMembersArgs
    boqItems?: boolean | ProjectCountOutputTypeCountBoqItemsArgs
    purchaseOrders?: boolean | ProjectCountOutputTypeCountPurchaseOrdersArgs
    materialRequests?: boolean | ProjectCountOutputTypeCountMaterialRequestsArgs
  }

  // Custom InputTypes
  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectCountOutputType
     */
    select?: ProjectCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FinancialTransactionWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountInventoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryItemWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountTeamMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectMemberWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountBoqItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BoqItemWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountPurchaseOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseOrderWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountMaterialRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaterialRequestWhereInput
  }


  /**
   * Count Type BoqItemCountOutputType
   */

  export type BoqItemCountOutputType = {
    boqComponents: number
  }

  export type BoqItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    boqComponents?: boolean | BoqItemCountOutputTypeCountBoqComponentsArgs
  }

  // Custom InputTypes
  /**
   * BoqItemCountOutputType without action
   */
  export type BoqItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoqItemCountOutputType
     */
    select?: BoqItemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BoqItemCountOutputType without action
   */
  export type BoqItemCountOutputTypeCountBoqComponentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BoqItemComponentWhereInput
  }


  /**
   * Count Type MaterialRequestCountOutputType
   */

  export type MaterialRequestCountOutputType = {
    items: number
    rfqs: number
  }

  export type MaterialRequestCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | MaterialRequestCountOutputTypeCountItemsArgs
    rfqs?: boolean | MaterialRequestCountOutputTypeCountRfqsArgs
  }

  // Custom InputTypes
  /**
   * MaterialRequestCountOutputType without action
   */
  export type MaterialRequestCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialRequestCountOutputType
     */
    select?: MaterialRequestCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MaterialRequestCountOutputType without action
   */
  export type MaterialRequestCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaterialRequestItemWhereInput
  }

  /**
   * MaterialRequestCountOutputType without action
   */
  export type MaterialRequestCountOutputTypeCountRfqsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RFQWhereInput
  }


  /**
   * Count Type RFQCountOutputType
   */

  export type RFQCountOutputType = {
    items: number
    quotations: number
  }

  export type RFQCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | RFQCountOutputTypeCountItemsArgs
    quotations?: boolean | RFQCountOutputTypeCountQuotationsArgs
  }

  // Custom InputTypes
  /**
   * RFQCountOutputType without action
   */
  export type RFQCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RFQCountOutputType
     */
    select?: RFQCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RFQCountOutputType without action
   */
  export type RFQCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RFQItemWhereInput
  }

  /**
   * RFQCountOutputType without action
   */
  export type RFQCountOutputTypeCountQuotationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupplierQuotationWhereInput
  }


  /**
   * Count Type SupplierCountOutputType
   */

  export type SupplierCountOutputType = {
    quotations: number
    purchaseOrders: number
    invoices: number
  }

  export type SupplierCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quotations?: boolean | SupplierCountOutputTypeCountQuotationsArgs
    purchaseOrders?: boolean | SupplierCountOutputTypeCountPurchaseOrdersArgs
    invoices?: boolean | SupplierCountOutputTypeCountInvoicesArgs
  }

  // Custom InputTypes
  /**
   * SupplierCountOutputType without action
   */
  export type SupplierCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierCountOutputType
     */
    select?: SupplierCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SupplierCountOutputType without action
   */
  export type SupplierCountOutputTypeCountQuotationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupplierQuotationWhereInput
  }

  /**
   * SupplierCountOutputType without action
   */
  export type SupplierCountOutputTypeCountPurchaseOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseOrderWhereInput
  }

  /**
   * SupplierCountOutputType without action
   */
  export type SupplierCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupplierInvoiceWhereInput
  }


  /**
   * Count Type WarehouseCountOutputType
   */

  export type WarehouseCountOutputType = {
    inventory: number
  }

  export type WarehouseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inventory?: boolean | WarehouseCountOutputTypeCountInventoryArgs
  }

  // Custom InputTypes
  /**
   * WarehouseCountOutputType without action
   */
  export type WarehouseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseCountOutputType
     */
    select?: WarehouseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WarehouseCountOutputType without action
   */
  export type WarehouseCountOutputTypeCountInventoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryItemWhereInput
  }


  /**
   * Count Type SupplierQuotationCountOutputType
   */

  export type SupplierQuotationCountOutputType = {
    items: number
  }

  export type SupplierQuotationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | SupplierQuotationCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * SupplierQuotationCountOutputType without action
   */
  export type SupplierQuotationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierQuotationCountOutputType
     */
    select?: SupplierQuotationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SupplierQuotationCountOutputType without action
   */
  export type SupplierQuotationCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuotationItemWhereInput
  }


  /**
   * Count Type PurchaseOrderCountOutputType
   */

  export type PurchaseOrderCountOutputType = {
    items: number
    receiving: number
    invoices: number
    disbursements: number
  }

  export type PurchaseOrderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | PurchaseOrderCountOutputTypeCountItemsArgs
    receiving?: boolean | PurchaseOrderCountOutputTypeCountReceivingArgs
    invoices?: boolean | PurchaseOrderCountOutputTypeCountInvoicesArgs
    disbursements?: boolean | PurchaseOrderCountOutputTypeCountDisbursementsArgs
  }

  // Custom InputTypes
  /**
   * PurchaseOrderCountOutputType without action
   */
  export type PurchaseOrderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderCountOutputType
     */
    select?: PurchaseOrderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PurchaseOrderCountOutputType without action
   */
  export type PurchaseOrderCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseOrderItemWhereInput
  }

  /**
   * PurchaseOrderCountOutputType without action
   */
  export type PurchaseOrderCountOutputTypeCountReceivingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReceivingReportWhereInput
  }

  /**
   * PurchaseOrderCountOutputType without action
   */
  export type PurchaseOrderCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupplierInvoiceWhereInput
  }

  /**
   * PurchaseOrderCountOutputType without action
   */
  export type PurchaseOrderCountOutputTypeCountDisbursementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DisbursementWhereInput
  }


  /**
   * Count Type ReceivingReportCountOutputType
   */

  export type ReceivingReportCountOutputType = {
    items: number
    invoices: number
  }

  export type ReceivingReportCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | ReceivingReportCountOutputTypeCountItemsArgs
    invoices?: boolean | ReceivingReportCountOutputTypeCountInvoicesArgs
  }

  // Custom InputTypes
  /**
   * ReceivingReportCountOutputType without action
   */
  export type ReceivingReportCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceivingReportCountOutputType
     */
    select?: ReceivingReportCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ReceivingReportCountOutputType without action
   */
  export type ReceivingReportCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReceivingItemWhereInput
  }

  /**
   * ReceivingReportCountOutputType without action
   */
  export type ReceivingReportCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupplierInvoiceWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    email: string | null
    name: string | null
    password: string | null
    role: $Enums.UserRole | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    email: string | null
    name: string | null
    password: string | null
    role: $Enums.UserRole | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    name: number
    password: number
    role: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    email: string
    name: string
    password: string
    role: $Enums.UserRole
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    purchaseOrders?: boolean | User$purchaseOrdersArgs<ExtArgs>
    poApprovals?: boolean | User$poApprovalsArgs<ExtArgs>
    materialRequests?: boolean | User$materialRequestsArgs<ExtArgs>
    mrApprovals?: boolean | User$mrApprovalsArgs<ExtArgs>
    rfqsCreated?: boolean | User$rfqsCreatedArgs<ExtArgs>
    receivedItems?: boolean | User$receivedItemsArgs<ExtArgs>
    disbursements?: boolean | User$disbursementsArgs<ExtArgs>
    projectMembers?: boolean | User$projectMembersArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>


  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchaseOrders?: boolean | User$purchaseOrdersArgs<ExtArgs>
    poApprovals?: boolean | User$poApprovalsArgs<ExtArgs>
    materialRequests?: boolean | User$materialRequestsArgs<ExtArgs>
    mrApprovals?: boolean | User$mrApprovalsArgs<ExtArgs>
    rfqsCreated?: boolean | User$rfqsCreatedArgs<ExtArgs>
    receivedItems?: boolean | User$receivedItemsArgs<ExtArgs>
    disbursements?: boolean | User$disbursementsArgs<ExtArgs>
    projectMembers?: boolean | User$projectMembersArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      purchaseOrders: Prisma.$PurchaseOrderPayload<ExtArgs>[]
      poApprovals: Prisma.$PurchaseOrderPayload<ExtArgs>[]
      materialRequests: Prisma.$MaterialRequestPayload<ExtArgs>[]
      mrApprovals: Prisma.$MaterialRequestPayload<ExtArgs>[]
      rfqsCreated: Prisma.$RFQPayload<ExtArgs>[]
      receivedItems: Prisma.$ReceivingReportPayload<ExtArgs>[]
      disbursements: Prisma.$DisbursementPayload<ExtArgs>[]
      projectMembers: Prisma.$ProjectMemberPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      email: string
      name: string
      password: string
      role: $Enums.UserRole
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    purchaseOrders<T extends User$purchaseOrdersArgs<ExtArgs> = {}>(args?: Subset<T, User$purchaseOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findMany"> | Null>
    poApprovals<T extends User$poApprovalsArgs<ExtArgs> = {}>(args?: Subset<T, User$poApprovalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findMany"> | Null>
    materialRequests<T extends User$materialRequestsArgs<ExtArgs> = {}>(args?: Subset<T, User$materialRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialRequestPayload<ExtArgs>, T, "findMany"> | Null>
    mrApprovals<T extends User$mrApprovalsArgs<ExtArgs> = {}>(args?: Subset<T, User$mrApprovalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialRequestPayload<ExtArgs>, T, "findMany"> | Null>
    rfqsCreated<T extends User$rfqsCreatedArgs<ExtArgs> = {}>(args?: Subset<T, User$rfqsCreatedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RFQPayload<ExtArgs>, T, "findMany"> | Null>
    receivedItems<T extends User$receivedItemsArgs<ExtArgs> = {}>(args?: Subset<T, User$receivedItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReceivingReportPayload<ExtArgs>, T, "findMany"> | Null>
    disbursements<T extends User$disbursementsArgs<ExtArgs> = {}>(args?: Subset<T, User$disbursementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DisbursementPayload<ExtArgs>, T, "findMany"> | Null>
    projectMembers<T extends User$projectMembersArgs<ExtArgs> = {}>(args?: Subset<T, User$projectMembersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly email: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.purchaseOrders
   */
  export type User$purchaseOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    where?: PurchaseOrderWhereInput
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    cursor?: PurchaseOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseOrderScalarFieldEnum | PurchaseOrderScalarFieldEnum[]
  }

  /**
   * User.poApprovals
   */
  export type User$poApprovalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    where?: PurchaseOrderWhereInput
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    cursor?: PurchaseOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseOrderScalarFieldEnum | PurchaseOrderScalarFieldEnum[]
  }

  /**
   * User.materialRequests
   */
  export type User$materialRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialRequest
     */
    select?: MaterialRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialRequestInclude<ExtArgs> | null
    where?: MaterialRequestWhereInput
    orderBy?: MaterialRequestOrderByWithRelationInput | MaterialRequestOrderByWithRelationInput[]
    cursor?: MaterialRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MaterialRequestScalarFieldEnum | MaterialRequestScalarFieldEnum[]
  }

  /**
   * User.mrApprovals
   */
  export type User$mrApprovalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialRequest
     */
    select?: MaterialRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialRequestInclude<ExtArgs> | null
    where?: MaterialRequestWhereInput
    orderBy?: MaterialRequestOrderByWithRelationInput | MaterialRequestOrderByWithRelationInput[]
    cursor?: MaterialRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MaterialRequestScalarFieldEnum | MaterialRequestScalarFieldEnum[]
  }

  /**
   * User.rfqsCreated
   */
  export type User$rfqsCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RFQ
     */
    select?: RFQSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RFQInclude<ExtArgs> | null
    where?: RFQWhereInput
    orderBy?: RFQOrderByWithRelationInput | RFQOrderByWithRelationInput[]
    cursor?: RFQWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RFQScalarFieldEnum | RFQScalarFieldEnum[]
  }

  /**
   * User.receivedItems
   */
  export type User$receivedItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceivingReport
     */
    select?: ReceivingReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceivingReportInclude<ExtArgs> | null
    where?: ReceivingReportWhereInput
    orderBy?: ReceivingReportOrderByWithRelationInput | ReceivingReportOrderByWithRelationInput[]
    cursor?: ReceivingReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReceivingReportScalarFieldEnum | ReceivingReportScalarFieldEnum[]
  }

  /**
   * User.disbursements
   */
  export type User$disbursementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Disbursement
     */
    select?: DisbursementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisbursementInclude<ExtArgs> | null
    where?: DisbursementWhereInput
    orderBy?: DisbursementOrderByWithRelationInput | DisbursementOrderByWithRelationInput[]
    cursor?: DisbursementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DisbursementScalarFieldEnum | DisbursementScalarFieldEnum[]
  }

  /**
   * User.projectMembers
   */
  export type User$projectMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    where?: ProjectMemberWhereInput
    orderBy?: ProjectMemberOrderByWithRelationInput | ProjectMemberOrderByWithRelationInput[]
    cursor?: ProjectMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectMemberScalarFieldEnum | ProjectMemberScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Company
   */

  export type AggregateCompany = {
    _count: CompanyCountAggregateOutputType | null
    _avg: CompanyAvgAggregateOutputType | null
    _sum: CompanySumAggregateOutputType | null
    _min: CompanyMinAggregateOutputType | null
    _max: CompanyMaxAggregateOutputType | null
  }

  export type CompanyAvgAggregateOutputType = {
    id: number | null
  }

  export type CompanySumAggregateOutputType = {
    id: number | null
  }

  export type CompanyMinAggregateOutputType = {
    id: number | null
    name: string | null
    address: string | null
    taxId: string | null
    currency: string | null
    logoUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CompanyMaxAggregateOutputType = {
    id: number | null
    name: string | null
    address: string | null
    taxId: string | null
    currency: string | null
    logoUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CompanyCountAggregateOutputType = {
    id: number
    name: number
    address: number
    taxId: number
    currency: number
    logoUrl: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CompanyAvgAggregateInputType = {
    id?: true
  }

  export type CompanySumAggregateInputType = {
    id?: true
  }

  export type CompanyMinAggregateInputType = {
    id?: true
    name?: true
    address?: true
    taxId?: true
    currency?: true
    logoUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CompanyMaxAggregateInputType = {
    id?: true
    name?: true
    address?: true
    taxId?: true
    currency?: true
    logoUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CompanyCountAggregateInputType = {
    id?: true
    name?: true
    address?: true
    taxId?: true
    currency?: true
    logoUrl?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CompanyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Company to aggregate.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Companies
    **/
    _count?: true | CompanyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CompanyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CompanySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyMaxAggregateInputType
  }

  export type GetCompanyAggregateType<T extends CompanyAggregateArgs> = {
        [P in keyof T & keyof AggregateCompany]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompany[P]>
      : GetScalarType<T[P], AggregateCompany[P]>
  }




  export type CompanyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyWhereInput
    orderBy?: CompanyOrderByWithAggregationInput | CompanyOrderByWithAggregationInput[]
    by: CompanyScalarFieldEnum[] | CompanyScalarFieldEnum
    having?: CompanyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyCountAggregateInputType | true
    _avg?: CompanyAvgAggregateInputType
    _sum?: CompanySumAggregateInputType
    _min?: CompanyMinAggregateInputType
    _max?: CompanyMaxAggregateInputType
  }

  export type CompanyGroupByOutputType = {
    id: number
    name: string
    address: string | null
    taxId: string | null
    currency: string
    logoUrl: string | null
    createdAt: Date
    updatedAt: Date
    _count: CompanyCountAggregateOutputType | null
    _avg: CompanyAvgAggregateOutputType | null
    _sum: CompanySumAggregateOutputType | null
    _min: CompanyMinAggregateOutputType | null
    _max: CompanyMaxAggregateOutputType | null
  }

  type GetCompanyGroupByPayload<T extends CompanyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyGroupByOutputType[P]>
        }
      >
    >


  export type CompanySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    taxId?: boolean
    currency?: boolean
    logoUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["company"]>


  export type CompanySelectScalar = {
    id?: boolean
    name?: boolean
    address?: boolean
    taxId?: boolean
    currency?: boolean
    logoUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $CompanyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Company"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      address: string | null
      taxId: string | null
      currency: string
      logoUrl: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["company"]>
    composites: {}
  }

  type CompanyGetPayload<S extends boolean | null | undefined | CompanyDefaultArgs> = $Result.GetResult<Prisma.$CompanyPayload, S>

  type CompanyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CompanyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CompanyCountAggregateInputType | true
    }

  export interface CompanyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Company'], meta: { name: 'Company' } }
    /**
     * Find zero or one Company that matches the filter.
     * @param {CompanyFindUniqueArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompanyFindUniqueArgs>(args: SelectSubset<T, CompanyFindUniqueArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Company that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CompanyFindUniqueOrThrowArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompanyFindUniqueOrThrowArgs>(args: SelectSubset<T, CompanyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Company that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindFirstArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompanyFindFirstArgs>(args?: SelectSubset<T, CompanyFindFirstArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Company that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindFirstOrThrowArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompanyFindFirstOrThrowArgs>(args?: SelectSubset<T, CompanyFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Companies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Companies
     * const companies = await prisma.company.findMany()
     * 
     * // Get first 10 Companies
     * const companies = await prisma.company.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companyWithIdOnly = await prisma.company.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CompanyFindManyArgs>(args?: SelectSubset<T, CompanyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Company.
     * @param {CompanyCreateArgs} args - Arguments to create a Company.
     * @example
     * // Create one Company
     * const Company = await prisma.company.create({
     *   data: {
     *     // ... data to create a Company
     *   }
     * })
     * 
     */
    create<T extends CompanyCreateArgs>(args: SelectSubset<T, CompanyCreateArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Companies.
     * @param {CompanyCreateManyArgs} args - Arguments to create many Companies.
     * @example
     * // Create many Companies
     * const company = await prisma.company.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompanyCreateManyArgs>(args?: SelectSubset<T, CompanyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Company.
     * @param {CompanyDeleteArgs} args - Arguments to delete one Company.
     * @example
     * // Delete one Company
     * const Company = await prisma.company.delete({
     *   where: {
     *     // ... filter to delete one Company
     *   }
     * })
     * 
     */
    delete<T extends CompanyDeleteArgs>(args: SelectSubset<T, CompanyDeleteArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Company.
     * @param {CompanyUpdateArgs} args - Arguments to update one Company.
     * @example
     * // Update one Company
     * const company = await prisma.company.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompanyUpdateArgs>(args: SelectSubset<T, CompanyUpdateArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Companies.
     * @param {CompanyDeleteManyArgs} args - Arguments to filter Companies to delete.
     * @example
     * // Delete a few Companies
     * const { count } = await prisma.company.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompanyDeleteManyArgs>(args?: SelectSubset<T, CompanyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Companies
     * const company = await prisma.company.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompanyUpdateManyArgs>(args: SelectSubset<T, CompanyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Company.
     * @param {CompanyUpsertArgs} args - Arguments to update or create a Company.
     * @example
     * // Update or create a Company
     * const company = await prisma.company.upsert({
     *   create: {
     *     // ... data to create a Company
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Company we want to update
     *   }
     * })
     */
    upsert<T extends CompanyUpsertArgs>(args: SelectSubset<T, CompanyUpsertArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyCountArgs} args - Arguments to filter Companies to count.
     * @example
     * // Count the number of Companies
     * const count = await prisma.company.count({
     *   where: {
     *     // ... the filter for the Companies we want to count
     *   }
     * })
    **/
    count<T extends CompanyCountArgs>(
      args?: Subset<T, CompanyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyAggregateArgs>(args: Subset<T, CompanyAggregateArgs>): Prisma.PrismaPromise<GetCompanyAggregateType<T>>

    /**
     * Group by Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompanyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanyGroupByArgs['orderBy'] }
        : { orderBy?: CompanyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompanyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Company model
   */
  readonly fields: CompanyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Company.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompanyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Company model
   */ 
  interface CompanyFieldRefs {
    readonly id: FieldRef<"Company", 'Int'>
    readonly name: FieldRef<"Company", 'String'>
    readonly address: FieldRef<"Company", 'String'>
    readonly taxId: FieldRef<"Company", 'String'>
    readonly currency: FieldRef<"Company", 'String'>
    readonly logoUrl: FieldRef<"Company", 'String'>
    readonly createdAt: FieldRef<"Company", 'DateTime'>
    readonly updatedAt: FieldRef<"Company", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Company findUnique
   */
  export type CompanyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company findUniqueOrThrow
   */
  export type CompanyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company findFirst
   */
  export type CompanyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Companies.
     */
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company findFirstOrThrow
   */
  export type CompanyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Companies.
     */
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company findMany
   */
  export type CompanyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Filter, which Companies to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company create
   */
  export type CompanyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * The data needed to create a Company.
     */
    data: XOR<CompanyCreateInput, CompanyUncheckedCreateInput>
  }

  /**
   * Company createMany
   */
  export type CompanyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Companies.
     */
    data: CompanyCreateManyInput | CompanyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Company update
   */
  export type CompanyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * The data needed to update a Company.
     */
    data: XOR<CompanyUpdateInput, CompanyUncheckedUpdateInput>
    /**
     * Choose, which Company to update.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company updateMany
   */
  export type CompanyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Companies.
     */
    data: XOR<CompanyUpdateManyMutationInput, CompanyUncheckedUpdateManyInput>
    /**
     * Filter which Companies to update
     */
    where?: CompanyWhereInput
  }

  /**
   * Company upsert
   */
  export type CompanyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * The filter to search for the Company to update in case it exists.
     */
    where: CompanyWhereUniqueInput
    /**
     * In case the Company found by the `where` argument doesn't exist, create a new Company with this data.
     */
    create: XOR<CompanyCreateInput, CompanyUncheckedCreateInput>
    /**
     * In case the Company was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompanyUpdateInput, CompanyUncheckedUpdateInput>
  }

  /**
   * Company delete
   */
  export type CompanyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Filter which Company to delete.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company deleteMany
   */
  export type CompanyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Companies to delete
     */
    where?: CompanyWhereInput
  }

  /**
   * Company without action
   */
  export type CompanyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
  }


  /**
   * Model Client
   */

  export type AggregateClient = {
    _count: ClientCountAggregateOutputType | null
    _avg: ClientAvgAggregateOutputType | null
    _sum: ClientSumAggregateOutputType | null
    _min: ClientMinAggregateOutputType | null
    _max: ClientMaxAggregateOutputType | null
  }

  export type ClientAvgAggregateOutputType = {
    id: number | null
  }

  export type ClientSumAggregateOutputType = {
    id: number | null
  }

  export type ClientMinAggregateOutputType = {
    id: number | null
    name: string | null
    contactPerson: string | null
    contractType: string | null
    paymentTerms: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClientMaxAggregateOutputType = {
    id: number | null
    name: string | null
    contactPerson: string | null
    contractType: string | null
    paymentTerms: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClientCountAggregateOutputType = {
    id: number
    name: number
    contactPerson: number
    contractType: number
    paymentTerms: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ClientAvgAggregateInputType = {
    id?: true
  }

  export type ClientSumAggregateInputType = {
    id?: true
  }

  export type ClientMinAggregateInputType = {
    id?: true
    name?: true
    contactPerson?: true
    contractType?: true
    paymentTerms?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClientMaxAggregateInputType = {
    id?: true
    name?: true
    contactPerson?: true
    contractType?: true
    paymentTerms?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClientCountAggregateInputType = {
    id?: true
    name?: true
    contactPerson?: true
    contractType?: true
    paymentTerms?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ClientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Client to aggregate.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Clients
    **/
    _count?: true | ClientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClientAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClientSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientMaxAggregateInputType
  }

  export type GetClientAggregateType<T extends ClientAggregateArgs> = {
        [P in keyof T & keyof AggregateClient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClient[P]>
      : GetScalarType<T[P], AggregateClient[P]>
  }




  export type ClientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientWhereInput
    orderBy?: ClientOrderByWithAggregationInput | ClientOrderByWithAggregationInput[]
    by: ClientScalarFieldEnum[] | ClientScalarFieldEnum
    having?: ClientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientCountAggregateInputType | true
    _avg?: ClientAvgAggregateInputType
    _sum?: ClientSumAggregateInputType
    _min?: ClientMinAggregateInputType
    _max?: ClientMaxAggregateInputType
  }

  export type ClientGroupByOutputType = {
    id: number
    name: string
    contactPerson: string | null
    contractType: string | null
    paymentTerms: string | null
    createdAt: Date
    updatedAt: Date
    _count: ClientCountAggregateOutputType | null
    _avg: ClientAvgAggregateOutputType | null
    _sum: ClientSumAggregateOutputType | null
    _min: ClientMinAggregateOutputType | null
    _max: ClientMaxAggregateOutputType | null
  }

  type GetClientGroupByPayload<T extends ClientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientGroupByOutputType[P]>
            : GetScalarType<T[P], ClientGroupByOutputType[P]>
        }
      >
    >


  export type ClientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    contactPerson?: boolean
    contractType?: boolean
    paymentTerms?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projects?: boolean | Client$projectsArgs<ExtArgs>
    _count?: boolean | ClientCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["client"]>


  export type ClientSelectScalar = {
    id?: boolean
    name?: boolean
    contactPerson?: boolean
    contractType?: boolean
    paymentTerms?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ClientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projects?: boolean | Client$projectsArgs<ExtArgs>
    _count?: boolean | ClientCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ClientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Client"
    objects: {
      projects: Prisma.$ProjectPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      contactPerson: string | null
      contractType: string | null
      paymentTerms: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["client"]>
    composites: {}
  }

  type ClientGetPayload<S extends boolean | null | undefined | ClientDefaultArgs> = $Result.GetResult<Prisma.$ClientPayload, S>

  type ClientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ClientFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ClientCountAggregateInputType | true
    }

  export interface ClientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Client'], meta: { name: 'Client' } }
    /**
     * Find zero or one Client that matches the filter.
     * @param {ClientFindUniqueArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClientFindUniqueArgs>(args: SelectSubset<T, ClientFindUniqueArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Client that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ClientFindUniqueOrThrowArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClientFindUniqueOrThrowArgs>(args: SelectSubset<T, ClientFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Client that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindFirstArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClientFindFirstArgs>(args?: SelectSubset<T, ClientFindFirstArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Client that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindFirstOrThrowArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClientFindFirstOrThrowArgs>(args?: SelectSubset<T, ClientFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Clients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clients
     * const clients = await prisma.client.findMany()
     * 
     * // Get first 10 Clients
     * const clients = await prisma.client.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clientWithIdOnly = await prisma.client.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClientFindManyArgs>(args?: SelectSubset<T, ClientFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Client.
     * @param {ClientCreateArgs} args - Arguments to create a Client.
     * @example
     * // Create one Client
     * const Client = await prisma.client.create({
     *   data: {
     *     // ... data to create a Client
     *   }
     * })
     * 
     */
    create<T extends ClientCreateArgs>(args: SelectSubset<T, ClientCreateArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Clients.
     * @param {ClientCreateManyArgs} args - Arguments to create many Clients.
     * @example
     * // Create many Clients
     * const client = await prisma.client.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClientCreateManyArgs>(args?: SelectSubset<T, ClientCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Client.
     * @param {ClientDeleteArgs} args - Arguments to delete one Client.
     * @example
     * // Delete one Client
     * const Client = await prisma.client.delete({
     *   where: {
     *     // ... filter to delete one Client
     *   }
     * })
     * 
     */
    delete<T extends ClientDeleteArgs>(args: SelectSubset<T, ClientDeleteArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Client.
     * @param {ClientUpdateArgs} args - Arguments to update one Client.
     * @example
     * // Update one Client
     * const client = await prisma.client.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClientUpdateArgs>(args: SelectSubset<T, ClientUpdateArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Clients.
     * @param {ClientDeleteManyArgs} args - Arguments to filter Clients to delete.
     * @example
     * // Delete a few Clients
     * const { count } = await prisma.client.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClientDeleteManyArgs>(args?: SelectSubset<T, ClientDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clients
     * const client = await prisma.client.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClientUpdateManyArgs>(args: SelectSubset<T, ClientUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Client.
     * @param {ClientUpsertArgs} args - Arguments to update or create a Client.
     * @example
     * // Update or create a Client
     * const client = await prisma.client.upsert({
     *   create: {
     *     // ... data to create a Client
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Client we want to update
     *   }
     * })
     */
    upsert<T extends ClientUpsertArgs>(args: SelectSubset<T, ClientUpsertArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientCountArgs} args - Arguments to filter Clients to count.
     * @example
     * // Count the number of Clients
     * const count = await prisma.client.count({
     *   where: {
     *     // ... the filter for the Clients we want to count
     *   }
     * })
    **/
    count<T extends ClientCountArgs>(
      args?: Subset<T, ClientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientAggregateArgs>(args: Subset<T, ClientAggregateArgs>): Prisma.PrismaPromise<GetClientAggregateType<T>>

    /**
     * Group by Client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientGroupByArgs['orderBy'] }
        : { orderBy?: ClientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Client model
   */
  readonly fields: ClientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Client.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    projects<T extends Client$projectsArgs<ExtArgs> = {}>(args?: Subset<T, Client$projectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Client model
   */ 
  interface ClientFieldRefs {
    readonly id: FieldRef<"Client", 'Int'>
    readonly name: FieldRef<"Client", 'String'>
    readonly contactPerson: FieldRef<"Client", 'String'>
    readonly contractType: FieldRef<"Client", 'String'>
    readonly paymentTerms: FieldRef<"Client", 'String'>
    readonly createdAt: FieldRef<"Client", 'DateTime'>
    readonly updatedAt: FieldRef<"Client", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Client findUnique
   */
  export type ClientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client findUniqueOrThrow
   */
  export type ClientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client findFirst
   */
  export type ClientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clients.
     */
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client findFirstOrThrow
   */
  export type ClientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clients.
     */
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client findMany
   */
  export type ClientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Clients to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client create
   */
  export type ClientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The data needed to create a Client.
     */
    data: XOR<ClientCreateInput, ClientUncheckedCreateInput>
  }

  /**
   * Client createMany
   */
  export type ClientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Clients.
     */
    data: ClientCreateManyInput | ClientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Client update
   */
  export type ClientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The data needed to update a Client.
     */
    data: XOR<ClientUpdateInput, ClientUncheckedUpdateInput>
    /**
     * Choose, which Client to update.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client updateMany
   */
  export type ClientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Clients.
     */
    data: XOR<ClientUpdateManyMutationInput, ClientUncheckedUpdateManyInput>
    /**
     * Filter which Clients to update
     */
    where?: ClientWhereInput
  }

  /**
   * Client upsert
   */
  export type ClientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The filter to search for the Client to update in case it exists.
     */
    where: ClientWhereUniqueInput
    /**
     * In case the Client found by the `where` argument doesn't exist, create a new Client with this data.
     */
    create: XOR<ClientCreateInput, ClientUncheckedCreateInput>
    /**
     * In case the Client was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClientUpdateInput, ClientUncheckedUpdateInput>
  }

  /**
   * Client delete
   */
  export type ClientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter which Client to delete.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client deleteMany
   */
  export type ClientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Clients to delete
     */
    where?: ClientWhereInput
  }

  /**
   * Client.projects
   */
  export type Client$projectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    cursor?: ProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Client without action
   */
  export type ClientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
  }


  /**
   * Model Project
   */

  export type AggregateProject = {
    _count: ProjectCountAggregateOutputType | null
    _avg: ProjectAvgAggregateOutputType | null
    _sum: ProjectSumAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  export type ProjectAvgAggregateOutputType = {
    id: number | null
    clientId: number | null
    budget: Decimal | null
    totalFloorArea: Decimal | null
    carportArea: Decimal | null
  }

  export type ProjectSumAggregateOutputType = {
    id: number | null
    clientId: number | null
    budget: Decimal | null
    totalFloorArea: Decimal | null
    carportArea: Decimal | null
  }

  export type ProjectMinAggregateOutputType = {
    id: number | null
    clientId: number | null
    name: string | null
    location: string | null
    duration: string | null
    budget: Decimal | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    totalFloorArea: Decimal | null
    carportArea: Decimal | null
  }

  export type ProjectMaxAggregateOutputType = {
    id: number | null
    clientId: number | null
    name: string | null
    location: string | null
    duration: string | null
    budget: Decimal | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    totalFloorArea: Decimal | null
    carportArea: Decimal | null
  }

  export type ProjectCountAggregateOutputType = {
    id: number
    clientId: number
    name: number
    location: number
    duration: number
    budget: number
    status: number
    createdAt: number
    updatedAt: number
    totalFloorArea: number
    carportArea: number
    _all: number
  }


  export type ProjectAvgAggregateInputType = {
    id?: true
    clientId?: true
    budget?: true
    totalFloorArea?: true
    carportArea?: true
  }

  export type ProjectSumAggregateInputType = {
    id?: true
    clientId?: true
    budget?: true
    totalFloorArea?: true
    carportArea?: true
  }

  export type ProjectMinAggregateInputType = {
    id?: true
    clientId?: true
    name?: true
    location?: true
    duration?: true
    budget?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    totalFloorArea?: true
    carportArea?: true
  }

  export type ProjectMaxAggregateInputType = {
    id?: true
    clientId?: true
    name?: true
    location?: true
    duration?: true
    budget?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    totalFloorArea?: true
    carportArea?: true
  }

  export type ProjectCountAggregateInputType = {
    id?: true
    clientId?: true
    name?: true
    location?: true
    duration?: true
    budget?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    totalFloorArea?: true
    carportArea?: true
    _all?: true
  }

  export type ProjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Project to aggregate.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Projects
    **/
    _count?: true | ProjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectMaxAggregateInputType
  }

  export type GetProjectAggregateType<T extends ProjectAggregateArgs> = {
        [P in keyof T & keyof AggregateProject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProject[P]>
      : GetScalarType<T[P], AggregateProject[P]>
  }




  export type ProjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithAggregationInput | ProjectOrderByWithAggregationInput[]
    by: ProjectScalarFieldEnum[] | ProjectScalarFieldEnum
    having?: ProjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectCountAggregateInputType | true
    _avg?: ProjectAvgAggregateInputType
    _sum?: ProjectSumAggregateInputType
    _min?: ProjectMinAggregateInputType
    _max?: ProjectMaxAggregateInputType
  }

  export type ProjectGroupByOutputType = {
    id: number
    clientId: number | null
    name: string
    location: string | null
    duration: string | null
    budget: Decimal
    status: string
    createdAt: Date
    updatedAt: Date
    totalFloorArea: Decimal | null
    carportArea: Decimal | null
    _count: ProjectCountAggregateOutputType | null
    _avg: ProjectAvgAggregateOutputType | null
    _sum: ProjectSumAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  type GetProjectGroupByPayload<T extends ProjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectGroupByOutputType[P]>
        }
      >
    >


  export type ProjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    name?: boolean
    location?: boolean
    duration?: boolean
    budget?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    totalFloorArea?: boolean
    carportArea?: boolean
    client?: boolean | Project$clientArgs<ExtArgs>
    transactions?: boolean | Project$transactionsArgs<ExtArgs>
    inventory?: boolean | Project$inventoryArgs<ExtArgs>
    teamMembers?: boolean | Project$teamMembersArgs<ExtArgs>
    boqItems?: boolean | Project$boqItemsArgs<ExtArgs>
    purchaseOrders?: boolean | Project$purchaseOrdersArgs<ExtArgs>
    materialRequests?: boolean | Project$materialRequestsArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>


  export type ProjectSelectScalar = {
    id?: boolean
    clientId?: boolean
    name?: boolean
    location?: boolean
    duration?: boolean
    budget?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    totalFloorArea?: boolean
    carportArea?: boolean
  }

  export type ProjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | Project$clientArgs<ExtArgs>
    transactions?: boolean | Project$transactionsArgs<ExtArgs>
    inventory?: boolean | Project$inventoryArgs<ExtArgs>
    teamMembers?: boolean | Project$teamMembersArgs<ExtArgs>
    boqItems?: boolean | Project$boqItemsArgs<ExtArgs>
    purchaseOrders?: boolean | Project$purchaseOrdersArgs<ExtArgs>
    materialRequests?: boolean | Project$materialRequestsArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ProjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Project"
    objects: {
      client: Prisma.$ClientPayload<ExtArgs> | null
      transactions: Prisma.$FinancialTransactionPayload<ExtArgs>[]
      inventory: Prisma.$InventoryItemPayload<ExtArgs>[]
      teamMembers: Prisma.$ProjectMemberPayload<ExtArgs>[]
      boqItems: Prisma.$BoqItemPayload<ExtArgs>[]
      purchaseOrders: Prisma.$PurchaseOrderPayload<ExtArgs>[]
      materialRequests: Prisma.$MaterialRequestPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      clientId: number | null
      name: string
      location: string | null
      duration: string | null
      budget: Prisma.Decimal
      status: string
      createdAt: Date
      updatedAt: Date
      totalFloorArea: Prisma.Decimal | null
      carportArea: Prisma.Decimal | null
    }, ExtArgs["result"]["project"]>
    composites: {}
  }

  type ProjectGetPayload<S extends boolean | null | undefined | ProjectDefaultArgs> = $Result.GetResult<Prisma.$ProjectPayload, S>

  type ProjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProjectFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProjectCountAggregateInputType | true
    }

  export interface ProjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Project'], meta: { name: 'Project' } }
    /**
     * Find zero or one Project that matches the filter.
     * @param {ProjectFindUniqueArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectFindUniqueArgs>(args: SelectSubset<T, ProjectFindUniqueArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Project that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProjectFindUniqueOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Project that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectFindFirstArgs>(args?: SelectSubset<T, ProjectFindFirstArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Project that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Projects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Projects
     * const projects = await prisma.project.findMany()
     * 
     * // Get first 10 Projects
     * const projects = await prisma.project.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectWithIdOnly = await prisma.project.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectFindManyArgs>(args?: SelectSubset<T, ProjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Project.
     * @param {ProjectCreateArgs} args - Arguments to create a Project.
     * @example
     * // Create one Project
     * const Project = await prisma.project.create({
     *   data: {
     *     // ... data to create a Project
     *   }
     * })
     * 
     */
    create<T extends ProjectCreateArgs>(args: SelectSubset<T, ProjectCreateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Projects.
     * @param {ProjectCreateManyArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectCreateManyArgs>(args?: SelectSubset<T, ProjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Project.
     * @param {ProjectDeleteArgs} args - Arguments to delete one Project.
     * @example
     * // Delete one Project
     * const Project = await prisma.project.delete({
     *   where: {
     *     // ... filter to delete one Project
     *   }
     * })
     * 
     */
    delete<T extends ProjectDeleteArgs>(args: SelectSubset<T, ProjectDeleteArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Project.
     * @param {ProjectUpdateArgs} args - Arguments to update one Project.
     * @example
     * // Update one Project
     * const project = await prisma.project.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectUpdateArgs>(args: SelectSubset<T, ProjectUpdateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Projects.
     * @param {ProjectDeleteManyArgs} args - Arguments to filter Projects to delete.
     * @example
     * // Delete a few Projects
     * const { count } = await prisma.project.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectDeleteManyArgs>(args?: SelectSubset<T, ProjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Projects
     * const project = await prisma.project.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectUpdateManyArgs>(args: SelectSubset<T, ProjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Project.
     * @param {ProjectUpsertArgs} args - Arguments to update or create a Project.
     * @example
     * // Update or create a Project
     * const project = await prisma.project.upsert({
     *   create: {
     *     // ... data to create a Project
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Project we want to update
     *   }
     * })
     */
    upsert<T extends ProjectUpsertArgs>(args: SelectSubset<T, ProjectUpsertArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectCountArgs} args - Arguments to filter Projects to count.
     * @example
     * // Count the number of Projects
     * const count = await prisma.project.count({
     *   where: {
     *     // ... the filter for the Projects we want to count
     *   }
     * })
    **/
    count<T extends ProjectCountArgs>(
      args?: Subset<T, ProjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectAggregateArgs>(args: Subset<T, ProjectAggregateArgs>): Prisma.PrismaPromise<GetProjectAggregateType<T>>

    /**
     * Group by Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectGroupByArgs['orderBy'] }
        : { orderBy?: ProjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Project model
   */
  readonly fields: ProjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Project.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends Project$clientArgs<ExtArgs> = {}>(args?: Subset<T, Project$clientArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    transactions<T extends Project$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, Project$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinancialTransactionPayload<ExtArgs>, T, "findMany"> | Null>
    inventory<T extends Project$inventoryArgs<ExtArgs> = {}>(args?: Subset<T, Project$inventoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findMany"> | Null>
    teamMembers<T extends Project$teamMembersArgs<ExtArgs> = {}>(args?: Subset<T, Project$teamMembersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "findMany"> | Null>
    boqItems<T extends Project$boqItemsArgs<ExtArgs> = {}>(args?: Subset<T, Project$boqItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BoqItemPayload<ExtArgs>, T, "findMany"> | Null>
    purchaseOrders<T extends Project$purchaseOrdersArgs<ExtArgs> = {}>(args?: Subset<T, Project$purchaseOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findMany"> | Null>
    materialRequests<T extends Project$materialRequestsArgs<ExtArgs> = {}>(args?: Subset<T, Project$materialRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialRequestPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Project model
   */ 
  interface ProjectFieldRefs {
    readonly id: FieldRef<"Project", 'Int'>
    readonly clientId: FieldRef<"Project", 'Int'>
    readonly name: FieldRef<"Project", 'String'>
    readonly location: FieldRef<"Project", 'String'>
    readonly duration: FieldRef<"Project", 'String'>
    readonly budget: FieldRef<"Project", 'Decimal'>
    readonly status: FieldRef<"Project", 'String'>
    readonly createdAt: FieldRef<"Project", 'DateTime'>
    readonly updatedAt: FieldRef<"Project", 'DateTime'>
    readonly totalFloorArea: FieldRef<"Project", 'Decimal'>
    readonly carportArea: FieldRef<"Project", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * Project findUnique
   */
  export type ProjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findUniqueOrThrow
   */
  export type ProjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findFirst
   */
  export type ProjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findFirstOrThrow
   */
  export type ProjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findMany
   */
  export type ProjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Projects to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project create
   */
  export type ProjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to create a Project.
     */
    data: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
  }

  /**
   * Project createMany
   */
  export type ProjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Project update
   */
  export type ProjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to update a Project.
     */
    data: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
    /**
     * Choose, which Project to update.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project updateMany
   */
  export type ProjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Projects.
     */
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyInput>
    /**
     * Filter which Projects to update
     */
    where?: ProjectWhereInput
  }

  /**
   * Project upsert
   */
  export type ProjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The filter to search for the Project to update in case it exists.
     */
    where: ProjectWhereUniqueInput
    /**
     * In case the Project found by the `where` argument doesn't exist, create a new Project with this data.
     */
    create: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
    /**
     * In case the Project was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
  }

  /**
   * Project delete
   */
  export type ProjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter which Project to delete.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project deleteMany
   */
  export type ProjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Projects to delete
     */
    where?: ProjectWhereInput
  }

  /**
   * Project.client
   */
  export type Project$clientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    where?: ClientWhereInput
  }

  /**
   * Project.transactions
   */
  export type Project$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialTransaction
     */
    select?: FinancialTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialTransactionInclude<ExtArgs> | null
    where?: FinancialTransactionWhereInput
    orderBy?: FinancialTransactionOrderByWithRelationInput | FinancialTransactionOrderByWithRelationInput[]
    cursor?: FinancialTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FinancialTransactionScalarFieldEnum | FinancialTransactionScalarFieldEnum[]
  }

  /**
   * Project.inventory
   */
  export type Project$inventoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    where?: InventoryItemWhereInput
    orderBy?: InventoryItemOrderByWithRelationInput | InventoryItemOrderByWithRelationInput[]
    cursor?: InventoryItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryItemScalarFieldEnum | InventoryItemScalarFieldEnum[]
  }

  /**
   * Project.teamMembers
   */
  export type Project$teamMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    where?: ProjectMemberWhereInput
    orderBy?: ProjectMemberOrderByWithRelationInput | ProjectMemberOrderByWithRelationInput[]
    cursor?: ProjectMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectMemberScalarFieldEnum | ProjectMemberScalarFieldEnum[]
  }

  /**
   * Project.boqItems
   */
  export type Project$boqItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoqItem
     */
    select?: BoqItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoqItemInclude<ExtArgs> | null
    where?: BoqItemWhereInput
    orderBy?: BoqItemOrderByWithRelationInput | BoqItemOrderByWithRelationInput[]
    cursor?: BoqItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BoqItemScalarFieldEnum | BoqItemScalarFieldEnum[]
  }

  /**
   * Project.purchaseOrders
   */
  export type Project$purchaseOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    where?: PurchaseOrderWhereInput
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    cursor?: PurchaseOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseOrderScalarFieldEnum | PurchaseOrderScalarFieldEnum[]
  }

  /**
   * Project.materialRequests
   */
  export type Project$materialRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialRequest
     */
    select?: MaterialRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialRequestInclude<ExtArgs> | null
    where?: MaterialRequestWhereInput
    orderBy?: MaterialRequestOrderByWithRelationInput | MaterialRequestOrderByWithRelationInput[]
    cursor?: MaterialRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MaterialRequestScalarFieldEnum | MaterialRequestScalarFieldEnum[]
  }

  /**
   * Project without action
   */
  export type ProjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
  }


  /**
   * Model ProjectMember
   */

  export type AggregateProjectMember = {
    _count: ProjectMemberCountAggregateOutputType | null
    _avg: ProjectMemberAvgAggregateOutputType | null
    _sum: ProjectMemberSumAggregateOutputType | null
    _min: ProjectMemberMinAggregateOutputType | null
    _max: ProjectMemberMaxAggregateOutputType | null
  }

  export type ProjectMemberAvgAggregateOutputType = {
    id: number | null
    projectId: number | null
    userId: number | null
  }

  export type ProjectMemberSumAggregateOutputType = {
    id: number | null
    projectId: number | null
    userId: number | null
  }

  export type ProjectMemberMinAggregateOutputType = {
    id: number | null
    projectId: number | null
    userId: number | null
    role: string | null
    assignedAt: Date | null
  }

  export type ProjectMemberMaxAggregateOutputType = {
    id: number | null
    projectId: number | null
    userId: number | null
    role: string | null
    assignedAt: Date | null
  }

  export type ProjectMemberCountAggregateOutputType = {
    id: number
    projectId: number
    userId: number
    role: number
    assignedAt: number
    _all: number
  }


  export type ProjectMemberAvgAggregateInputType = {
    id?: true
    projectId?: true
    userId?: true
  }

  export type ProjectMemberSumAggregateInputType = {
    id?: true
    projectId?: true
    userId?: true
  }

  export type ProjectMemberMinAggregateInputType = {
    id?: true
    projectId?: true
    userId?: true
    role?: true
    assignedAt?: true
  }

  export type ProjectMemberMaxAggregateInputType = {
    id?: true
    projectId?: true
    userId?: true
    role?: true
    assignedAt?: true
  }

  export type ProjectMemberCountAggregateInputType = {
    id?: true
    projectId?: true
    userId?: true
    role?: true
    assignedAt?: true
    _all?: true
  }

  export type ProjectMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectMember to aggregate.
     */
    where?: ProjectMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectMembers to fetch.
     */
    orderBy?: ProjectMemberOrderByWithRelationInput | ProjectMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectMembers
    **/
    _count?: true | ProjectMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectMemberAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectMemberSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectMemberMaxAggregateInputType
  }

  export type GetProjectMemberAggregateType<T extends ProjectMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectMember[P]>
      : GetScalarType<T[P], AggregateProjectMember[P]>
  }




  export type ProjectMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectMemberWhereInput
    orderBy?: ProjectMemberOrderByWithAggregationInput | ProjectMemberOrderByWithAggregationInput[]
    by: ProjectMemberScalarFieldEnum[] | ProjectMemberScalarFieldEnum
    having?: ProjectMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectMemberCountAggregateInputType | true
    _avg?: ProjectMemberAvgAggregateInputType
    _sum?: ProjectMemberSumAggregateInputType
    _min?: ProjectMemberMinAggregateInputType
    _max?: ProjectMemberMaxAggregateInputType
  }

  export type ProjectMemberGroupByOutputType = {
    id: number
    projectId: number
    userId: number
    role: string
    assignedAt: Date
    _count: ProjectMemberCountAggregateOutputType | null
    _avg: ProjectMemberAvgAggregateOutputType | null
    _sum: ProjectMemberSumAggregateOutputType | null
    _min: ProjectMemberMinAggregateOutputType | null
    _max: ProjectMemberMaxAggregateOutputType | null
  }

  type GetProjectMemberGroupByPayload<T extends ProjectMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectMemberGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectMemberGroupByOutputType[P]>
        }
      >
    >


  export type ProjectMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    userId?: boolean
    role?: boolean
    assignedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectMember"]>


  export type ProjectMemberSelectScalar = {
    id?: boolean
    projectId?: boolean
    userId?: boolean
    role?: boolean
    assignedAt?: boolean
  }

  export type ProjectMemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ProjectMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProjectMember"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      projectId: number
      userId: number
      role: string
      assignedAt: Date
    }, ExtArgs["result"]["projectMember"]>
    composites: {}
  }

  type ProjectMemberGetPayload<S extends boolean | null | undefined | ProjectMemberDefaultArgs> = $Result.GetResult<Prisma.$ProjectMemberPayload, S>

  type ProjectMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProjectMemberFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProjectMemberCountAggregateInputType | true
    }

  export interface ProjectMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProjectMember'], meta: { name: 'ProjectMember' } }
    /**
     * Find zero or one ProjectMember that matches the filter.
     * @param {ProjectMemberFindUniqueArgs} args - Arguments to find a ProjectMember
     * @example
     * // Get one ProjectMember
     * const projectMember = await prisma.projectMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectMemberFindUniqueArgs>(args: SelectSubset<T, ProjectMemberFindUniqueArgs<ExtArgs>>): Prisma__ProjectMemberClient<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProjectMember that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProjectMemberFindUniqueOrThrowArgs} args - Arguments to find a ProjectMember
     * @example
     * // Get one ProjectMember
     * const projectMember = await prisma.projectMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectMemberFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectMemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectMemberClient<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProjectMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMemberFindFirstArgs} args - Arguments to find a ProjectMember
     * @example
     * // Get one ProjectMember
     * const projectMember = await prisma.projectMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectMemberFindFirstArgs>(args?: SelectSubset<T, ProjectMemberFindFirstArgs<ExtArgs>>): Prisma__ProjectMemberClient<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProjectMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMemberFindFirstOrThrowArgs} args - Arguments to find a ProjectMember
     * @example
     * // Get one ProjectMember
     * const projectMember = await prisma.projectMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectMemberFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectMemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectMemberClient<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProjectMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectMembers
     * const projectMembers = await prisma.projectMember.findMany()
     * 
     * // Get first 10 ProjectMembers
     * const projectMembers = await prisma.projectMember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectMemberWithIdOnly = await prisma.projectMember.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectMemberFindManyArgs>(args?: SelectSubset<T, ProjectMemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProjectMember.
     * @param {ProjectMemberCreateArgs} args - Arguments to create a ProjectMember.
     * @example
     * // Create one ProjectMember
     * const ProjectMember = await prisma.projectMember.create({
     *   data: {
     *     // ... data to create a ProjectMember
     *   }
     * })
     * 
     */
    create<T extends ProjectMemberCreateArgs>(args: SelectSubset<T, ProjectMemberCreateArgs<ExtArgs>>): Prisma__ProjectMemberClient<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProjectMembers.
     * @param {ProjectMemberCreateManyArgs} args - Arguments to create many ProjectMembers.
     * @example
     * // Create many ProjectMembers
     * const projectMember = await prisma.projectMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectMemberCreateManyArgs>(args?: SelectSubset<T, ProjectMemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProjectMember.
     * @param {ProjectMemberDeleteArgs} args - Arguments to delete one ProjectMember.
     * @example
     * // Delete one ProjectMember
     * const ProjectMember = await prisma.projectMember.delete({
     *   where: {
     *     // ... filter to delete one ProjectMember
     *   }
     * })
     * 
     */
    delete<T extends ProjectMemberDeleteArgs>(args: SelectSubset<T, ProjectMemberDeleteArgs<ExtArgs>>): Prisma__ProjectMemberClient<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProjectMember.
     * @param {ProjectMemberUpdateArgs} args - Arguments to update one ProjectMember.
     * @example
     * // Update one ProjectMember
     * const projectMember = await prisma.projectMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectMemberUpdateArgs>(args: SelectSubset<T, ProjectMemberUpdateArgs<ExtArgs>>): Prisma__ProjectMemberClient<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProjectMembers.
     * @param {ProjectMemberDeleteManyArgs} args - Arguments to filter ProjectMembers to delete.
     * @example
     * // Delete a few ProjectMembers
     * const { count } = await prisma.projectMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectMemberDeleteManyArgs>(args?: SelectSubset<T, ProjectMemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectMembers
     * const projectMember = await prisma.projectMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectMemberUpdateManyArgs>(args: SelectSubset<T, ProjectMemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProjectMember.
     * @param {ProjectMemberUpsertArgs} args - Arguments to update or create a ProjectMember.
     * @example
     * // Update or create a ProjectMember
     * const projectMember = await prisma.projectMember.upsert({
     *   create: {
     *     // ... data to create a ProjectMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectMember we want to update
     *   }
     * })
     */
    upsert<T extends ProjectMemberUpsertArgs>(args: SelectSubset<T, ProjectMemberUpsertArgs<ExtArgs>>): Prisma__ProjectMemberClient<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProjectMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMemberCountArgs} args - Arguments to filter ProjectMembers to count.
     * @example
     * // Count the number of ProjectMembers
     * const count = await prisma.projectMember.count({
     *   where: {
     *     // ... the filter for the ProjectMembers we want to count
     *   }
     * })
    **/
    count<T extends ProjectMemberCountArgs>(
      args?: Subset<T, ProjectMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectMemberAggregateArgs>(args: Subset<T, ProjectMemberAggregateArgs>): Prisma.PrismaPromise<GetProjectMemberAggregateType<T>>

    /**
     * Group by ProjectMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectMemberGroupByArgs['orderBy'] }
        : { orderBy?: ProjectMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProjectMember model
   */
  readonly fields: ProjectMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProjectMember model
   */ 
  interface ProjectMemberFieldRefs {
    readonly id: FieldRef<"ProjectMember", 'Int'>
    readonly projectId: FieldRef<"ProjectMember", 'Int'>
    readonly userId: FieldRef<"ProjectMember", 'Int'>
    readonly role: FieldRef<"ProjectMember", 'String'>
    readonly assignedAt: FieldRef<"ProjectMember", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProjectMember findUnique
   */
  export type ProjectMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    /**
     * Filter, which ProjectMember to fetch.
     */
    where: ProjectMemberWhereUniqueInput
  }

  /**
   * ProjectMember findUniqueOrThrow
   */
  export type ProjectMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    /**
     * Filter, which ProjectMember to fetch.
     */
    where: ProjectMemberWhereUniqueInput
  }

  /**
   * ProjectMember findFirst
   */
  export type ProjectMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    /**
     * Filter, which ProjectMember to fetch.
     */
    where?: ProjectMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectMembers to fetch.
     */
    orderBy?: ProjectMemberOrderByWithRelationInput | ProjectMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectMembers.
     */
    cursor?: ProjectMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectMembers.
     */
    distinct?: ProjectMemberScalarFieldEnum | ProjectMemberScalarFieldEnum[]
  }

  /**
   * ProjectMember findFirstOrThrow
   */
  export type ProjectMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    /**
     * Filter, which ProjectMember to fetch.
     */
    where?: ProjectMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectMembers to fetch.
     */
    orderBy?: ProjectMemberOrderByWithRelationInput | ProjectMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectMembers.
     */
    cursor?: ProjectMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectMembers.
     */
    distinct?: ProjectMemberScalarFieldEnum | ProjectMemberScalarFieldEnum[]
  }

  /**
   * ProjectMember findMany
   */
  export type ProjectMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    /**
     * Filter, which ProjectMembers to fetch.
     */
    where?: ProjectMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectMembers to fetch.
     */
    orderBy?: ProjectMemberOrderByWithRelationInput | ProjectMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectMembers.
     */
    cursor?: ProjectMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectMembers.
     */
    skip?: number
    distinct?: ProjectMemberScalarFieldEnum | ProjectMemberScalarFieldEnum[]
  }

  /**
   * ProjectMember create
   */
  export type ProjectMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    /**
     * The data needed to create a ProjectMember.
     */
    data: XOR<ProjectMemberCreateInput, ProjectMemberUncheckedCreateInput>
  }

  /**
   * ProjectMember createMany
   */
  export type ProjectMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProjectMembers.
     */
    data: ProjectMemberCreateManyInput | ProjectMemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProjectMember update
   */
  export type ProjectMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    /**
     * The data needed to update a ProjectMember.
     */
    data: XOR<ProjectMemberUpdateInput, ProjectMemberUncheckedUpdateInput>
    /**
     * Choose, which ProjectMember to update.
     */
    where: ProjectMemberWhereUniqueInput
  }

  /**
   * ProjectMember updateMany
   */
  export type ProjectMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProjectMembers.
     */
    data: XOR<ProjectMemberUpdateManyMutationInput, ProjectMemberUncheckedUpdateManyInput>
    /**
     * Filter which ProjectMembers to update
     */
    where?: ProjectMemberWhereInput
  }

  /**
   * ProjectMember upsert
   */
  export type ProjectMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    /**
     * The filter to search for the ProjectMember to update in case it exists.
     */
    where: ProjectMemberWhereUniqueInput
    /**
     * In case the ProjectMember found by the `where` argument doesn't exist, create a new ProjectMember with this data.
     */
    create: XOR<ProjectMemberCreateInput, ProjectMemberUncheckedCreateInput>
    /**
     * In case the ProjectMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectMemberUpdateInput, ProjectMemberUncheckedUpdateInput>
  }

  /**
   * ProjectMember delete
   */
  export type ProjectMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    /**
     * Filter which ProjectMember to delete.
     */
    where: ProjectMemberWhereUniqueInput
  }

  /**
   * ProjectMember deleteMany
   */
  export type ProjectMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectMembers to delete
     */
    where?: ProjectMemberWhereInput
  }

  /**
   * ProjectMember without action
   */
  export type ProjectMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
  }


  /**
   * Model BoqItem
   */

  export type AggregateBoqItem = {
    _count: BoqItemCountAggregateOutputType | null
    _avg: BoqItemAvgAggregateOutputType | null
    _sum: BoqItemSumAggregateOutputType | null
    _min: BoqItemMinAggregateOutputType | null
    _max: BoqItemMaxAggregateOutputType | null
  }

  export type BoqItemAvgAggregateOutputType = {
    id: number | null
    projectId: number | null
    materialUnitPrice: Decimal | null
    laborUnitPrice: Decimal | null
    quantity: Decimal | null
  }

  export type BoqItemSumAggregateOutputType = {
    id: number | null
    projectId: number | null
    materialUnitPrice: Decimal | null
    laborUnitPrice: Decimal | null
    quantity: Decimal | null
  }

  export type BoqItemMinAggregateOutputType = {
    id: number | null
    projectId: number | null
    itemDescription: string | null
    unit: string | null
    materialUnitPrice: Decimal | null
    laborUnitPrice: Decimal | null
    quantity: Decimal | null
    isCarport: boolean | null
  }

  export type BoqItemMaxAggregateOutputType = {
    id: number | null
    projectId: number | null
    itemDescription: string | null
    unit: string | null
    materialUnitPrice: Decimal | null
    laborUnitPrice: Decimal | null
    quantity: Decimal | null
    isCarport: boolean | null
  }

  export type BoqItemCountAggregateOutputType = {
    id: number
    projectId: number
    itemDescription: number
    unit: number
    materialUnitPrice: number
    laborUnitPrice: number
    quantity: number
    isCarport: number
    _all: number
  }


  export type BoqItemAvgAggregateInputType = {
    id?: true
    projectId?: true
    materialUnitPrice?: true
    laborUnitPrice?: true
    quantity?: true
  }

  export type BoqItemSumAggregateInputType = {
    id?: true
    projectId?: true
    materialUnitPrice?: true
    laborUnitPrice?: true
    quantity?: true
  }

  export type BoqItemMinAggregateInputType = {
    id?: true
    projectId?: true
    itemDescription?: true
    unit?: true
    materialUnitPrice?: true
    laborUnitPrice?: true
    quantity?: true
    isCarport?: true
  }

  export type BoqItemMaxAggregateInputType = {
    id?: true
    projectId?: true
    itemDescription?: true
    unit?: true
    materialUnitPrice?: true
    laborUnitPrice?: true
    quantity?: true
    isCarport?: true
  }

  export type BoqItemCountAggregateInputType = {
    id?: true
    projectId?: true
    itemDescription?: true
    unit?: true
    materialUnitPrice?: true
    laborUnitPrice?: true
    quantity?: true
    isCarport?: true
    _all?: true
  }

  export type BoqItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BoqItem to aggregate.
     */
    where?: BoqItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BoqItems to fetch.
     */
    orderBy?: BoqItemOrderByWithRelationInput | BoqItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BoqItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BoqItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BoqItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BoqItems
    **/
    _count?: true | BoqItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BoqItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BoqItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BoqItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BoqItemMaxAggregateInputType
  }

  export type GetBoqItemAggregateType<T extends BoqItemAggregateArgs> = {
        [P in keyof T & keyof AggregateBoqItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBoqItem[P]>
      : GetScalarType<T[P], AggregateBoqItem[P]>
  }




  export type BoqItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BoqItemWhereInput
    orderBy?: BoqItemOrderByWithAggregationInput | BoqItemOrderByWithAggregationInput[]
    by: BoqItemScalarFieldEnum[] | BoqItemScalarFieldEnum
    having?: BoqItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BoqItemCountAggregateInputType | true
    _avg?: BoqItemAvgAggregateInputType
    _sum?: BoqItemSumAggregateInputType
    _min?: BoqItemMinAggregateInputType
    _max?: BoqItemMaxAggregateInputType
  }

  export type BoqItemGroupByOutputType = {
    id: number
    projectId: number
    itemDescription: string
    unit: string
    materialUnitPrice: Decimal
    laborUnitPrice: Decimal
    quantity: Decimal
    isCarport: boolean
    _count: BoqItemCountAggregateOutputType | null
    _avg: BoqItemAvgAggregateOutputType | null
    _sum: BoqItemSumAggregateOutputType | null
    _min: BoqItemMinAggregateOutputType | null
    _max: BoqItemMaxAggregateOutputType | null
  }

  type GetBoqItemGroupByPayload<T extends BoqItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BoqItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BoqItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BoqItemGroupByOutputType[P]>
            : GetScalarType<T[P], BoqItemGroupByOutputType[P]>
        }
      >
    >


  export type BoqItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    itemDescription?: boolean
    unit?: boolean
    materialUnitPrice?: boolean
    laborUnitPrice?: boolean
    quantity?: boolean
    isCarport?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    boqComponents?: boolean | BoqItem$boqComponentsArgs<ExtArgs>
    _count?: boolean | BoqItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["boqItem"]>


  export type BoqItemSelectScalar = {
    id?: boolean
    projectId?: boolean
    itemDescription?: boolean
    unit?: boolean
    materialUnitPrice?: boolean
    laborUnitPrice?: boolean
    quantity?: boolean
    isCarport?: boolean
  }

  export type BoqItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    boqComponents?: boolean | BoqItem$boqComponentsArgs<ExtArgs>
    _count?: boolean | BoqItemCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $BoqItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BoqItem"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      boqComponents: Prisma.$BoqItemComponentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      projectId: number
      itemDescription: string
      unit: string
      materialUnitPrice: Prisma.Decimal
      laborUnitPrice: Prisma.Decimal
      quantity: Prisma.Decimal
      isCarport: boolean
    }, ExtArgs["result"]["boqItem"]>
    composites: {}
  }

  type BoqItemGetPayload<S extends boolean | null | undefined | BoqItemDefaultArgs> = $Result.GetResult<Prisma.$BoqItemPayload, S>

  type BoqItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BoqItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BoqItemCountAggregateInputType | true
    }

  export interface BoqItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BoqItem'], meta: { name: 'BoqItem' } }
    /**
     * Find zero or one BoqItem that matches the filter.
     * @param {BoqItemFindUniqueArgs} args - Arguments to find a BoqItem
     * @example
     * // Get one BoqItem
     * const boqItem = await prisma.boqItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BoqItemFindUniqueArgs>(args: SelectSubset<T, BoqItemFindUniqueArgs<ExtArgs>>): Prisma__BoqItemClient<$Result.GetResult<Prisma.$BoqItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BoqItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BoqItemFindUniqueOrThrowArgs} args - Arguments to find a BoqItem
     * @example
     * // Get one BoqItem
     * const boqItem = await prisma.boqItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BoqItemFindUniqueOrThrowArgs>(args: SelectSubset<T, BoqItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BoqItemClient<$Result.GetResult<Prisma.$BoqItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BoqItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoqItemFindFirstArgs} args - Arguments to find a BoqItem
     * @example
     * // Get one BoqItem
     * const boqItem = await prisma.boqItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BoqItemFindFirstArgs>(args?: SelectSubset<T, BoqItemFindFirstArgs<ExtArgs>>): Prisma__BoqItemClient<$Result.GetResult<Prisma.$BoqItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BoqItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoqItemFindFirstOrThrowArgs} args - Arguments to find a BoqItem
     * @example
     * // Get one BoqItem
     * const boqItem = await prisma.boqItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BoqItemFindFirstOrThrowArgs>(args?: SelectSubset<T, BoqItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__BoqItemClient<$Result.GetResult<Prisma.$BoqItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BoqItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoqItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BoqItems
     * const boqItems = await prisma.boqItem.findMany()
     * 
     * // Get first 10 BoqItems
     * const boqItems = await prisma.boqItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const boqItemWithIdOnly = await prisma.boqItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BoqItemFindManyArgs>(args?: SelectSubset<T, BoqItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BoqItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BoqItem.
     * @param {BoqItemCreateArgs} args - Arguments to create a BoqItem.
     * @example
     * // Create one BoqItem
     * const BoqItem = await prisma.boqItem.create({
     *   data: {
     *     // ... data to create a BoqItem
     *   }
     * })
     * 
     */
    create<T extends BoqItemCreateArgs>(args: SelectSubset<T, BoqItemCreateArgs<ExtArgs>>): Prisma__BoqItemClient<$Result.GetResult<Prisma.$BoqItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BoqItems.
     * @param {BoqItemCreateManyArgs} args - Arguments to create many BoqItems.
     * @example
     * // Create many BoqItems
     * const boqItem = await prisma.boqItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BoqItemCreateManyArgs>(args?: SelectSubset<T, BoqItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BoqItem.
     * @param {BoqItemDeleteArgs} args - Arguments to delete one BoqItem.
     * @example
     * // Delete one BoqItem
     * const BoqItem = await prisma.boqItem.delete({
     *   where: {
     *     // ... filter to delete one BoqItem
     *   }
     * })
     * 
     */
    delete<T extends BoqItemDeleteArgs>(args: SelectSubset<T, BoqItemDeleteArgs<ExtArgs>>): Prisma__BoqItemClient<$Result.GetResult<Prisma.$BoqItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BoqItem.
     * @param {BoqItemUpdateArgs} args - Arguments to update one BoqItem.
     * @example
     * // Update one BoqItem
     * const boqItem = await prisma.boqItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BoqItemUpdateArgs>(args: SelectSubset<T, BoqItemUpdateArgs<ExtArgs>>): Prisma__BoqItemClient<$Result.GetResult<Prisma.$BoqItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BoqItems.
     * @param {BoqItemDeleteManyArgs} args - Arguments to filter BoqItems to delete.
     * @example
     * // Delete a few BoqItems
     * const { count } = await prisma.boqItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BoqItemDeleteManyArgs>(args?: SelectSubset<T, BoqItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BoqItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoqItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BoqItems
     * const boqItem = await prisma.boqItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BoqItemUpdateManyArgs>(args: SelectSubset<T, BoqItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BoqItem.
     * @param {BoqItemUpsertArgs} args - Arguments to update or create a BoqItem.
     * @example
     * // Update or create a BoqItem
     * const boqItem = await prisma.boqItem.upsert({
     *   create: {
     *     // ... data to create a BoqItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BoqItem we want to update
     *   }
     * })
     */
    upsert<T extends BoqItemUpsertArgs>(args: SelectSubset<T, BoqItemUpsertArgs<ExtArgs>>): Prisma__BoqItemClient<$Result.GetResult<Prisma.$BoqItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BoqItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoqItemCountArgs} args - Arguments to filter BoqItems to count.
     * @example
     * // Count the number of BoqItems
     * const count = await prisma.boqItem.count({
     *   where: {
     *     // ... the filter for the BoqItems we want to count
     *   }
     * })
    **/
    count<T extends BoqItemCountArgs>(
      args?: Subset<T, BoqItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BoqItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BoqItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoqItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BoqItemAggregateArgs>(args: Subset<T, BoqItemAggregateArgs>): Prisma.PrismaPromise<GetBoqItemAggregateType<T>>

    /**
     * Group by BoqItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoqItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BoqItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BoqItemGroupByArgs['orderBy'] }
        : { orderBy?: BoqItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BoqItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBoqItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BoqItem model
   */
  readonly fields: BoqItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BoqItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BoqItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    boqComponents<T extends BoqItem$boqComponentsArgs<ExtArgs> = {}>(args?: Subset<T, BoqItem$boqComponentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BoqItemComponentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BoqItem model
   */ 
  interface BoqItemFieldRefs {
    readonly id: FieldRef<"BoqItem", 'Int'>
    readonly projectId: FieldRef<"BoqItem", 'Int'>
    readonly itemDescription: FieldRef<"BoqItem", 'String'>
    readonly unit: FieldRef<"BoqItem", 'String'>
    readonly materialUnitPrice: FieldRef<"BoqItem", 'Decimal'>
    readonly laborUnitPrice: FieldRef<"BoqItem", 'Decimal'>
    readonly quantity: FieldRef<"BoqItem", 'Decimal'>
    readonly isCarport: FieldRef<"BoqItem", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * BoqItem findUnique
   */
  export type BoqItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoqItem
     */
    select?: BoqItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoqItemInclude<ExtArgs> | null
    /**
     * Filter, which BoqItem to fetch.
     */
    where: BoqItemWhereUniqueInput
  }

  /**
   * BoqItem findUniqueOrThrow
   */
  export type BoqItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoqItem
     */
    select?: BoqItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoqItemInclude<ExtArgs> | null
    /**
     * Filter, which BoqItem to fetch.
     */
    where: BoqItemWhereUniqueInput
  }

  /**
   * BoqItem findFirst
   */
  export type BoqItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoqItem
     */
    select?: BoqItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoqItemInclude<ExtArgs> | null
    /**
     * Filter, which BoqItem to fetch.
     */
    where?: BoqItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BoqItems to fetch.
     */
    orderBy?: BoqItemOrderByWithRelationInput | BoqItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BoqItems.
     */
    cursor?: BoqItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BoqItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BoqItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BoqItems.
     */
    distinct?: BoqItemScalarFieldEnum | BoqItemScalarFieldEnum[]
  }

  /**
   * BoqItem findFirstOrThrow
   */
  export type BoqItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoqItem
     */
    select?: BoqItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoqItemInclude<ExtArgs> | null
    /**
     * Filter, which BoqItem to fetch.
     */
    where?: BoqItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BoqItems to fetch.
     */
    orderBy?: BoqItemOrderByWithRelationInput | BoqItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BoqItems.
     */
    cursor?: BoqItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BoqItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BoqItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BoqItems.
     */
    distinct?: BoqItemScalarFieldEnum | BoqItemScalarFieldEnum[]
  }

  /**
   * BoqItem findMany
   */
  export type BoqItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoqItem
     */
    select?: BoqItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoqItemInclude<ExtArgs> | null
    /**
     * Filter, which BoqItems to fetch.
     */
    where?: BoqItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BoqItems to fetch.
     */
    orderBy?: BoqItemOrderByWithRelationInput | BoqItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BoqItems.
     */
    cursor?: BoqItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BoqItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BoqItems.
     */
    skip?: number
    distinct?: BoqItemScalarFieldEnum | BoqItemScalarFieldEnum[]
  }

  /**
   * BoqItem create
   */
  export type BoqItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoqItem
     */
    select?: BoqItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoqItemInclude<ExtArgs> | null
    /**
     * The data needed to create a BoqItem.
     */
    data: XOR<BoqItemCreateInput, BoqItemUncheckedCreateInput>
  }

  /**
   * BoqItem createMany
   */
  export type BoqItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BoqItems.
     */
    data: BoqItemCreateManyInput | BoqItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BoqItem update
   */
  export type BoqItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoqItem
     */
    select?: BoqItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoqItemInclude<ExtArgs> | null
    /**
     * The data needed to update a BoqItem.
     */
    data: XOR<BoqItemUpdateInput, BoqItemUncheckedUpdateInput>
    /**
     * Choose, which BoqItem to update.
     */
    where: BoqItemWhereUniqueInput
  }

  /**
   * BoqItem updateMany
   */
  export type BoqItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BoqItems.
     */
    data: XOR<BoqItemUpdateManyMutationInput, BoqItemUncheckedUpdateManyInput>
    /**
     * Filter which BoqItems to update
     */
    where?: BoqItemWhereInput
  }

  /**
   * BoqItem upsert
   */
  export type BoqItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoqItem
     */
    select?: BoqItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoqItemInclude<ExtArgs> | null
    /**
     * The filter to search for the BoqItem to update in case it exists.
     */
    where: BoqItemWhereUniqueInput
    /**
     * In case the BoqItem found by the `where` argument doesn't exist, create a new BoqItem with this data.
     */
    create: XOR<BoqItemCreateInput, BoqItemUncheckedCreateInput>
    /**
     * In case the BoqItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BoqItemUpdateInput, BoqItemUncheckedUpdateInput>
  }

  /**
   * BoqItem delete
   */
  export type BoqItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoqItem
     */
    select?: BoqItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoqItemInclude<ExtArgs> | null
    /**
     * Filter which BoqItem to delete.
     */
    where: BoqItemWhereUniqueInput
  }

  /**
   * BoqItem deleteMany
   */
  export type BoqItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BoqItems to delete
     */
    where?: BoqItemWhereInput
  }

  /**
   * BoqItem.boqComponents
   */
  export type BoqItem$boqComponentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoqItemComponent
     */
    select?: BoqItemComponentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoqItemComponentInclude<ExtArgs> | null
    where?: BoqItemComponentWhereInput
    orderBy?: BoqItemComponentOrderByWithRelationInput | BoqItemComponentOrderByWithRelationInput[]
    cursor?: BoqItemComponentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BoqItemComponentScalarFieldEnum | BoqItemComponentScalarFieldEnum[]
  }

  /**
   * BoqItem without action
   */
  export type BoqItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoqItem
     */
    select?: BoqItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoqItemInclude<ExtArgs> | null
  }


  /**
   * Model BoqItemComponent
   */

  export type AggregateBoqItemComponent = {
    _count: BoqItemComponentCountAggregateOutputType | null
    _avg: BoqItemComponentAvgAggregateOutputType | null
    _sum: BoqItemComponentSumAggregateOutputType | null
    _min: BoqItemComponentMinAggregateOutputType | null
    _max: BoqItemComponentMaxAggregateOutputType | null
  }

  export type BoqItemComponentAvgAggregateOutputType = {
    id: number | null
    boqItemId: number | null
    quantityFactor: Decimal | null
    unitRate: Decimal | null
    totalComponentCost: Decimal | null
  }

  export type BoqItemComponentSumAggregateOutputType = {
    id: number | null
    boqItemId: number | null
    quantityFactor: Decimal | null
    unitRate: Decimal | null
    totalComponentCost: Decimal | null
  }

  export type BoqItemComponentMinAggregateOutputType = {
    id: number | null
    boqItemId: number | null
    resourceType: $Enums.ResourceType | null
    name: string | null
    quantityFactor: Decimal | null
    unitRate: Decimal | null
    totalComponentCost: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BoqItemComponentMaxAggregateOutputType = {
    id: number | null
    boqItemId: number | null
    resourceType: $Enums.ResourceType | null
    name: string | null
    quantityFactor: Decimal | null
    unitRate: Decimal | null
    totalComponentCost: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BoqItemComponentCountAggregateOutputType = {
    id: number
    boqItemId: number
    resourceType: number
    name: number
    quantityFactor: number
    unitRate: number
    totalComponentCost: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BoqItemComponentAvgAggregateInputType = {
    id?: true
    boqItemId?: true
    quantityFactor?: true
    unitRate?: true
    totalComponentCost?: true
  }

  export type BoqItemComponentSumAggregateInputType = {
    id?: true
    boqItemId?: true
    quantityFactor?: true
    unitRate?: true
    totalComponentCost?: true
  }

  export type BoqItemComponentMinAggregateInputType = {
    id?: true
    boqItemId?: true
    resourceType?: true
    name?: true
    quantityFactor?: true
    unitRate?: true
    totalComponentCost?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BoqItemComponentMaxAggregateInputType = {
    id?: true
    boqItemId?: true
    resourceType?: true
    name?: true
    quantityFactor?: true
    unitRate?: true
    totalComponentCost?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BoqItemComponentCountAggregateInputType = {
    id?: true
    boqItemId?: true
    resourceType?: true
    name?: true
    quantityFactor?: true
    unitRate?: true
    totalComponentCost?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BoqItemComponentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BoqItemComponent to aggregate.
     */
    where?: BoqItemComponentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BoqItemComponents to fetch.
     */
    orderBy?: BoqItemComponentOrderByWithRelationInput | BoqItemComponentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BoqItemComponentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BoqItemComponents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BoqItemComponents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BoqItemComponents
    **/
    _count?: true | BoqItemComponentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BoqItemComponentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BoqItemComponentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BoqItemComponentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BoqItemComponentMaxAggregateInputType
  }

  export type GetBoqItemComponentAggregateType<T extends BoqItemComponentAggregateArgs> = {
        [P in keyof T & keyof AggregateBoqItemComponent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBoqItemComponent[P]>
      : GetScalarType<T[P], AggregateBoqItemComponent[P]>
  }




  export type BoqItemComponentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BoqItemComponentWhereInput
    orderBy?: BoqItemComponentOrderByWithAggregationInput | BoqItemComponentOrderByWithAggregationInput[]
    by: BoqItemComponentScalarFieldEnum[] | BoqItemComponentScalarFieldEnum
    having?: BoqItemComponentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BoqItemComponentCountAggregateInputType | true
    _avg?: BoqItemComponentAvgAggregateInputType
    _sum?: BoqItemComponentSumAggregateInputType
    _min?: BoqItemComponentMinAggregateInputType
    _max?: BoqItemComponentMaxAggregateInputType
  }

  export type BoqItemComponentGroupByOutputType = {
    id: number
    boqItemId: number
    resourceType: $Enums.ResourceType
    name: string
    quantityFactor: Decimal
    unitRate: Decimal
    totalComponentCost: Decimal
    createdAt: Date
    updatedAt: Date
    _count: BoqItemComponentCountAggregateOutputType | null
    _avg: BoqItemComponentAvgAggregateOutputType | null
    _sum: BoqItemComponentSumAggregateOutputType | null
    _min: BoqItemComponentMinAggregateOutputType | null
    _max: BoqItemComponentMaxAggregateOutputType | null
  }

  type GetBoqItemComponentGroupByPayload<T extends BoqItemComponentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BoqItemComponentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BoqItemComponentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BoqItemComponentGroupByOutputType[P]>
            : GetScalarType<T[P], BoqItemComponentGroupByOutputType[P]>
        }
      >
    >


  export type BoqItemComponentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    boqItemId?: boolean
    resourceType?: boolean
    name?: boolean
    quantityFactor?: boolean
    unitRate?: boolean
    totalComponentCost?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    boqItem?: boolean | BoqItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["boqItemComponent"]>


  export type BoqItemComponentSelectScalar = {
    id?: boolean
    boqItemId?: boolean
    resourceType?: boolean
    name?: boolean
    quantityFactor?: boolean
    unitRate?: boolean
    totalComponentCost?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BoqItemComponentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    boqItem?: boolean | BoqItemDefaultArgs<ExtArgs>
  }

  export type $BoqItemComponentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BoqItemComponent"
    objects: {
      boqItem: Prisma.$BoqItemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      boqItemId: number
      resourceType: $Enums.ResourceType
      name: string
      quantityFactor: Prisma.Decimal
      unitRate: Prisma.Decimal
      totalComponentCost: Prisma.Decimal
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["boqItemComponent"]>
    composites: {}
  }

  type BoqItemComponentGetPayload<S extends boolean | null | undefined | BoqItemComponentDefaultArgs> = $Result.GetResult<Prisma.$BoqItemComponentPayload, S>

  type BoqItemComponentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BoqItemComponentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BoqItemComponentCountAggregateInputType | true
    }

  export interface BoqItemComponentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BoqItemComponent'], meta: { name: 'BoqItemComponent' } }
    /**
     * Find zero or one BoqItemComponent that matches the filter.
     * @param {BoqItemComponentFindUniqueArgs} args - Arguments to find a BoqItemComponent
     * @example
     * // Get one BoqItemComponent
     * const boqItemComponent = await prisma.boqItemComponent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BoqItemComponentFindUniqueArgs>(args: SelectSubset<T, BoqItemComponentFindUniqueArgs<ExtArgs>>): Prisma__BoqItemComponentClient<$Result.GetResult<Prisma.$BoqItemComponentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BoqItemComponent that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BoqItemComponentFindUniqueOrThrowArgs} args - Arguments to find a BoqItemComponent
     * @example
     * // Get one BoqItemComponent
     * const boqItemComponent = await prisma.boqItemComponent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BoqItemComponentFindUniqueOrThrowArgs>(args: SelectSubset<T, BoqItemComponentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BoqItemComponentClient<$Result.GetResult<Prisma.$BoqItemComponentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BoqItemComponent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoqItemComponentFindFirstArgs} args - Arguments to find a BoqItemComponent
     * @example
     * // Get one BoqItemComponent
     * const boqItemComponent = await prisma.boqItemComponent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BoqItemComponentFindFirstArgs>(args?: SelectSubset<T, BoqItemComponentFindFirstArgs<ExtArgs>>): Prisma__BoqItemComponentClient<$Result.GetResult<Prisma.$BoqItemComponentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BoqItemComponent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoqItemComponentFindFirstOrThrowArgs} args - Arguments to find a BoqItemComponent
     * @example
     * // Get one BoqItemComponent
     * const boqItemComponent = await prisma.boqItemComponent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BoqItemComponentFindFirstOrThrowArgs>(args?: SelectSubset<T, BoqItemComponentFindFirstOrThrowArgs<ExtArgs>>): Prisma__BoqItemComponentClient<$Result.GetResult<Prisma.$BoqItemComponentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BoqItemComponents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoqItemComponentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BoqItemComponents
     * const boqItemComponents = await prisma.boqItemComponent.findMany()
     * 
     * // Get first 10 BoqItemComponents
     * const boqItemComponents = await prisma.boqItemComponent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const boqItemComponentWithIdOnly = await prisma.boqItemComponent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BoqItemComponentFindManyArgs>(args?: SelectSubset<T, BoqItemComponentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BoqItemComponentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BoqItemComponent.
     * @param {BoqItemComponentCreateArgs} args - Arguments to create a BoqItemComponent.
     * @example
     * // Create one BoqItemComponent
     * const BoqItemComponent = await prisma.boqItemComponent.create({
     *   data: {
     *     // ... data to create a BoqItemComponent
     *   }
     * })
     * 
     */
    create<T extends BoqItemComponentCreateArgs>(args: SelectSubset<T, BoqItemComponentCreateArgs<ExtArgs>>): Prisma__BoqItemComponentClient<$Result.GetResult<Prisma.$BoqItemComponentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BoqItemComponents.
     * @param {BoqItemComponentCreateManyArgs} args - Arguments to create many BoqItemComponents.
     * @example
     * // Create many BoqItemComponents
     * const boqItemComponent = await prisma.boqItemComponent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BoqItemComponentCreateManyArgs>(args?: SelectSubset<T, BoqItemComponentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BoqItemComponent.
     * @param {BoqItemComponentDeleteArgs} args - Arguments to delete one BoqItemComponent.
     * @example
     * // Delete one BoqItemComponent
     * const BoqItemComponent = await prisma.boqItemComponent.delete({
     *   where: {
     *     // ... filter to delete one BoqItemComponent
     *   }
     * })
     * 
     */
    delete<T extends BoqItemComponentDeleteArgs>(args: SelectSubset<T, BoqItemComponentDeleteArgs<ExtArgs>>): Prisma__BoqItemComponentClient<$Result.GetResult<Prisma.$BoqItemComponentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BoqItemComponent.
     * @param {BoqItemComponentUpdateArgs} args - Arguments to update one BoqItemComponent.
     * @example
     * // Update one BoqItemComponent
     * const boqItemComponent = await prisma.boqItemComponent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BoqItemComponentUpdateArgs>(args: SelectSubset<T, BoqItemComponentUpdateArgs<ExtArgs>>): Prisma__BoqItemComponentClient<$Result.GetResult<Prisma.$BoqItemComponentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BoqItemComponents.
     * @param {BoqItemComponentDeleteManyArgs} args - Arguments to filter BoqItemComponents to delete.
     * @example
     * // Delete a few BoqItemComponents
     * const { count } = await prisma.boqItemComponent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BoqItemComponentDeleteManyArgs>(args?: SelectSubset<T, BoqItemComponentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BoqItemComponents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoqItemComponentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BoqItemComponents
     * const boqItemComponent = await prisma.boqItemComponent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BoqItemComponentUpdateManyArgs>(args: SelectSubset<T, BoqItemComponentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BoqItemComponent.
     * @param {BoqItemComponentUpsertArgs} args - Arguments to update or create a BoqItemComponent.
     * @example
     * // Update or create a BoqItemComponent
     * const boqItemComponent = await prisma.boqItemComponent.upsert({
     *   create: {
     *     // ... data to create a BoqItemComponent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BoqItemComponent we want to update
     *   }
     * })
     */
    upsert<T extends BoqItemComponentUpsertArgs>(args: SelectSubset<T, BoqItemComponentUpsertArgs<ExtArgs>>): Prisma__BoqItemComponentClient<$Result.GetResult<Prisma.$BoqItemComponentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BoqItemComponents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoqItemComponentCountArgs} args - Arguments to filter BoqItemComponents to count.
     * @example
     * // Count the number of BoqItemComponents
     * const count = await prisma.boqItemComponent.count({
     *   where: {
     *     // ... the filter for the BoqItemComponents we want to count
     *   }
     * })
    **/
    count<T extends BoqItemComponentCountArgs>(
      args?: Subset<T, BoqItemComponentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BoqItemComponentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BoqItemComponent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoqItemComponentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BoqItemComponentAggregateArgs>(args: Subset<T, BoqItemComponentAggregateArgs>): Prisma.PrismaPromise<GetBoqItemComponentAggregateType<T>>

    /**
     * Group by BoqItemComponent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoqItemComponentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BoqItemComponentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BoqItemComponentGroupByArgs['orderBy'] }
        : { orderBy?: BoqItemComponentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BoqItemComponentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBoqItemComponentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BoqItemComponent model
   */
  readonly fields: BoqItemComponentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BoqItemComponent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BoqItemComponentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    boqItem<T extends BoqItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BoqItemDefaultArgs<ExtArgs>>): Prisma__BoqItemClient<$Result.GetResult<Prisma.$BoqItemPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BoqItemComponent model
   */ 
  interface BoqItemComponentFieldRefs {
    readonly id: FieldRef<"BoqItemComponent", 'Int'>
    readonly boqItemId: FieldRef<"BoqItemComponent", 'Int'>
    readonly resourceType: FieldRef<"BoqItemComponent", 'ResourceType'>
    readonly name: FieldRef<"BoqItemComponent", 'String'>
    readonly quantityFactor: FieldRef<"BoqItemComponent", 'Decimal'>
    readonly unitRate: FieldRef<"BoqItemComponent", 'Decimal'>
    readonly totalComponentCost: FieldRef<"BoqItemComponent", 'Decimal'>
    readonly createdAt: FieldRef<"BoqItemComponent", 'DateTime'>
    readonly updatedAt: FieldRef<"BoqItemComponent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BoqItemComponent findUnique
   */
  export type BoqItemComponentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoqItemComponent
     */
    select?: BoqItemComponentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoqItemComponentInclude<ExtArgs> | null
    /**
     * Filter, which BoqItemComponent to fetch.
     */
    where: BoqItemComponentWhereUniqueInput
  }

  /**
   * BoqItemComponent findUniqueOrThrow
   */
  export type BoqItemComponentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoqItemComponent
     */
    select?: BoqItemComponentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoqItemComponentInclude<ExtArgs> | null
    /**
     * Filter, which BoqItemComponent to fetch.
     */
    where: BoqItemComponentWhereUniqueInput
  }

  /**
   * BoqItemComponent findFirst
   */
  export type BoqItemComponentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoqItemComponent
     */
    select?: BoqItemComponentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoqItemComponentInclude<ExtArgs> | null
    /**
     * Filter, which BoqItemComponent to fetch.
     */
    where?: BoqItemComponentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BoqItemComponents to fetch.
     */
    orderBy?: BoqItemComponentOrderByWithRelationInput | BoqItemComponentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BoqItemComponents.
     */
    cursor?: BoqItemComponentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BoqItemComponents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BoqItemComponents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BoqItemComponents.
     */
    distinct?: BoqItemComponentScalarFieldEnum | BoqItemComponentScalarFieldEnum[]
  }

  /**
   * BoqItemComponent findFirstOrThrow
   */
  export type BoqItemComponentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoqItemComponent
     */
    select?: BoqItemComponentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoqItemComponentInclude<ExtArgs> | null
    /**
     * Filter, which BoqItemComponent to fetch.
     */
    where?: BoqItemComponentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BoqItemComponents to fetch.
     */
    orderBy?: BoqItemComponentOrderByWithRelationInput | BoqItemComponentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BoqItemComponents.
     */
    cursor?: BoqItemComponentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BoqItemComponents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BoqItemComponents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BoqItemComponents.
     */
    distinct?: BoqItemComponentScalarFieldEnum | BoqItemComponentScalarFieldEnum[]
  }

  /**
   * BoqItemComponent findMany
   */
  export type BoqItemComponentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoqItemComponent
     */
    select?: BoqItemComponentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoqItemComponentInclude<ExtArgs> | null
    /**
     * Filter, which BoqItemComponents to fetch.
     */
    where?: BoqItemComponentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BoqItemComponents to fetch.
     */
    orderBy?: BoqItemComponentOrderByWithRelationInput | BoqItemComponentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BoqItemComponents.
     */
    cursor?: BoqItemComponentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BoqItemComponents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BoqItemComponents.
     */
    skip?: number
    distinct?: BoqItemComponentScalarFieldEnum | BoqItemComponentScalarFieldEnum[]
  }

  /**
   * BoqItemComponent create
   */
  export type BoqItemComponentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoqItemComponent
     */
    select?: BoqItemComponentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoqItemComponentInclude<ExtArgs> | null
    /**
     * The data needed to create a BoqItemComponent.
     */
    data: XOR<BoqItemComponentCreateInput, BoqItemComponentUncheckedCreateInput>
  }

  /**
   * BoqItemComponent createMany
   */
  export type BoqItemComponentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BoqItemComponents.
     */
    data: BoqItemComponentCreateManyInput | BoqItemComponentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BoqItemComponent update
   */
  export type BoqItemComponentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoqItemComponent
     */
    select?: BoqItemComponentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoqItemComponentInclude<ExtArgs> | null
    /**
     * The data needed to update a BoqItemComponent.
     */
    data: XOR<BoqItemComponentUpdateInput, BoqItemComponentUncheckedUpdateInput>
    /**
     * Choose, which BoqItemComponent to update.
     */
    where: BoqItemComponentWhereUniqueInput
  }

  /**
   * BoqItemComponent updateMany
   */
  export type BoqItemComponentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BoqItemComponents.
     */
    data: XOR<BoqItemComponentUpdateManyMutationInput, BoqItemComponentUncheckedUpdateManyInput>
    /**
     * Filter which BoqItemComponents to update
     */
    where?: BoqItemComponentWhereInput
  }

  /**
   * BoqItemComponent upsert
   */
  export type BoqItemComponentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoqItemComponent
     */
    select?: BoqItemComponentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoqItemComponentInclude<ExtArgs> | null
    /**
     * The filter to search for the BoqItemComponent to update in case it exists.
     */
    where: BoqItemComponentWhereUniqueInput
    /**
     * In case the BoqItemComponent found by the `where` argument doesn't exist, create a new BoqItemComponent with this data.
     */
    create: XOR<BoqItemComponentCreateInput, BoqItemComponentUncheckedCreateInput>
    /**
     * In case the BoqItemComponent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BoqItemComponentUpdateInput, BoqItemComponentUncheckedUpdateInput>
  }

  /**
   * BoqItemComponent delete
   */
  export type BoqItemComponentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoqItemComponent
     */
    select?: BoqItemComponentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoqItemComponentInclude<ExtArgs> | null
    /**
     * Filter which BoqItemComponent to delete.
     */
    where: BoqItemComponentWhereUniqueInput
  }

  /**
   * BoqItemComponent deleteMany
   */
  export type BoqItemComponentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BoqItemComponents to delete
     */
    where?: BoqItemComponentWhereInput
  }

  /**
   * BoqItemComponent without action
   */
  export type BoqItemComponentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoqItemComponent
     */
    select?: BoqItemComponentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoqItemComponentInclude<ExtArgs> | null
  }


  /**
   * Model MaterialRequest
   */

  export type AggregateMaterialRequest = {
    _count: MaterialRequestCountAggregateOutputType | null
    _avg: MaterialRequestAvgAggregateOutputType | null
    _sum: MaterialRequestSumAggregateOutputType | null
    _min: MaterialRequestMinAggregateOutputType | null
    _max: MaterialRequestMaxAggregateOutputType | null
  }

  export type MaterialRequestAvgAggregateOutputType = {
    id: number | null
    projectId: number | null
    requesterId: number | null
    approverId: number | null
  }

  export type MaterialRequestSumAggregateOutputType = {
    id: number | null
    projectId: number | null
    requesterId: number | null
    approverId: number | null
  }

  export type MaterialRequestMinAggregateOutputType = {
    id: number | null
    projectId: number | null
    requesterId: number | null
    approverId: number | null
    requestDate: Date | null
    status: $Enums.MrStatus | null
    remarks: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MaterialRequestMaxAggregateOutputType = {
    id: number | null
    projectId: number | null
    requesterId: number | null
    approverId: number | null
    requestDate: Date | null
    status: $Enums.MrStatus | null
    remarks: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MaterialRequestCountAggregateOutputType = {
    id: number
    projectId: number
    requesterId: number
    approverId: number
    requestDate: number
    status: number
    remarks: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MaterialRequestAvgAggregateInputType = {
    id?: true
    projectId?: true
    requesterId?: true
    approverId?: true
  }

  export type MaterialRequestSumAggregateInputType = {
    id?: true
    projectId?: true
    requesterId?: true
    approverId?: true
  }

  export type MaterialRequestMinAggregateInputType = {
    id?: true
    projectId?: true
    requesterId?: true
    approverId?: true
    requestDate?: true
    status?: true
    remarks?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MaterialRequestMaxAggregateInputType = {
    id?: true
    projectId?: true
    requesterId?: true
    approverId?: true
    requestDate?: true
    status?: true
    remarks?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MaterialRequestCountAggregateInputType = {
    id?: true
    projectId?: true
    requesterId?: true
    approverId?: true
    requestDate?: true
    status?: true
    remarks?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MaterialRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MaterialRequest to aggregate.
     */
    where?: MaterialRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaterialRequests to fetch.
     */
    orderBy?: MaterialRequestOrderByWithRelationInput | MaterialRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MaterialRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaterialRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaterialRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MaterialRequests
    **/
    _count?: true | MaterialRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MaterialRequestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MaterialRequestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MaterialRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MaterialRequestMaxAggregateInputType
  }

  export type GetMaterialRequestAggregateType<T extends MaterialRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateMaterialRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMaterialRequest[P]>
      : GetScalarType<T[P], AggregateMaterialRequest[P]>
  }




  export type MaterialRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaterialRequestWhereInput
    orderBy?: MaterialRequestOrderByWithAggregationInput | MaterialRequestOrderByWithAggregationInput[]
    by: MaterialRequestScalarFieldEnum[] | MaterialRequestScalarFieldEnum
    having?: MaterialRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MaterialRequestCountAggregateInputType | true
    _avg?: MaterialRequestAvgAggregateInputType
    _sum?: MaterialRequestSumAggregateInputType
    _min?: MaterialRequestMinAggregateInputType
    _max?: MaterialRequestMaxAggregateInputType
  }

  export type MaterialRequestGroupByOutputType = {
    id: number
    projectId: number
    requesterId: number
    approverId: number | null
    requestDate: Date
    status: $Enums.MrStatus
    remarks: string | null
    createdAt: Date
    updatedAt: Date
    _count: MaterialRequestCountAggregateOutputType | null
    _avg: MaterialRequestAvgAggregateOutputType | null
    _sum: MaterialRequestSumAggregateOutputType | null
    _min: MaterialRequestMinAggregateOutputType | null
    _max: MaterialRequestMaxAggregateOutputType | null
  }

  type GetMaterialRequestGroupByPayload<T extends MaterialRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MaterialRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MaterialRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MaterialRequestGroupByOutputType[P]>
            : GetScalarType<T[P], MaterialRequestGroupByOutputType[P]>
        }
      >
    >


  export type MaterialRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    requesterId?: boolean
    approverId?: boolean
    requestDate?: boolean
    status?: boolean
    remarks?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    requester?: boolean | UserDefaultArgs<ExtArgs>
    approver?: boolean | MaterialRequest$approverArgs<ExtArgs>
    items?: boolean | MaterialRequest$itemsArgs<ExtArgs>
    rfqs?: boolean | MaterialRequest$rfqsArgs<ExtArgs>
    _count?: boolean | MaterialRequestCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["materialRequest"]>


  export type MaterialRequestSelectScalar = {
    id?: boolean
    projectId?: boolean
    requesterId?: boolean
    approverId?: boolean
    requestDate?: boolean
    status?: boolean
    remarks?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MaterialRequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    requester?: boolean | UserDefaultArgs<ExtArgs>
    approver?: boolean | MaterialRequest$approverArgs<ExtArgs>
    items?: boolean | MaterialRequest$itemsArgs<ExtArgs>
    rfqs?: boolean | MaterialRequest$rfqsArgs<ExtArgs>
    _count?: boolean | MaterialRequestCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $MaterialRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MaterialRequest"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      requester: Prisma.$UserPayload<ExtArgs>
      approver: Prisma.$UserPayload<ExtArgs> | null
      items: Prisma.$MaterialRequestItemPayload<ExtArgs>[]
      rfqs: Prisma.$RFQPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      projectId: number
      requesterId: number
      approverId: number | null
      requestDate: Date
      status: $Enums.MrStatus
      remarks: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["materialRequest"]>
    composites: {}
  }

  type MaterialRequestGetPayload<S extends boolean | null | undefined | MaterialRequestDefaultArgs> = $Result.GetResult<Prisma.$MaterialRequestPayload, S>

  type MaterialRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MaterialRequestFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MaterialRequestCountAggregateInputType | true
    }

  export interface MaterialRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MaterialRequest'], meta: { name: 'MaterialRequest' } }
    /**
     * Find zero or one MaterialRequest that matches the filter.
     * @param {MaterialRequestFindUniqueArgs} args - Arguments to find a MaterialRequest
     * @example
     * // Get one MaterialRequest
     * const materialRequest = await prisma.materialRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MaterialRequestFindUniqueArgs>(args: SelectSubset<T, MaterialRequestFindUniqueArgs<ExtArgs>>): Prisma__MaterialRequestClient<$Result.GetResult<Prisma.$MaterialRequestPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MaterialRequest that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MaterialRequestFindUniqueOrThrowArgs} args - Arguments to find a MaterialRequest
     * @example
     * // Get one MaterialRequest
     * const materialRequest = await prisma.materialRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MaterialRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, MaterialRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MaterialRequestClient<$Result.GetResult<Prisma.$MaterialRequestPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MaterialRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialRequestFindFirstArgs} args - Arguments to find a MaterialRequest
     * @example
     * // Get one MaterialRequest
     * const materialRequest = await prisma.materialRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MaterialRequestFindFirstArgs>(args?: SelectSubset<T, MaterialRequestFindFirstArgs<ExtArgs>>): Prisma__MaterialRequestClient<$Result.GetResult<Prisma.$MaterialRequestPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MaterialRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialRequestFindFirstOrThrowArgs} args - Arguments to find a MaterialRequest
     * @example
     * // Get one MaterialRequest
     * const materialRequest = await prisma.materialRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MaterialRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, MaterialRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__MaterialRequestClient<$Result.GetResult<Prisma.$MaterialRequestPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MaterialRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MaterialRequests
     * const materialRequests = await prisma.materialRequest.findMany()
     * 
     * // Get first 10 MaterialRequests
     * const materialRequests = await prisma.materialRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const materialRequestWithIdOnly = await prisma.materialRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MaterialRequestFindManyArgs>(args?: SelectSubset<T, MaterialRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialRequestPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MaterialRequest.
     * @param {MaterialRequestCreateArgs} args - Arguments to create a MaterialRequest.
     * @example
     * // Create one MaterialRequest
     * const MaterialRequest = await prisma.materialRequest.create({
     *   data: {
     *     // ... data to create a MaterialRequest
     *   }
     * })
     * 
     */
    create<T extends MaterialRequestCreateArgs>(args: SelectSubset<T, MaterialRequestCreateArgs<ExtArgs>>): Prisma__MaterialRequestClient<$Result.GetResult<Prisma.$MaterialRequestPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MaterialRequests.
     * @param {MaterialRequestCreateManyArgs} args - Arguments to create many MaterialRequests.
     * @example
     * // Create many MaterialRequests
     * const materialRequest = await prisma.materialRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MaterialRequestCreateManyArgs>(args?: SelectSubset<T, MaterialRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MaterialRequest.
     * @param {MaterialRequestDeleteArgs} args - Arguments to delete one MaterialRequest.
     * @example
     * // Delete one MaterialRequest
     * const MaterialRequest = await prisma.materialRequest.delete({
     *   where: {
     *     // ... filter to delete one MaterialRequest
     *   }
     * })
     * 
     */
    delete<T extends MaterialRequestDeleteArgs>(args: SelectSubset<T, MaterialRequestDeleteArgs<ExtArgs>>): Prisma__MaterialRequestClient<$Result.GetResult<Prisma.$MaterialRequestPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MaterialRequest.
     * @param {MaterialRequestUpdateArgs} args - Arguments to update one MaterialRequest.
     * @example
     * // Update one MaterialRequest
     * const materialRequest = await prisma.materialRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MaterialRequestUpdateArgs>(args: SelectSubset<T, MaterialRequestUpdateArgs<ExtArgs>>): Prisma__MaterialRequestClient<$Result.GetResult<Prisma.$MaterialRequestPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MaterialRequests.
     * @param {MaterialRequestDeleteManyArgs} args - Arguments to filter MaterialRequests to delete.
     * @example
     * // Delete a few MaterialRequests
     * const { count } = await prisma.materialRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MaterialRequestDeleteManyArgs>(args?: SelectSubset<T, MaterialRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MaterialRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MaterialRequests
     * const materialRequest = await prisma.materialRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MaterialRequestUpdateManyArgs>(args: SelectSubset<T, MaterialRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MaterialRequest.
     * @param {MaterialRequestUpsertArgs} args - Arguments to update or create a MaterialRequest.
     * @example
     * // Update or create a MaterialRequest
     * const materialRequest = await prisma.materialRequest.upsert({
     *   create: {
     *     // ... data to create a MaterialRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MaterialRequest we want to update
     *   }
     * })
     */
    upsert<T extends MaterialRequestUpsertArgs>(args: SelectSubset<T, MaterialRequestUpsertArgs<ExtArgs>>): Prisma__MaterialRequestClient<$Result.GetResult<Prisma.$MaterialRequestPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MaterialRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialRequestCountArgs} args - Arguments to filter MaterialRequests to count.
     * @example
     * // Count the number of MaterialRequests
     * const count = await prisma.materialRequest.count({
     *   where: {
     *     // ... the filter for the MaterialRequests we want to count
     *   }
     * })
    **/
    count<T extends MaterialRequestCountArgs>(
      args?: Subset<T, MaterialRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MaterialRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MaterialRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MaterialRequestAggregateArgs>(args: Subset<T, MaterialRequestAggregateArgs>): Prisma.PrismaPromise<GetMaterialRequestAggregateType<T>>

    /**
     * Group by MaterialRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MaterialRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MaterialRequestGroupByArgs['orderBy'] }
        : { orderBy?: MaterialRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MaterialRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMaterialRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MaterialRequest model
   */
  readonly fields: MaterialRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MaterialRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MaterialRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    requester<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    approver<T extends MaterialRequest$approverArgs<ExtArgs> = {}>(args?: Subset<T, MaterialRequest$approverArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    items<T extends MaterialRequest$itemsArgs<ExtArgs> = {}>(args?: Subset<T, MaterialRequest$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialRequestItemPayload<ExtArgs>, T, "findMany"> | Null>
    rfqs<T extends MaterialRequest$rfqsArgs<ExtArgs> = {}>(args?: Subset<T, MaterialRequest$rfqsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RFQPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MaterialRequest model
   */ 
  interface MaterialRequestFieldRefs {
    readonly id: FieldRef<"MaterialRequest", 'Int'>
    readonly projectId: FieldRef<"MaterialRequest", 'Int'>
    readonly requesterId: FieldRef<"MaterialRequest", 'Int'>
    readonly approverId: FieldRef<"MaterialRequest", 'Int'>
    readonly requestDate: FieldRef<"MaterialRequest", 'DateTime'>
    readonly status: FieldRef<"MaterialRequest", 'MrStatus'>
    readonly remarks: FieldRef<"MaterialRequest", 'String'>
    readonly createdAt: FieldRef<"MaterialRequest", 'DateTime'>
    readonly updatedAt: FieldRef<"MaterialRequest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MaterialRequest findUnique
   */
  export type MaterialRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialRequest
     */
    select?: MaterialRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialRequestInclude<ExtArgs> | null
    /**
     * Filter, which MaterialRequest to fetch.
     */
    where: MaterialRequestWhereUniqueInput
  }

  /**
   * MaterialRequest findUniqueOrThrow
   */
  export type MaterialRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialRequest
     */
    select?: MaterialRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialRequestInclude<ExtArgs> | null
    /**
     * Filter, which MaterialRequest to fetch.
     */
    where: MaterialRequestWhereUniqueInput
  }

  /**
   * MaterialRequest findFirst
   */
  export type MaterialRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialRequest
     */
    select?: MaterialRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialRequestInclude<ExtArgs> | null
    /**
     * Filter, which MaterialRequest to fetch.
     */
    where?: MaterialRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaterialRequests to fetch.
     */
    orderBy?: MaterialRequestOrderByWithRelationInput | MaterialRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MaterialRequests.
     */
    cursor?: MaterialRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaterialRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaterialRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MaterialRequests.
     */
    distinct?: MaterialRequestScalarFieldEnum | MaterialRequestScalarFieldEnum[]
  }

  /**
   * MaterialRequest findFirstOrThrow
   */
  export type MaterialRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialRequest
     */
    select?: MaterialRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialRequestInclude<ExtArgs> | null
    /**
     * Filter, which MaterialRequest to fetch.
     */
    where?: MaterialRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaterialRequests to fetch.
     */
    orderBy?: MaterialRequestOrderByWithRelationInput | MaterialRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MaterialRequests.
     */
    cursor?: MaterialRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaterialRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaterialRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MaterialRequests.
     */
    distinct?: MaterialRequestScalarFieldEnum | MaterialRequestScalarFieldEnum[]
  }

  /**
   * MaterialRequest findMany
   */
  export type MaterialRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialRequest
     */
    select?: MaterialRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialRequestInclude<ExtArgs> | null
    /**
     * Filter, which MaterialRequests to fetch.
     */
    where?: MaterialRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaterialRequests to fetch.
     */
    orderBy?: MaterialRequestOrderByWithRelationInput | MaterialRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MaterialRequests.
     */
    cursor?: MaterialRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaterialRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaterialRequests.
     */
    skip?: number
    distinct?: MaterialRequestScalarFieldEnum | MaterialRequestScalarFieldEnum[]
  }

  /**
   * MaterialRequest create
   */
  export type MaterialRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialRequest
     */
    select?: MaterialRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialRequestInclude<ExtArgs> | null
    /**
     * The data needed to create a MaterialRequest.
     */
    data: XOR<MaterialRequestCreateInput, MaterialRequestUncheckedCreateInput>
  }

  /**
   * MaterialRequest createMany
   */
  export type MaterialRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MaterialRequests.
     */
    data: MaterialRequestCreateManyInput | MaterialRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MaterialRequest update
   */
  export type MaterialRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialRequest
     */
    select?: MaterialRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialRequestInclude<ExtArgs> | null
    /**
     * The data needed to update a MaterialRequest.
     */
    data: XOR<MaterialRequestUpdateInput, MaterialRequestUncheckedUpdateInput>
    /**
     * Choose, which MaterialRequest to update.
     */
    where: MaterialRequestWhereUniqueInput
  }

  /**
   * MaterialRequest updateMany
   */
  export type MaterialRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MaterialRequests.
     */
    data: XOR<MaterialRequestUpdateManyMutationInput, MaterialRequestUncheckedUpdateManyInput>
    /**
     * Filter which MaterialRequests to update
     */
    where?: MaterialRequestWhereInput
  }

  /**
   * MaterialRequest upsert
   */
  export type MaterialRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialRequest
     */
    select?: MaterialRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialRequestInclude<ExtArgs> | null
    /**
     * The filter to search for the MaterialRequest to update in case it exists.
     */
    where: MaterialRequestWhereUniqueInput
    /**
     * In case the MaterialRequest found by the `where` argument doesn't exist, create a new MaterialRequest with this data.
     */
    create: XOR<MaterialRequestCreateInput, MaterialRequestUncheckedCreateInput>
    /**
     * In case the MaterialRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MaterialRequestUpdateInput, MaterialRequestUncheckedUpdateInput>
  }

  /**
   * MaterialRequest delete
   */
  export type MaterialRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialRequest
     */
    select?: MaterialRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialRequestInclude<ExtArgs> | null
    /**
     * Filter which MaterialRequest to delete.
     */
    where: MaterialRequestWhereUniqueInput
  }

  /**
   * MaterialRequest deleteMany
   */
  export type MaterialRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MaterialRequests to delete
     */
    where?: MaterialRequestWhereInput
  }

  /**
   * MaterialRequest.approver
   */
  export type MaterialRequest$approverArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * MaterialRequest.items
   */
  export type MaterialRequest$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialRequestItem
     */
    select?: MaterialRequestItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialRequestItemInclude<ExtArgs> | null
    where?: MaterialRequestItemWhereInput
    orderBy?: MaterialRequestItemOrderByWithRelationInput | MaterialRequestItemOrderByWithRelationInput[]
    cursor?: MaterialRequestItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MaterialRequestItemScalarFieldEnum | MaterialRequestItemScalarFieldEnum[]
  }

  /**
   * MaterialRequest.rfqs
   */
  export type MaterialRequest$rfqsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RFQ
     */
    select?: RFQSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RFQInclude<ExtArgs> | null
    where?: RFQWhereInput
    orderBy?: RFQOrderByWithRelationInput | RFQOrderByWithRelationInput[]
    cursor?: RFQWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RFQScalarFieldEnum | RFQScalarFieldEnum[]
  }

  /**
   * MaterialRequest without action
   */
  export type MaterialRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialRequest
     */
    select?: MaterialRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialRequestInclude<ExtArgs> | null
  }


  /**
   * Model MaterialRequestItem
   */

  export type AggregateMaterialRequestItem = {
    _count: MaterialRequestItemCountAggregateOutputType | null
    _avg: MaterialRequestItemAvgAggregateOutputType | null
    _sum: MaterialRequestItemSumAggregateOutputType | null
    _min: MaterialRequestItemMinAggregateOutputType | null
    _max: MaterialRequestItemMaxAggregateOutputType | null
  }

  export type MaterialRequestItemAvgAggregateOutputType = {
    id: number | null
    materialRequestId: number | null
    quantity: Decimal | null
    materialUnitPrice: Decimal | null
    laborUnitPrice: Decimal | null
  }

  export type MaterialRequestItemSumAggregateOutputType = {
    id: number | null
    materialRequestId: number | null
    quantity: Decimal | null
    materialUnitPrice: Decimal | null
    laborUnitPrice: Decimal | null
  }

  export type MaterialRequestItemMinAggregateOutputType = {
    id: number | null
    materialRequestId: number | null
    itemDescription: string | null
    description: string | null
    quantity: Decimal | null
    materialUnitPrice: Decimal | null
    laborUnitPrice: Decimal | null
    unit: string | null
  }

  export type MaterialRequestItemMaxAggregateOutputType = {
    id: number | null
    materialRequestId: number | null
    itemDescription: string | null
    description: string | null
    quantity: Decimal | null
    materialUnitPrice: Decimal | null
    laborUnitPrice: Decimal | null
    unit: string | null
  }

  export type MaterialRequestItemCountAggregateOutputType = {
    id: number
    materialRequestId: number
    itemDescription: number
    description: number
    quantity: number
    materialUnitPrice: number
    laborUnitPrice: number
    unit: number
    _all: number
  }


  export type MaterialRequestItemAvgAggregateInputType = {
    id?: true
    materialRequestId?: true
    quantity?: true
    materialUnitPrice?: true
    laborUnitPrice?: true
  }

  export type MaterialRequestItemSumAggregateInputType = {
    id?: true
    materialRequestId?: true
    quantity?: true
    materialUnitPrice?: true
    laborUnitPrice?: true
  }

  export type MaterialRequestItemMinAggregateInputType = {
    id?: true
    materialRequestId?: true
    itemDescription?: true
    description?: true
    quantity?: true
    materialUnitPrice?: true
    laborUnitPrice?: true
    unit?: true
  }

  export type MaterialRequestItemMaxAggregateInputType = {
    id?: true
    materialRequestId?: true
    itemDescription?: true
    description?: true
    quantity?: true
    materialUnitPrice?: true
    laborUnitPrice?: true
    unit?: true
  }

  export type MaterialRequestItemCountAggregateInputType = {
    id?: true
    materialRequestId?: true
    itemDescription?: true
    description?: true
    quantity?: true
    materialUnitPrice?: true
    laborUnitPrice?: true
    unit?: true
    _all?: true
  }

  export type MaterialRequestItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MaterialRequestItem to aggregate.
     */
    where?: MaterialRequestItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaterialRequestItems to fetch.
     */
    orderBy?: MaterialRequestItemOrderByWithRelationInput | MaterialRequestItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MaterialRequestItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaterialRequestItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaterialRequestItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MaterialRequestItems
    **/
    _count?: true | MaterialRequestItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MaterialRequestItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MaterialRequestItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MaterialRequestItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MaterialRequestItemMaxAggregateInputType
  }

  export type GetMaterialRequestItemAggregateType<T extends MaterialRequestItemAggregateArgs> = {
        [P in keyof T & keyof AggregateMaterialRequestItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMaterialRequestItem[P]>
      : GetScalarType<T[P], AggregateMaterialRequestItem[P]>
  }




  export type MaterialRequestItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaterialRequestItemWhereInput
    orderBy?: MaterialRequestItemOrderByWithAggregationInput | MaterialRequestItemOrderByWithAggregationInput[]
    by: MaterialRequestItemScalarFieldEnum[] | MaterialRequestItemScalarFieldEnum
    having?: MaterialRequestItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MaterialRequestItemCountAggregateInputType | true
    _avg?: MaterialRequestItemAvgAggregateInputType
    _sum?: MaterialRequestItemSumAggregateInputType
    _min?: MaterialRequestItemMinAggregateInputType
    _max?: MaterialRequestItemMaxAggregateInputType
  }

  export type MaterialRequestItemGroupByOutputType = {
    id: number
    materialRequestId: number
    itemDescription: string
    description: string | null
    quantity: Decimal
    materialUnitPrice: Decimal
    laborUnitPrice: Decimal
    unit: string
    _count: MaterialRequestItemCountAggregateOutputType | null
    _avg: MaterialRequestItemAvgAggregateOutputType | null
    _sum: MaterialRequestItemSumAggregateOutputType | null
    _min: MaterialRequestItemMinAggregateOutputType | null
    _max: MaterialRequestItemMaxAggregateOutputType | null
  }

  type GetMaterialRequestItemGroupByPayload<T extends MaterialRequestItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MaterialRequestItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MaterialRequestItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MaterialRequestItemGroupByOutputType[P]>
            : GetScalarType<T[P], MaterialRequestItemGroupByOutputType[P]>
        }
      >
    >


  export type MaterialRequestItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    materialRequestId?: boolean
    itemDescription?: boolean
    description?: boolean
    quantity?: boolean
    materialUnitPrice?: boolean
    laborUnitPrice?: boolean
    unit?: boolean
    materialRequest?: boolean | MaterialRequestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["materialRequestItem"]>


  export type MaterialRequestItemSelectScalar = {
    id?: boolean
    materialRequestId?: boolean
    itemDescription?: boolean
    description?: boolean
    quantity?: boolean
    materialUnitPrice?: boolean
    laborUnitPrice?: boolean
    unit?: boolean
  }

  export type MaterialRequestItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    materialRequest?: boolean | MaterialRequestDefaultArgs<ExtArgs>
  }

  export type $MaterialRequestItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MaterialRequestItem"
    objects: {
      materialRequest: Prisma.$MaterialRequestPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      materialRequestId: number
      itemDescription: string
      description: string | null
      quantity: Prisma.Decimal
      materialUnitPrice: Prisma.Decimal
      laborUnitPrice: Prisma.Decimal
      unit: string
    }, ExtArgs["result"]["materialRequestItem"]>
    composites: {}
  }

  type MaterialRequestItemGetPayload<S extends boolean | null | undefined | MaterialRequestItemDefaultArgs> = $Result.GetResult<Prisma.$MaterialRequestItemPayload, S>

  type MaterialRequestItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MaterialRequestItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MaterialRequestItemCountAggregateInputType | true
    }

  export interface MaterialRequestItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MaterialRequestItem'], meta: { name: 'MaterialRequestItem' } }
    /**
     * Find zero or one MaterialRequestItem that matches the filter.
     * @param {MaterialRequestItemFindUniqueArgs} args - Arguments to find a MaterialRequestItem
     * @example
     * // Get one MaterialRequestItem
     * const materialRequestItem = await prisma.materialRequestItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MaterialRequestItemFindUniqueArgs>(args: SelectSubset<T, MaterialRequestItemFindUniqueArgs<ExtArgs>>): Prisma__MaterialRequestItemClient<$Result.GetResult<Prisma.$MaterialRequestItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MaterialRequestItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MaterialRequestItemFindUniqueOrThrowArgs} args - Arguments to find a MaterialRequestItem
     * @example
     * // Get one MaterialRequestItem
     * const materialRequestItem = await prisma.materialRequestItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MaterialRequestItemFindUniqueOrThrowArgs>(args: SelectSubset<T, MaterialRequestItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MaterialRequestItemClient<$Result.GetResult<Prisma.$MaterialRequestItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MaterialRequestItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialRequestItemFindFirstArgs} args - Arguments to find a MaterialRequestItem
     * @example
     * // Get one MaterialRequestItem
     * const materialRequestItem = await prisma.materialRequestItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MaterialRequestItemFindFirstArgs>(args?: SelectSubset<T, MaterialRequestItemFindFirstArgs<ExtArgs>>): Prisma__MaterialRequestItemClient<$Result.GetResult<Prisma.$MaterialRequestItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MaterialRequestItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialRequestItemFindFirstOrThrowArgs} args - Arguments to find a MaterialRequestItem
     * @example
     * // Get one MaterialRequestItem
     * const materialRequestItem = await prisma.materialRequestItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MaterialRequestItemFindFirstOrThrowArgs>(args?: SelectSubset<T, MaterialRequestItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__MaterialRequestItemClient<$Result.GetResult<Prisma.$MaterialRequestItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MaterialRequestItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialRequestItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MaterialRequestItems
     * const materialRequestItems = await prisma.materialRequestItem.findMany()
     * 
     * // Get first 10 MaterialRequestItems
     * const materialRequestItems = await prisma.materialRequestItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const materialRequestItemWithIdOnly = await prisma.materialRequestItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MaterialRequestItemFindManyArgs>(args?: SelectSubset<T, MaterialRequestItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialRequestItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MaterialRequestItem.
     * @param {MaterialRequestItemCreateArgs} args - Arguments to create a MaterialRequestItem.
     * @example
     * // Create one MaterialRequestItem
     * const MaterialRequestItem = await prisma.materialRequestItem.create({
     *   data: {
     *     // ... data to create a MaterialRequestItem
     *   }
     * })
     * 
     */
    create<T extends MaterialRequestItemCreateArgs>(args: SelectSubset<T, MaterialRequestItemCreateArgs<ExtArgs>>): Prisma__MaterialRequestItemClient<$Result.GetResult<Prisma.$MaterialRequestItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MaterialRequestItems.
     * @param {MaterialRequestItemCreateManyArgs} args - Arguments to create many MaterialRequestItems.
     * @example
     * // Create many MaterialRequestItems
     * const materialRequestItem = await prisma.materialRequestItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MaterialRequestItemCreateManyArgs>(args?: SelectSubset<T, MaterialRequestItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MaterialRequestItem.
     * @param {MaterialRequestItemDeleteArgs} args - Arguments to delete one MaterialRequestItem.
     * @example
     * // Delete one MaterialRequestItem
     * const MaterialRequestItem = await prisma.materialRequestItem.delete({
     *   where: {
     *     // ... filter to delete one MaterialRequestItem
     *   }
     * })
     * 
     */
    delete<T extends MaterialRequestItemDeleteArgs>(args: SelectSubset<T, MaterialRequestItemDeleteArgs<ExtArgs>>): Prisma__MaterialRequestItemClient<$Result.GetResult<Prisma.$MaterialRequestItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MaterialRequestItem.
     * @param {MaterialRequestItemUpdateArgs} args - Arguments to update one MaterialRequestItem.
     * @example
     * // Update one MaterialRequestItem
     * const materialRequestItem = await prisma.materialRequestItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MaterialRequestItemUpdateArgs>(args: SelectSubset<T, MaterialRequestItemUpdateArgs<ExtArgs>>): Prisma__MaterialRequestItemClient<$Result.GetResult<Prisma.$MaterialRequestItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MaterialRequestItems.
     * @param {MaterialRequestItemDeleteManyArgs} args - Arguments to filter MaterialRequestItems to delete.
     * @example
     * // Delete a few MaterialRequestItems
     * const { count } = await prisma.materialRequestItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MaterialRequestItemDeleteManyArgs>(args?: SelectSubset<T, MaterialRequestItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MaterialRequestItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialRequestItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MaterialRequestItems
     * const materialRequestItem = await prisma.materialRequestItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MaterialRequestItemUpdateManyArgs>(args: SelectSubset<T, MaterialRequestItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MaterialRequestItem.
     * @param {MaterialRequestItemUpsertArgs} args - Arguments to update or create a MaterialRequestItem.
     * @example
     * // Update or create a MaterialRequestItem
     * const materialRequestItem = await prisma.materialRequestItem.upsert({
     *   create: {
     *     // ... data to create a MaterialRequestItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MaterialRequestItem we want to update
     *   }
     * })
     */
    upsert<T extends MaterialRequestItemUpsertArgs>(args: SelectSubset<T, MaterialRequestItemUpsertArgs<ExtArgs>>): Prisma__MaterialRequestItemClient<$Result.GetResult<Prisma.$MaterialRequestItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MaterialRequestItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialRequestItemCountArgs} args - Arguments to filter MaterialRequestItems to count.
     * @example
     * // Count the number of MaterialRequestItems
     * const count = await prisma.materialRequestItem.count({
     *   where: {
     *     // ... the filter for the MaterialRequestItems we want to count
     *   }
     * })
    **/
    count<T extends MaterialRequestItemCountArgs>(
      args?: Subset<T, MaterialRequestItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MaterialRequestItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MaterialRequestItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialRequestItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MaterialRequestItemAggregateArgs>(args: Subset<T, MaterialRequestItemAggregateArgs>): Prisma.PrismaPromise<GetMaterialRequestItemAggregateType<T>>

    /**
     * Group by MaterialRequestItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialRequestItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MaterialRequestItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MaterialRequestItemGroupByArgs['orderBy'] }
        : { orderBy?: MaterialRequestItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MaterialRequestItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMaterialRequestItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MaterialRequestItem model
   */
  readonly fields: MaterialRequestItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MaterialRequestItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MaterialRequestItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    materialRequest<T extends MaterialRequestDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MaterialRequestDefaultArgs<ExtArgs>>): Prisma__MaterialRequestClient<$Result.GetResult<Prisma.$MaterialRequestPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MaterialRequestItem model
   */ 
  interface MaterialRequestItemFieldRefs {
    readonly id: FieldRef<"MaterialRequestItem", 'Int'>
    readonly materialRequestId: FieldRef<"MaterialRequestItem", 'Int'>
    readonly itemDescription: FieldRef<"MaterialRequestItem", 'String'>
    readonly description: FieldRef<"MaterialRequestItem", 'String'>
    readonly quantity: FieldRef<"MaterialRequestItem", 'Decimal'>
    readonly materialUnitPrice: FieldRef<"MaterialRequestItem", 'Decimal'>
    readonly laborUnitPrice: FieldRef<"MaterialRequestItem", 'Decimal'>
    readonly unit: FieldRef<"MaterialRequestItem", 'String'>
  }
    

  // Custom InputTypes
  /**
   * MaterialRequestItem findUnique
   */
  export type MaterialRequestItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialRequestItem
     */
    select?: MaterialRequestItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialRequestItemInclude<ExtArgs> | null
    /**
     * Filter, which MaterialRequestItem to fetch.
     */
    where: MaterialRequestItemWhereUniqueInput
  }

  /**
   * MaterialRequestItem findUniqueOrThrow
   */
  export type MaterialRequestItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialRequestItem
     */
    select?: MaterialRequestItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialRequestItemInclude<ExtArgs> | null
    /**
     * Filter, which MaterialRequestItem to fetch.
     */
    where: MaterialRequestItemWhereUniqueInput
  }

  /**
   * MaterialRequestItem findFirst
   */
  export type MaterialRequestItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialRequestItem
     */
    select?: MaterialRequestItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialRequestItemInclude<ExtArgs> | null
    /**
     * Filter, which MaterialRequestItem to fetch.
     */
    where?: MaterialRequestItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaterialRequestItems to fetch.
     */
    orderBy?: MaterialRequestItemOrderByWithRelationInput | MaterialRequestItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MaterialRequestItems.
     */
    cursor?: MaterialRequestItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaterialRequestItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaterialRequestItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MaterialRequestItems.
     */
    distinct?: MaterialRequestItemScalarFieldEnum | MaterialRequestItemScalarFieldEnum[]
  }

  /**
   * MaterialRequestItem findFirstOrThrow
   */
  export type MaterialRequestItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialRequestItem
     */
    select?: MaterialRequestItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialRequestItemInclude<ExtArgs> | null
    /**
     * Filter, which MaterialRequestItem to fetch.
     */
    where?: MaterialRequestItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaterialRequestItems to fetch.
     */
    orderBy?: MaterialRequestItemOrderByWithRelationInput | MaterialRequestItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MaterialRequestItems.
     */
    cursor?: MaterialRequestItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaterialRequestItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaterialRequestItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MaterialRequestItems.
     */
    distinct?: MaterialRequestItemScalarFieldEnum | MaterialRequestItemScalarFieldEnum[]
  }

  /**
   * MaterialRequestItem findMany
   */
  export type MaterialRequestItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialRequestItem
     */
    select?: MaterialRequestItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialRequestItemInclude<ExtArgs> | null
    /**
     * Filter, which MaterialRequestItems to fetch.
     */
    where?: MaterialRequestItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaterialRequestItems to fetch.
     */
    orderBy?: MaterialRequestItemOrderByWithRelationInput | MaterialRequestItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MaterialRequestItems.
     */
    cursor?: MaterialRequestItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaterialRequestItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaterialRequestItems.
     */
    skip?: number
    distinct?: MaterialRequestItemScalarFieldEnum | MaterialRequestItemScalarFieldEnum[]
  }

  /**
   * MaterialRequestItem create
   */
  export type MaterialRequestItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialRequestItem
     */
    select?: MaterialRequestItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialRequestItemInclude<ExtArgs> | null
    /**
     * The data needed to create a MaterialRequestItem.
     */
    data: XOR<MaterialRequestItemCreateInput, MaterialRequestItemUncheckedCreateInput>
  }

  /**
   * MaterialRequestItem createMany
   */
  export type MaterialRequestItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MaterialRequestItems.
     */
    data: MaterialRequestItemCreateManyInput | MaterialRequestItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MaterialRequestItem update
   */
  export type MaterialRequestItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialRequestItem
     */
    select?: MaterialRequestItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialRequestItemInclude<ExtArgs> | null
    /**
     * The data needed to update a MaterialRequestItem.
     */
    data: XOR<MaterialRequestItemUpdateInput, MaterialRequestItemUncheckedUpdateInput>
    /**
     * Choose, which MaterialRequestItem to update.
     */
    where: MaterialRequestItemWhereUniqueInput
  }

  /**
   * MaterialRequestItem updateMany
   */
  export type MaterialRequestItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MaterialRequestItems.
     */
    data: XOR<MaterialRequestItemUpdateManyMutationInput, MaterialRequestItemUncheckedUpdateManyInput>
    /**
     * Filter which MaterialRequestItems to update
     */
    where?: MaterialRequestItemWhereInput
  }

  /**
   * MaterialRequestItem upsert
   */
  export type MaterialRequestItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialRequestItem
     */
    select?: MaterialRequestItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialRequestItemInclude<ExtArgs> | null
    /**
     * The filter to search for the MaterialRequestItem to update in case it exists.
     */
    where: MaterialRequestItemWhereUniqueInput
    /**
     * In case the MaterialRequestItem found by the `where` argument doesn't exist, create a new MaterialRequestItem with this data.
     */
    create: XOR<MaterialRequestItemCreateInput, MaterialRequestItemUncheckedCreateInput>
    /**
     * In case the MaterialRequestItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MaterialRequestItemUpdateInput, MaterialRequestItemUncheckedUpdateInput>
  }

  /**
   * MaterialRequestItem delete
   */
  export type MaterialRequestItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialRequestItem
     */
    select?: MaterialRequestItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialRequestItemInclude<ExtArgs> | null
    /**
     * Filter which MaterialRequestItem to delete.
     */
    where: MaterialRequestItemWhereUniqueInput
  }

  /**
   * MaterialRequestItem deleteMany
   */
  export type MaterialRequestItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MaterialRequestItems to delete
     */
    where?: MaterialRequestItemWhereInput
  }

  /**
   * MaterialRequestItem without action
   */
  export type MaterialRequestItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialRequestItem
     */
    select?: MaterialRequestItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialRequestItemInclude<ExtArgs> | null
  }


  /**
   * Model RFQ
   */

  export type AggregateRFQ = {
    _count: RFQCountAggregateOutputType | null
    _avg: RFQAvgAggregateOutputType | null
    _sum: RFQSumAggregateOutputType | null
    _min: RFQMinAggregateOutputType | null
    _max: RFQMaxAggregateOutputType | null
  }

  export type RFQAvgAggregateOutputType = {
    id: number | null
    mrId: number | null
    createdById: number | null
  }

  export type RFQSumAggregateOutputType = {
    id: number | null
    mrId: number | null
    createdById: number | null
  }

  export type RFQMinAggregateOutputType = {
    id: number | null
    mrId: number | null
    createdById: number | null
    title: string | null
    status: $Enums.RfqStatus | null
    dueDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RFQMaxAggregateOutputType = {
    id: number | null
    mrId: number | null
    createdById: number | null
    title: string | null
    status: $Enums.RfqStatus | null
    dueDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RFQCountAggregateOutputType = {
    id: number
    mrId: number
    createdById: number
    title: number
    status: number
    dueDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RFQAvgAggregateInputType = {
    id?: true
    mrId?: true
    createdById?: true
  }

  export type RFQSumAggregateInputType = {
    id?: true
    mrId?: true
    createdById?: true
  }

  export type RFQMinAggregateInputType = {
    id?: true
    mrId?: true
    createdById?: true
    title?: true
    status?: true
    dueDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RFQMaxAggregateInputType = {
    id?: true
    mrId?: true
    createdById?: true
    title?: true
    status?: true
    dueDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RFQCountAggregateInputType = {
    id?: true
    mrId?: true
    createdById?: true
    title?: true
    status?: true
    dueDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RFQAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RFQ to aggregate.
     */
    where?: RFQWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RFQS to fetch.
     */
    orderBy?: RFQOrderByWithRelationInput | RFQOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RFQWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RFQS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RFQS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RFQS
    **/
    _count?: true | RFQCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RFQAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RFQSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RFQMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RFQMaxAggregateInputType
  }

  export type GetRFQAggregateType<T extends RFQAggregateArgs> = {
        [P in keyof T & keyof AggregateRFQ]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRFQ[P]>
      : GetScalarType<T[P], AggregateRFQ[P]>
  }




  export type RFQGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RFQWhereInput
    orderBy?: RFQOrderByWithAggregationInput | RFQOrderByWithAggregationInput[]
    by: RFQScalarFieldEnum[] | RFQScalarFieldEnum
    having?: RFQScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RFQCountAggregateInputType | true
    _avg?: RFQAvgAggregateInputType
    _sum?: RFQSumAggregateInputType
    _min?: RFQMinAggregateInputType
    _max?: RFQMaxAggregateInputType
  }

  export type RFQGroupByOutputType = {
    id: number
    mrId: number | null
    createdById: number
    title: string
    status: $Enums.RfqStatus
    dueDate: Date | null
    createdAt: Date
    updatedAt: Date
    _count: RFQCountAggregateOutputType | null
    _avg: RFQAvgAggregateOutputType | null
    _sum: RFQSumAggregateOutputType | null
    _min: RFQMinAggregateOutputType | null
    _max: RFQMaxAggregateOutputType | null
  }

  type GetRFQGroupByPayload<T extends RFQGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RFQGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RFQGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RFQGroupByOutputType[P]>
            : GetScalarType<T[P], RFQGroupByOutputType[P]>
        }
      >
    >


  export type RFQSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mrId?: boolean
    createdById?: boolean
    title?: boolean
    status?: boolean
    dueDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    materialRequest?: boolean | RFQ$materialRequestArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    items?: boolean | RFQ$itemsArgs<ExtArgs>
    quotations?: boolean | RFQ$quotationsArgs<ExtArgs>
    _count?: boolean | RFQCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rFQ"]>


  export type RFQSelectScalar = {
    id?: boolean
    mrId?: boolean
    createdById?: boolean
    title?: boolean
    status?: boolean
    dueDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RFQInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    materialRequest?: boolean | RFQ$materialRequestArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    items?: boolean | RFQ$itemsArgs<ExtArgs>
    quotations?: boolean | RFQ$quotationsArgs<ExtArgs>
    _count?: boolean | RFQCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $RFQPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RFQ"
    objects: {
      materialRequest: Prisma.$MaterialRequestPayload<ExtArgs> | null
      createdBy: Prisma.$UserPayload<ExtArgs>
      items: Prisma.$RFQItemPayload<ExtArgs>[]
      quotations: Prisma.$SupplierQuotationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      mrId: number | null
      createdById: number
      title: string
      status: $Enums.RfqStatus
      dueDate: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["rFQ"]>
    composites: {}
  }

  type RFQGetPayload<S extends boolean | null | undefined | RFQDefaultArgs> = $Result.GetResult<Prisma.$RFQPayload, S>

  type RFQCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RFQFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RFQCountAggregateInputType | true
    }

  export interface RFQDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RFQ'], meta: { name: 'RFQ' } }
    /**
     * Find zero or one RFQ that matches the filter.
     * @param {RFQFindUniqueArgs} args - Arguments to find a RFQ
     * @example
     * // Get one RFQ
     * const rFQ = await prisma.rFQ.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RFQFindUniqueArgs>(args: SelectSubset<T, RFQFindUniqueArgs<ExtArgs>>): Prisma__RFQClient<$Result.GetResult<Prisma.$RFQPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RFQ that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RFQFindUniqueOrThrowArgs} args - Arguments to find a RFQ
     * @example
     * // Get one RFQ
     * const rFQ = await prisma.rFQ.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RFQFindUniqueOrThrowArgs>(args: SelectSubset<T, RFQFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RFQClient<$Result.GetResult<Prisma.$RFQPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RFQ that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RFQFindFirstArgs} args - Arguments to find a RFQ
     * @example
     * // Get one RFQ
     * const rFQ = await prisma.rFQ.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RFQFindFirstArgs>(args?: SelectSubset<T, RFQFindFirstArgs<ExtArgs>>): Prisma__RFQClient<$Result.GetResult<Prisma.$RFQPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RFQ that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RFQFindFirstOrThrowArgs} args - Arguments to find a RFQ
     * @example
     * // Get one RFQ
     * const rFQ = await prisma.rFQ.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RFQFindFirstOrThrowArgs>(args?: SelectSubset<T, RFQFindFirstOrThrowArgs<ExtArgs>>): Prisma__RFQClient<$Result.GetResult<Prisma.$RFQPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RFQS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RFQFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RFQS
     * const rFQS = await prisma.rFQ.findMany()
     * 
     * // Get first 10 RFQS
     * const rFQS = await prisma.rFQ.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rFQWithIdOnly = await prisma.rFQ.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RFQFindManyArgs>(args?: SelectSubset<T, RFQFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RFQPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RFQ.
     * @param {RFQCreateArgs} args - Arguments to create a RFQ.
     * @example
     * // Create one RFQ
     * const RFQ = await prisma.rFQ.create({
     *   data: {
     *     // ... data to create a RFQ
     *   }
     * })
     * 
     */
    create<T extends RFQCreateArgs>(args: SelectSubset<T, RFQCreateArgs<ExtArgs>>): Prisma__RFQClient<$Result.GetResult<Prisma.$RFQPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RFQS.
     * @param {RFQCreateManyArgs} args - Arguments to create many RFQS.
     * @example
     * // Create many RFQS
     * const rFQ = await prisma.rFQ.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RFQCreateManyArgs>(args?: SelectSubset<T, RFQCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RFQ.
     * @param {RFQDeleteArgs} args - Arguments to delete one RFQ.
     * @example
     * // Delete one RFQ
     * const RFQ = await prisma.rFQ.delete({
     *   where: {
     *     // ... filter to delete one RFQ
     *   }
     * })
     * 
     */
    delete<T extends RFQDeleteArgs>(args: SelectSubset<T, RFQDeleteArgs<ExtArgs>>): Prisma__RFQClient<$Result.GetResult<Prisma.$RFQPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RFQ.
     * @param {RFQUpdateArgs} args - Arguments to update one RFQ.
     * @example
     * // Update one RFQ
     * const rFQ = await prisma.rFQ.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RFQUpdateArgs>(args: SelectSubset<T, RFQUpdateArgs<ExtArgs>>): Prisma__RFQClient<$Result.GetResult<Prisma.$RFQPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RFQS.
     * @param {RFQDeleteManyArgs} args - Arguments to filter RFQS to delete.
     * @example
     * // Delete a few RFQS
     * const { count } = await prisma.rFQ.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RFQDeleteManyArgs>(args?: SelectSubset<T, RFQDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RFQS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RFQUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RFQS
     * const rFQ = await prisma.rFQ.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RFQUpdateManyArgs>(args: SelectSubset<T, RFQUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RFQ.
     * @param {RFQUpsertArgs} args - Arguments to update or create a RFQ.
     * @example
     * // Update or create a RFQ
     * const rFQ = await prisma.rFQ.upsert({
     *   create: {
     *     // ... data to create a RFQ
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RFQ we want to update
     *   }
     * })
     */
    upsert<T extends RFQUpsertArgs>(args: SelectSubset<T, RFQUpsertArgs<ExtArgs>>): Prisma__RFQClient<$Result.GetResult<Prisma.$RFQPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RFQS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RFQCountArgs} args - Arguments to filter RFQS to count.
     * @example
     * // Count the number of RFQS
     * const count = await prisma.rFQ.count({
     *   where: {
     *     // ... the filter for the RFQS we want to count
     *   }
     * })
    **/
    count<T extends RFQCountArgs>(
      args?: Subset<T, RFQCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RFQCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RFQ.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RFQAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RFQAggregateArgs>(args: Subset<T, RFQAggregateArgs>): Prisma.PrismaPromise<GetRFQAggregateType<T>>

    /**
     * Group by RFQ.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RFQGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RFQGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RFQGroupByArgs['orderBy'] }
        : { orderBy?: RFQGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RFQGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRFQGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RFQ model
   */
  readonly fields: RFQFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RFQ.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RFQClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    materialRequest<T extends RFQ$materialRequestArgs<ExtArgs> = {}>(args?: Subset<T, RFQ$materialRequestArgs<ExtArgs>>): Prisma__MaterialRequestClient<$Result.GetResult<Prisma.$MaterialRequestPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    items<T extends RFQ$itemsArgs<ExtArgs> = {}>(args?: Subset<T, RFQ$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RFQItemPayload<ExtArgs>, T, "findMany"> | Null>
    quotations<T extends RFQ$quotationsArgs<ExtArgs> = {}>(args?: Subset<T, RFQ$quotationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierQuotationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RFQ model
   */ 
  interface RFQFieldRefs {
    readonly id: FieldRef<"RFQ", 'Int'>
    readonly mrId: FieldRef<"RFQ", 'Int'>
    readonly createdById: FieldRef<"RFQ", 'Int'>
    readonly title: FieldRef<"RFQ", 'String'>
    readonly status: FieldRef<"RFQ", 'RfqStatus'>
    readonly dueDate: FieldRef<"RFQ", 'DateTime'>
    readonly createdAt: FieldRef<"RFQ", 'DateTime'>
    readonly updatedAt: FieldRef<"RFQ", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RFQ findUnique
   */
  export type RFQFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RFQ
     */
    select?: RFQSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RFQInclude<ExtArgs> | null
    /**
     * Filter, which RFQ to fetch.
     */
    where: RFQWhereUniqueInput
  }

  /**
   * RFQ findUniqueOrThrow
   */
  export type RFQFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RFQ
     */
    select?: RFQSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RFQInclude<ExtArgs> | null
    /**
     * Filter, which RFQ to fetch.
     */
    where: RFQWhereUniqueInput
  }

  /**
   * RFQ findFirst
   */
  export type RFQFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RFQ
     */
    select?: RFQSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RFQInclude<ExtArgs> | null
    /**
     * Filter, which RFQ to fetch.
     */
    where?: RFQWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RFQS to fetch.
     */
    orderBy?: RFQOrderByWithRelationInput | RFQOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RFQS.
     */
    cursor?: RFQWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RFQS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RFQS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RFQS.
     */
    distinct?: RFQScalarFieldEnum | RFQScalarFieldEnum[]
  }

  /**
   * RFQ findFirstOrThrow
   */
  export type RFQFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RFQ
     */
    select?: RFQSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RFQInclude<ExtArgs> | null
    /**
     * Filter, which RFQ to fetch.
     */
    where?: RFQWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RFQS to fetch.
     */
    orderBy?: RFQOrderByWithRelationInput | RFQOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RFQS.
     */
    cursor?: RFQWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RFQS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RFQS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RFQS.
     */
    distinct?: RFQScalarFieldEnum | RFQScalarFieldEnum[]
  }

  /**
   * RFQ findMany
   */
  export type RFQFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RFQ
     */
    select?: RFQSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RFQInclude<ExtArgs> | null
    /**
     * Filter, which RFQS to fetch.
     */
    where?: RFQWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RFQS to fetch.
     */
    orderBy?: RFQOrderByWithRelationInput | RFQOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RFQS.
     */
    cursor?: RFQWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RFQS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RFQS.
     */
    skip?: number
    distinct?: RFQScalarFieldEnum | RFQScalarFieldEnum[]
  }

  /**
   * RFQ create
   */
  export type RFQCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RFQ
     */
    select?: RFQSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RFQInclude<ExtArgs> | null
    /**
     * The data needed to create a RFQ.
     */
    data: XOR<RFQCreateInput, RFQUncheckedCreateInput>
  }

  /**
   * RFQ createMany
   */
  export type RFQCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RFQS.
     */
    data: RFQCreateManyInput | RFQCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RFQ update
   */
  export type RFQUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RFQ
     */
    select?: RFQSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RFQInclude<ExtArgs> | null
    /**
     * The data needed to update a RFQ.
     */
    data: XOR<RFQUpdateInput, RFQUncheckedUpdateInput>
    /**
     * Choose, which RFQ to update.
     */
    where: RFQWhereUniqueInput
  }

  /**
   * RFQ updateMany
   */
  export type RFQUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RFQS.
     */
    data: XOR<RFQUpdateManyMutationInput, RFQUncheckedUpdateManyInput>
    /**
     * Filter which RFQS to update
     */
    where?: RFQWhereInput
  }

  /**
   * RFQ upsert
   */
  export type RFQUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RFQ
     */
    select?: RFQSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RFQInclude<ExtArgs> | null
    /**
     * The filter to search for the RFQ to update in case it exists.
     */
    where: RFQWhereUniqueInput
    /**
     * In case the RFQ found by the `where` argument doesn't exist, create a new RFQ with this data.
     */
    create: XOR<RFQCreateInput, RFQUncheckedCreateInput>
    /**
     * In case the RFQ was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RFQUpdateInput, RFQUncheckedUpdateInput>
  }

  /**
   * RFQ delete
   */
  export type RFQDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RFQ
     */
    select?: RFQSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RFQInclude<ExtArgs> | null
    /**
     * Filter which RFQ to delete.
     */
    where: RFQWhereUniqueInput
  }

  /**
   * RFQ deleteMany
   */
  export type RFQDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RFQS to delete
     */
    where?: RFQWhereInput
  }

  /**
   * RFQ.materialRequest
   */
  export type RFQ$materialRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialRequest
     */
    select?: MaterialRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialRequestInclude<ExtArgs> | null
    where?: MaterialRequestWhereInput
  }

  /**
   * RFQ.items
   */
  export type RFQ$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RFQItem
     */
    select?: RFQItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RFQItemInclude<ExtArgs> | null
    where?: RFQItemWhereInput
    orderBy?: RFQItemOrderByWithRelationInput | RFQItemOrderByWithRelationInput[]
    cursor?: RFQItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RFQItemScalarFieldEnum | RFQItemScalarFieldEnum[]
  }

  /**
   * RFQ.quotations
   */
  export type RFQ$quotationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierQuotation
     */
    select?: SupplierQuotationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierQuotationInclude<ExtArgs> | null
    where?: SupplierQuotationWhereInput
    orderBy?: SupplierQuotationOrderByWithRelationInput | SupplierQuotationOrderByWithRelationInput[]
    cursor?: SupplierQuotationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SupplierQuotationScalarFieldEnum | SupplierQuotationScalarFieldEnum[]
  }

  /**
   * RFQ without action
   */
  export type RFQDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RFQ
     */
    select?: RFQSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RFQInclude<ExtArgs> | null
  }


  /**
   * Model RFQItem
   */

  export type AggregateRFQItem = {
    _count: RFQItemCountAggregateOutputType | null
    _avg: RFQItemAvgAggregateOutputType | null
    _sum: RFQItemSumAggregateOutputType | null
    _min: RFQItemMinAggregateOutputType | null
    _max: RFQItemMaxAggregateOutputType | null
  }

  export type RFQItemAvgAggregateOutputType = {
    id: number | null
    rfqId: number | null
    quantity: Decimal | null
  }

  export type RFQItemSumAggregateOutputType = {
    id: number | null
    rfqId: number | null
    quantity: Decimal | null
  }

  export type RFQItemMinAggregateOutputType = {
    id: number | null
    rfqId: number | null
    materialName: string | null
    quantity: Decimal | null
    unit: string | null
  }

  export type RFQItemMaxAggregateOutputType = {
    id: number | null
    rfqId: number | null
    materialName: string | null
    quantity: Decimal | null
    unit: string | null
  }

  export type RFQItemCountAggregateOutputType = {
    id: number
    rfqId: number
    materialName: number
    quantity: number
    unit: number
    _all: number
  }


  export type RFQItemAvgAggregateInputType = {
    id?: true
    rfqId?: true
    quantity?: true
  }

  export type RFQItemSumAggregateInputType = {
    id?: true
    rfqId?: true
    quantity?: true
  }

  export type RFQItemMinAggregateInputType = {
    id?: true
    rfqId?: true
    materialName?: true
    quantity?: true
    unit?: true
  }

  export type RFQItemMaxAggregateInputType = {
    id?: true
    rfqId?: true
    materialName?: true
    quantity?: true
    unit?: true
  }

  export type RFQItemCountAggregateInputType = {
    id?: true
    rfqId?: true
    materialName?: true
    quantity?: true
    unit?: true
    _all?: true
  }

  export type RFQItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RFQItem to aggregate.
     */
    where?: RFQItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RFQItems to fetch.
     */
    orderBy?: RFQItemOrderByWithRelationInput | RFQItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RFQItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RFQItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RFQItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RFQItems
    **/
    _count?: true | RFQItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RFQItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RFQItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RFQItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RFQItemMaxAggregateInputType
  }

  export type GetRFQItemAggregateType<T extends RFQItemAggregateArgs> = {
        [P in keyof T & keyof AggregateRFQItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRFQItem[P]>
      : GetScalarType<T[P], AggregateRFQItem[P]>
  }




  export type RFQItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RFQItemWhereInput
    orderBy?: RFQItemOrderByWithAggregationInput | RFQItemOrderByWithAggregationInput[]
    by: RFQItemScalarFieldEnum[] | RFQItemScalarFieldEnum
    having?: RFQItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RFQItemCountAggregateInputType | true
    _avg?: RFQItemAvgAggregateInputType
    _sum?: RFQItemSumAggregateInputType
    _min?: RFQItemMinAggregateInputType
    _max?: RFQItemMaxAggregateInputType
  }

  export type RFQItemGroupByOutputType = {
    id: number
    rfqId: number
    materialName: string
    quantity: Decimal
    unit: string
    _count: RFQItemCountAggregateOutputType | null
    _avg: RFQItemAvgAggregateOutputType | null
    _sum: RFQItemSumAggregateOutputType | null
    _min: RFQItemMinAggregateOutputType | null
    _max: RFQItemMaxAggregateOutputType | null
  }

  type GetRFQItemGroupByPayload<T extends RFQItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RFQItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RFQItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RFQItemGroupByOutputType[P]>
            : GetScalarType<T[P], RFQItemGroupByOutputType[P]>
        }
      >
    >


  export type RFQItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rfqId?: boolean
    materialName?: boolean
    quantity?: boolean
    unit?: boolean
    rfq?: boolean | RFQDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rFQItem"]>


  export type RFQItemSelectScalar = {
    id?: boolean
    rfqId?: boolean
    materialName?: boolean
    quantity?: boolean
    unit?: boolean
  }

  export type RFQItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rfq?: boolean | RFQDefaultArgs<ExtArgs>
  }

  export type $RFQItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RFQItem"
    objects: {
      rfq: Prisma.$RFQPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      rfqId: number
      materialName: string
      quantity: Prisma.Decimal
      unit: string
    }, ExtArgs["result"]["rFQItem"]>
    composites: {}
  }

  type RFQItemGetPayload<S extends boolean | null | undefined | RFQItemDefaultArgs> = $Result.GetResult<Prisma.$RFQItemPayload, S>

  type RFQItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RFQItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RFQItemCountAggregateInputType | true
    }

  export interface RFQItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RFQItem'], meta: { name: 'RFQItem' } }
    /**
     * Find zero or one RFQItem that matches the filter.
     * @param {RFQItemFindUniqueArgs} args - Arguments to find a RFQItem
     * @example
     * // Get one RFQItem
     * const rFQItem = await prisma.rFQItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RFQItemFindUniqueArgs>(args: SelectSubset<T, RFQItemFindUniqueArgs<ExtArgs>>): Prisma__RFQItemClient<$Result.GetResult<Prisma.$RFQItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RFQItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RFQItemFindUniqueOrThrowArgs} args - Arguments to find a RFQItem
     * @example
     * // Get one RFQItem
     * const rFQItem = await prisma.rFQItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RFQItemFindUniqueOrThrowArgs>(args: SelectSubset<T, RFQItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RFQItemClient<$Result.GetResult<Prisma.$RFQItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RFQItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RFQItemFindFirstArgs} args - Arguments to find a RFQItem
     * @example
     * // Get one RFQItem
     * const rFQItem = await prisma.rFQItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RFQItemFindFirstArgs>(args?: SelectSubset<T, RFQItemFindFirstArgs<ExtArgs>>): Prisma__RFQItemClient<$Result.GetResult<Prisma.$RFQItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RFQItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RFQItemFindFirstOrThrowArgs} args - Arguments to find a RFQItem
     * @example
     * // Get one RFQItem
     * const rFQItem = await prisma.rFQItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RFQItemFindFirstOrThrowArgs>(args?: SelectSubset<T, RFQItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__RFQItemClient<$Result.GetResult<Prisma.$RFQItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RFQItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RFQItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RFQItems
     * const rFQItems = await prisma.rFQItem.findMany()
     * 
     * // Get first 10 RFQItems
     * const rFQItems = await prisma.rFQItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rFQItemWithIdOnly = await prisma.rFQItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RFQItemFindManyArgs>(args?: SelectSubset<T, RFQItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RFQItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RFQItem.
     * @param {RFQItemCreateArgs} args - Arguments to create a RFQItem.
     * @example
     * // Create one RFQItem
     * const RFQItem = await prisma.rFQItem.create({
     *   data: {
     *     // ... data to create a RFQItem
     *   }
     * })
     * 
     */
    create<T extends RFQItemCreateArgs>(args: SelectSubset<T, RFQItemCreateArgs<ExtArgs>>): Prisma__RFQItemClient<$Result.GetResult<Prisma.$RFQItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RFQItems.
     * @param {RFQItemCreateManyArgs} args - Arguments to create many RFQItems.
     * @example
     * // Create many RFQItems
     * const rFQItem = await prisma.rFQItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RFQItemCreateManyArgs>(args?: SelectSubset<T, RFQItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RFQItem.
     * @param {RFQItemDeleteArgs} args - Arguments to delete one RFQItem.
     * @example
     * // Delete one RFQItem
     * const RFQItem = await prisma.rFQItem.delete({
     *   where: {
     *     // ... filter to delete one RFQItem
     *   }
     * })
     * 
     */
    delete<T extends RFQItemDeleteArgs>(args: SelectSubset<T, RFQItemDeleteArgs<ExtArgs>>): Prisma__RFQItemClient<$Result.GetResult<Prisma.$RFQItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RFQItem.
     * @param {RFQItemUpdateArgs} args - Arguments to update one RFQItem.
     * @example
     * // Update one RFQItem
     * const rFQItem = await prisma.rFQItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RFQItemUpdateArgs>(args: SelectSubset<T, RFQItemUpdateArgs<ExtArgs>>): Prisma__RFQItemClient<$Result.GetResult<Prisma.$RFQItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RFQItems.
     * @param {RFQItemDeleteManyArgs} args - Arguments to filter RFQItems to delete.
     * @example
     * // Delete a few RFQItems
     * const { count } = await prisma.rFQItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RFQItemDeleteManyArgs>(args?: SelectSubset<T, RFQItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RFQItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RFQItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RFQItems
     * const rFQItem = await prisma.rFQItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RFQItemUpdateManyArgs>(args: SelectSubset<T, RFQItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RFQItem.
     * @param {RFQItemUpsertArgs} args - Arguments to update or create a RFQItem.
     * @example
     * // Update or create a RFQItem
     * const rFQItem = await prisma.rFQItem.upsert({
     *   create: {
     *     // ... data to create a RFQItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RFQItem we want to update
     *   }
     * })
     */
    upsert<T extends RFQItemUpsertArgs>(args: SelectSubset<T, RFQItemUpsertArgs<ExtArgs>>): Prisma__RFQItemClient<$Result.GetResult<Prisma.$RFQItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RFQItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RFQItemCountArgs} args - Arguments to filter RFQItems to count.
     * @example
     * // Count the number of RFQItems
     * const count = await prisma.rFQItem.count({
     *   where: {
     *     // ... the filter for the RFQItems we want to count
     *   }
     * })
    **/
    count<T extends RFQItemCountArgs>(
      args?: Subset<T, RFQItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RFQItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RFQItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RFQItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RFQItemAggregateArgs>(args: Subset<T, RFQItemAggregateArgs>): Prisma.PrismaPromise<GetRFQItemAggregateType<T>>

    /**
     * Group by RFQItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RFQItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RFQItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RFQItemGroupByArgs['orderBy'] }
        : { orderBy?: RFQItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RFQItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRFQItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RFQItem model
   */
  readonly fields: RFQItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RFQItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RFQItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    rfq<T extends RFQDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RFQDefaultArgs<ExtArgs>>): Prisma__RFQClient<$Result.GetResult<Prisma.$RFQPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RFQItem model
   */ 
  interface RFQItemFieldRefs {
    readonly id: FieldRef<"RFQItem", 'Int'>
    readonly rfqId: FieldRef<"RFQItem", 'Int'>
    readonly materialName: FieldRef<"RFQItem", 'String'>
    readonly quantity: FieldRef<"RFQItem", 'Decimal'>
    readonly unit: FieldRef<"RFQItem", 'String'>
  }
    

  // Custom InputTypes
  /**
   * RFQItem findUnique
   */
  export type RFQItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RFQItem
     */
    select?: RFQItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RFQItemInclude<ExtArgs> | null
    /**
     * Filter, which RFQItem to fetch.
     */
    where: RFQItemWhereUniqueInput
  }

  /**
   * RFQItem findUniqueOrThrow
   */
  export type RFQItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RFQItem
     */
    select?: RFQItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RFQItemInclude<ExtArgs> | null
    /**
     * Filter, which RFQItem to fetch.
     */
    where: RFQItemWhereUniqueInput
  }

  /**
   * RFQItem findFirst
   */
  export type RFQItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RFQItem
     */
    select?: RFQItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RFQItemInclude<ExtArgs> | null
    /**
     * Filter, which RFQItem to fetch.
     */
    where?: RFQItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RFQItems to fetch.
     */
    orderBy?: RFQItemOrderByWithRelationInput | RFQItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RFQItems.
     */
    cursor?: RFQItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RFQItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RFQItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RFQItems.
     */
    distinct?: RFQItemScalarFieldEnum | RFQItemScalarFieldEnum[]
  }

  /**
   * RFQItem findFirstOrThrow
   */
  export type RFQItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RFQItem
     */
    select?: RFQItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RFQItemInclude<ExtArgs> | null
    /**
     * Filter, which RFQItem to fetch.
     */
    where?: RFQItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RFQItems to fetch.
     */
    orderBy?: RFQItemOrderByWithRelationInput | RFQItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RFQItems.
     */
    cursor?: RFQItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RFQItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RFQItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RFQItems.
     */
    distinct?: RFQItemScalarFieldEnum | RFQItemScalarFieldEnum[]
  }

  /**
   * RFQItem findMany
   */
  export type RFQItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RFQItem
     */
    select?: RFQItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RFQItemInclude<ExtArgs> | null
    /**
     * Filter, which RFQItems to fetch.
     */
    where?: RFQItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RFQItems to fetch.
     */
    orderBy?: RFQItemOrderByWithRelationInput | RFQItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RFQItems.
     */
    cursor?: RFQItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RFQItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RFQItems.
     */
    skip?: number
    distinct?: RFQItemScalarFieldEnum | RFQItemScalarFieldEnum[]
  }

  /**
   * RFQItem create
   */
  export type RFQItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RFQItem
     */
    select?: RFQItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RFQItemInclude<ExtArgs> | null
    /**
     * The data needed to create a RFQItem.
     */
    data: XOR<RFQItemCreateInput, RFQItemUncheckedCreateInput>
  }

  /**
   * RFQItem createMany
   */
  export type RFQItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RFQItems.
     */
    data: RFQItemCreateManyInput | RFQItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RFQItem update
   */
  export type RFQItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RFQItem
     */
    select?: RFQItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RFQItemInclude<ExtArgs> | null
    /**
     * The data needed to update a RFQItem.
     */
    data: XOR<RFQItemUpdateInput, RFQItemUncheckedUpdateInput>
    /**
     * Choose, which RFQItem to update.
     */
    where: RFQItemWhereUniqueInput
  }

  /**
   * RFQItem updateMany
   */
  export type RFQItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RFQItems.
     */
    data: XOR<RFQItemUpdateManyMutationInput, RFQItemUncheckedUpdateManyInput>
    /**
     * Filter which RFQItems to update
     */
    where?: RFQItemWhereInput
  }

  /**
   * RFQItem upsert
   */
  export type RFQItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RFQItem
     */
    select?: RFQItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RFQItemInclude<ExtArgs> | null
    /**
     * The filter to search for the RFQItem to update in case it exists.
     */
    where: RFQItemWhereUniqueInput
    /**
     * In case the RFQItem found by the `where` argument doesn't exist, create a new RFQItem with this data.
     */
    create: XOR<RFQItemCreateInput, RFQItemUncheckedCreateInput>
    /**
     * In case the RFQItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RFQItemUpdateInput, RFQItemUncheckedUpdateInput>
  }

  /**
   * RFQItem delete
   */
  export type RFQItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RFQItem
     */
    select?: RFQItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RFQItemInclude<ExtArgs> | null
    /**
     * Filter which RFQItem to delete.
     */
    where: RFQItemWhereUniqueInput
  }

  /**
   * RFQItem deleteMany
   */
  export type RFQItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RFQItems to delete
     */
    where?: RFQItemWhereInput
  }

  /**
   * RFQItem without action
   */
  export type RFQItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RFQItem
     */
    select?: RFQItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RFQItemInclude<ExtArgs> | null
  }


  /**
   * Model Supplier
   */

  export type AggregateSupplier = {
    _count: SupplierCountAggregateOutputType | null
    _avg: SupplierAvgAggregateOutputType | null
    _sum: SupplierSumAggregateOutputType | null
    _min: SupplierMinAggregateOutputType | null
    _max: SupplierMaxAggregateOutputType | null
  }

  export type SupplierAvgAggregateOutputType = {
    id: number | null
    rating: number | null
  }

  export type SupplierSumAggregateOutputType = {
    id: number | null
    rating: number | null
  }

  export type SupplierMinAggregateOutputType = {
    id: number | null
    name: string | null
    contactPerson: string | null
    email: string | null
    phone: string | null
    address: string | null
    rating: number | null
  }

  export type SupplierMaxAggregateOutputType = {
    id: number | null
    name: string | null
    contactPerson: string | null
    email: string | null
    phone: string | null
    address: string | null
    rating: number | null
  }

  export type SupplierCountAggregateOutputType = {
    id: number
    name: number
    contactPerson: number
    email: number
    phone: number
    address: number
    rating: number
    _all: number
  }


  export type SupplierAvgAggregateInputType = {
    id?: true
    rating?: true
  }

  export type SupplierSumAggregateInputType = {
    id?: true
    rating?: true
  }

  export type SupplierMinAggregateInputType = {
    id?: true
    name?: true
    contactPerson?: true
    email?: true
    phone?: true
    address?: true
    rating?: true
  }

  export type SupplierMaxAggregateInputType = {
    id?: true
    name?: true
    contactPerson?: true
    email?: true
    phone?: true
    address?: true
    rating?: true
  }

  export type SupplierCountAggregateInputType = {
    id?: true
    name?: true
    contactPerson?: true
    email?: true
    phone?: true
    address?: true
    rating?: true
    _all?: true
  }

  export type SupplierAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Supplier to aggregate.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Suppliers
    **/
    _count?: true | SupplierCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SupplierAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SupplierSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SupplierMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SupplierMaxAggregateInputType
  }

  export type GetSupplierAggregateType<T extends SupplierAggregateArgs> = {
        [P in keyof T & keyof AggregateSupplier]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupplier[P]>
      : GetScalarType<T[P], AggregateSupplier[P]>
  }




  export type SupplierGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupplierWhereInput
    orderBy?: SupplierOrderByWithAggregationInput | SupplierOrderByWithAggregationInput[]
    by: SupplierScalarFieldEnum[] | SupplierScalarFieldEnum
    having?: SupplierScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SupplierCountAggregateInputType | true
    _avg?: SupplierAvgAggregateInputType
    _sum?: SupplierSumAggregateInputType
    _min?: SupplierMinAggregateInputType
    _max?: SupplierMaxAggregateInputType
  }

  export type SupplierGroupByOutputType = {
    id: number
    name: string
    contactPerson: string | null
    email: string | null
    phone: string | null
    address: string | null
    rating: number | null
    _count: SupplierCountAggregateOutputType | null
    _avg: SupplierAvgAggregateOutputType | null
    _sum: SupplierSumAggregateOutputType | null
    _min: SupplierMinAggregateOutputType | null
    _max: SupplierMaxAggregateOutputType | null
  }

  type GetSupplierGroupByPayload<T extends SupplierGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SupplierGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SupplierGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SupplierGroupByOutputType[P]>
            : GetScalarType<T[P], SupplierGroupByOutputType[P]>
        }
      >
    >


  export type SupplierSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    contactPerson?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    rating?: boolean
    quotations?: boolean | Supplier$quotationsArgs<ExtArgs>
    purchaseOrders?: boolean | Supplier$purchaseOrdersArgs<ExtArgs>
    invoices?: boolean | Supplier$invoicesArgs<ExtArgs>
    _count?: boolean | SupplierCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supplier"]>


  export type SupplierSelectScalar = {
    id?: boolean
    name?: boolean
    contactPerson?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    rating?: boolean
  }

  export type SupplierInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quotations?: boolean | Supplier$quotationsArgs<ExtArgs>
    purchaseOrders?: boolean | Supplier$purchaseOrdersArgs<ExtArgs>
    invoices?: boolean | Supplier$invoicesArgs<ExtArgs>
    _count?: boolean | SupplierCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $SupplierPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Supplier"
    objects: {
      quotations: Prisma.$SupplierQuotationPayload<ExtArgs>[]
      purchaseOrders: Prisma.$PurchaseOrderPayload<ExtArgs>[]
      invoices: Prisma.$SupplierInvoicePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      contactPerson: string | null
      email: string | null
      phone: string | null
      address: string | null
      rating: number | null
    }, ExtArgs["result"]["supplier"]>
    composites: {}
  }

  type SupplierGetPayload<S extends boolean | null | undefined | SupplierDefaultArgs> = $Result.GetResult<Prisma.$SupplierPayload, S>

  type SupplierCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SupplierFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SupplierCountAggregateInputType | true
    }

  export interface SupplierDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Supplier'], meta: { name: 'Supplier' } }
    /**
     * Find zero or one Supplier that matches the filter.
     * @param {SupplierFindUniqueArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SupplierFindUniqueArgs>(args: SelectSubset<T, SupplierFindUniqueArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Supplier that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SupplierFindUniqueOrThrowArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SupplierFindUniqueOrThrowArgs>(args: SelectSubset<T, SupplierFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Supplier that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierFindFirstArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SupplierFindFirstArgs>(args?: SelectSubset<T, SupplierFindFirstArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Supplier that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierFindFirstOrThrowArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SupplierFindFirstOrThrowArgs>(args?: SelectSubset<T, SupplierFindFirstOrThrowArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Suppliers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Suppliers
     * const suppliers = await prisma.supplier.findMany()
     * 
     * // Get first 10 Suppliers
     * const suppliers = await prisma.supplier.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const supplierWithIdOnly = await prisma.supplier.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SupplierFindManyArgs>(args?: SelectSubset<T, SupplierFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Supplier.
     * @param {SupplierCreateArgs} args - Arguments to create a Supplier.
     * @example
     * // Create one Supplier
     * const Supplier = await prisma.supplier.create({
     *   data: {
     *     // ... data to create a Supplier
     *   }
     * })
     * 
     */
    create<T extends SupplierCreateArgs>(args: SelectSubset<T, SupplierCreateArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Suppliers.
     * @param {SupplierCreateManyArgs} args - Arguments to create many Suppliers.
     * @example
     * // Create many Suppliers
     * const supplier = await prisma.supplier.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SupplierCreateManyArgs>(args?: SelectSubset<T, SupplierCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Supplier.
     * @param {SupplierDeleteArgs} args - Arguments to delete one Supplier.
     * @example
     * // Delete one Supplier
     * const Supplier = await prisma.supplier.delete({
     *   where: {
     *     // ... filter to delete one Supplier
     *   }
     * })
     * 
     */
    delete<T extends SupplierDeleteArgs>(args: SelectSubset<T, SupplierDeleteArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Supplier.
     * @param {SupplierUpdateArgs} args - Arguments to update one Supplier.
     * @example
     * // Update one Supplier
     * const supplier = await prisma.supplier.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SupplierUpdateArgs>(args: SelectSubset<T, SupplierUpdateArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Suppliers.
     * @param {SupplierDeleteManyArgs} args - Arguments to filter Suppliers to delete.
     * @example
     * // Delete a few Suppliers
     * const { count } = await prisma.supplier.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SupplierDeleteManyArgs>(args?: SelectSubset<T, SupplierDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Suppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Suppliers
     * const supplier = await prisma.supplier.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SupplierUpdateManyArgs>(args: SelectSubset<T, SupplierUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Supplier.
     * @param {SupplierUpsertArgs} args - Arguments to update or create a Supplier.
     * @example
     * // Update or create a Supplier
     * const supplier = await prisma.supplier.upsert({
     *   create: {
     *     // ... data to create a Supplier
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Supplier we want to update
     *   }
     * })
     */
    upsert<T extends SupplierUpsertArgs>(args: SelectSubset<T, SupplierUpsertArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Suppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierCountArgs} args - Arguments to filter Suppliers to count.
     * @example
     * // Count the number of Suppliers
     * const count = await prisma.supplier.count({
     *   where: {
     *     // ... the filter for the Suppliers we want to count
     *   }
     * })
    **/
    count<T extends SupplierCountArgs>(
      args?: Subset<T, SupplierCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SupplierCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Supplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SupplierAggregateArgs>(args: Subset<T, SupplierAggregateArgs>): Prisma.PrismaPromise<GetSupplierAggregateType<T>>

    /**
     * Group by Supplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SupplierGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SupplierGroupByArgs['orderBy'] }
        : { orderBy?: SupplierGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SupplierGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSupplierGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Supplier model
   */
  readonly fields: SupplierFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Supplier.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SupplierClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    quotations<T extends Supplier$quotationsArgs<ExtArgs> = {}>(args?: Subset<T, Supplier$quotationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierQuotationPayload<ExtArgs>, T, "findMany"> | Null>
    purchaseOrders<T extends Supplier$purchaseOrdersArgs<ExtArgs> = {}>(args?: Subset<T, Supplier$purchaseOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findMany"> | Null>
    invoices<T extends Supplier$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, Supplier$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierInvoicePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Supplier model
   */ 
  interface SupplierFieldRefs {
    readonly id: FieldRef<"Supplier", 'Int'>
    readonly name: FieldRef<"Supplier", 'String'>
    readonly contactPerson: FieldRef<"Supplier", 'String'>
    readonly email: FieldRef<"Supplier", 'String'>
    readonly phone: FieldRef<"Supplier", 'String'>
    readonly address: FieldRef<"Supplier", 'String'>
    readonly rating: FieldRef<"Supplier", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Supplier findUnique
   */
  export type SupplierFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier findUniqueOrThrow
   */
  export type SupplierFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier findFirst
   */
  export type SupplierFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Suppliers.
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Suppliers.
     */
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }

  /**
   * Supplier findFirstOrThrow
   */
  export type SupplierFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Suppliers.
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Suppliers.
     */
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }

  /**
   * Supplier findMany
   */
  export type SupplierFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Suppliers to fetch.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Suppliers.
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }

  /**
   * Supplier create
   */
  export type SupplierCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * The data needed to create a Supplier.
     */
    data: XOR<SupplierCreateInput, SupplierUncheckedCreateInput>
  }

  /**
   * Supplier createMany
   */
  export type SupplierCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Suppliers.
     */
    data: SupplierCreateManyInput | SupplierCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Supplier update
   */
  export type SupplierUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * The data needed to update a Supplier.
     */
    data: XOR<SupplierUpdateInput, SupplierUncheckedUpdateInput>
    /**
     * Choose, which Supplier to update.
     */
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier updateMany
   */
  export type SupplierUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Suppliers.
     */
    data: XOR<SupplierUpdateManyMutationInput, SupplierUncheckedUpdateManyInput>
    /**
     * Filter which Suppliers to update
     */
    where?: SupplierWhereInput
  }

  /**
   * Supplier upsert
   */
  export type SupplierUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * The filter to search for the Supplier to update in case it exists.
     */
    where: SupplierWhereUniqueInput
    /**
     * In case the Supplier found by the `where` argument doesn't exist, create a new Supplier with this data.
     */
    create: XOR<SupplierCreateInput, SupplierUncheckedCreateInput>
    /**
     * In case the Supplier was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SupplierUpdateInput, SupplierUncheckedUpdateInput>
  }

  /**
   * Supplier delete
   */
  export type SupplierDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter which Supplier to delete.
     */
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier deleteMany
   */
  export type SupplierDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Suppliers to delete
     */
    where?: SupplierWhereInput
  }

  /**
   * Supplier.quotations
   */
  export type Supplier$quotationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierQuotation
     */
    select?: SupplierQuotationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierQuotationInclude<ExtArgs> | null
    where?: SupplierQuotationWhereInput
    orderBy?: SupplierQuotationOrderByWithRelationInput | SupplierQuotationOrderByWithRelationInput[]
    cursor?: SupplierQuotationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SupplierQuotationScalarFieldEnum | SupplierQuotationScalarFieldEnum[]
  }

  /**
   * Supplier.purchaseOrders
   */
  export type Supplier$purchaseOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    where?: PurchaseOrderWhereInput
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    cursor?: PurchaseOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseOrderScalarFieldEnum | PurchaseOrderScalarFieldEnum[]
  }

  /**
   * Supplier.invoices
   */
  export type Supplier$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierInvoice
     */
    select?: SupplierInvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInvoiceInclude<ExtArgs> | null
    where?: SupplierInvoiceWhereInput
    orderBy?: SupplierInvoiceOrderByWithRelationInput | SupplierInvoiceOrderByWithRelationInput[]
    cursor?: SupplierInvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SupplierInvoiceScalarFieldEnum | SupplierInvoiceScalarFieldEnum[]
  }

  /**
   * Supplier without action
   */
  export type SupplierDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
  }


  /**
   * Model Material
   */

  export type AggregateMaterial = {
    _count: MaterialCountAggregateOutputType | null
    _avg: MaterialAvgAggregateOutputType | null
    _sum: MaterialSumAggregateOutputType | null
    _min: MaterialMinAggregateOutputType | null
    _max: MaterialMaxAggregateOutputType | null
  }

  export type MaterialAvgAggregateOutputType = {
    id: number | null
  }

  export type MaterialSumAggregateOutputType = {
    id: number | null
  }

  export type MaterialMinAggregateOutputType = {
    id: number | null
    code: string | null
    name: string | null
    description: string | null
    unit: string | null
    category: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MaterialMaxAggregateOutputType = {
    id: number | null
    code: string | null
    name: string | null
    description: string | null
    unit: string | null
    category: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MaterialCountAggregateOutputType = {
    id: number
    code: number
    name: number
    description: number
    unit: number
    category: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MaterialAvgAggregateInputType = {
    id?: true
  }

  export type MaterialSumAggregateInputType = {
    id?: true
  }

  export type MaterialMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    unit?: true
    category?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MaterialMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    unit?: true
    category?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MaterialCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    unit?: true
    category?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MaterialAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Material to aggregate.
     */
    where?: MaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Materials to fetch.
     */
    orderBy?: MaterialOrderByWithRelationInput | MaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Materials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Materials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Materials
    **/
    _count?: true | MaterialCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MaterialAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MaterialSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MaterialMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MaterialMaxAggregateInputType
  }

  export type GetMaterialAggregateType<T extends MaterialAggregateArgs> = {
        [P in keyof T & keyof AggregateMaterial]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMaterial[P]>
      : GetScalarType<T[P], AggregateMaterial[P]>
  }




  export type MaterialGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaterialWhereInput
    orderBy?: MaterialOrderByWithAggregationInput | MaterialOrderByWithAggregationInput[]
    by: MaterialScalarFieldEnum[] | MaterialScalarFieldEnum
    having?: MaterialScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MaterialCountAggregateInputType | true
    _avg?: MaterialAvgAggregateInputType
    _sum?: MaterialSumAggregateInputType
    _min?: MaterialMinAggregateInputType
    _max?: MaterialMaxAggregateInputType
  }

  export type MaterialGroupByOutputType = {
    id: number
    code: string
    name: string
    description: string | null
    unit: string
    category: string | null
    createdAt: Date
    updatedAt: Date
    _count: MaterialCountAggregateOutputType | null
    _avg: MaterialAvgAggregateOutputType | null
    _sum: MaterialSumAggregateOutputType | null
    _min: MaterialMinAggregateOutputType | null
    _max: MaterialMaxAggregateOutputType | null
  }

  type GetMaterialGroupByPayload<T extends MaterialGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MaterialGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MaterialGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MaterialGroupByOutputType[P]>
            : GetScalarType<T[P], MaterialGroupByOutputType[P]>
        }
      >
    >


  export type MaterialSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    unit?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["material"]>


  export type MaterialSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    unit?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $MaterialPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Material"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      code: string
      name: string
      description: string | null
      unit: string
      category: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["material"]>
    composites: {}
  }

  type MaterialGetPayload<S extends boolean | null | undefined | MaterialDefaultArgs> = $Result.GetResult<Prisma.$MaterialPayload, S>

  type MaterialCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MaterialFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MaterialCountAggregateInputType | true
    }

  export interface MaterialDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Material'], meta: { name: 'Material' } }
    /**
     * Find zero or one Material that matches the filter.
     * @param {MaterialFindUniqueArgs} args - Arguments to find a Material
     * @example
     * // Get one Material
     * const material = await prisma.material.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MaterialFindUniqueArgs>(args: SelectSubset<T, MaterialFindUniqueArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Material that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MaterialFindUniqueOrThrowArgs} args - Arguments to find a Material
     * @example
     * // Get one Material
     * const material = await prisma.material.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MaterialFindUniqueOrThrowArgs>(args: SelectSubset<T, MaterialFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Material that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialFindFirstArgs} args - Arguments to find a Material
     * @example
     * // Get one Material
     * const material = await prisma.material.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MaterialFindFirstArgs>(args?: SelectSubset<T, MaterialFindFirstArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Material that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialFindFirstOrThrowArgs} args - Arguments to find a Material
     * @example
     * // Get one Material
     * const material = await prisma.material.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MaterialFindFirstOrThrowArgs>(args?: SelectSubset<T, MaterialFindFirstOrThrowArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Materials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Materials
     * const materials = await prisma.material.findMany()
     * 
     * // Get first 10 Materials
     * const materials = await prisma.material.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const materialWithIdOnly = await prisma.material.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MaterialFindManyArgs>(args?: SelectSubset<T, MaterialFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Material.
     * @param {MaterialCreateArgs} args - Arguments to create a Material.
     * @example
     * // Create one Material
     * const Material = await prisma.material.create({
     *   data: {
     *     // ... data to create a Material
     *   }
     * })
     * 
     */
    create<T extends MaterialCreateArgs>(args: SelectSubset<T, MaterialCreateArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Materials.
     * @param {MaterialCreateManyArgs} args - Arguments to create many Materials.
     * @example
     * // Create many Materials
     * const material = await prisma.material.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MaterialCreateManyArgs>(args?: SelectSubset<T, MaterialCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Material.
     * @param {MaterialDeleteArgs} args - Arguments to delete one Material.
     * @example
     * // Delete one Material
     * const Material = await prisma.material.delete({
     *   where: {
     *     // ... filter to delete one Material
     *   }
     * })
     * 
     */
    delete<T extends MaterialDeleteArgs>(args: SelectSubset<T, MaterialDeleteArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Material.
     * @param {MaterialUpdateArgs} args - Arguments to update one Material.
     * @example
     * // Update one Material
     * const material = await prisma.material.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MaterialUpdateArgs>(args: SelectSubset<T, MaterialUpdateArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Materials.
     * @param {MaterialDeleteManyArgs} args - Arguments to filter Materials to delete.
     * @example
     * // Delete a few Materials
     * const { count } = await prisma.material.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MaterialDeleteManyArgs>(args?: SelectSubset<T, MaterialDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Materials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Materials
     * const material = await prisma.material.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MaterialUpdateManyArgs>(args: SelectSubset<T, MaterialUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Material.
     * @param {MaterialUpsertArgs} args - Arguments to update or create a Material.
     * @example
     * // Update or create a Material
     * const material = await prisma.material.upsert({
     *   create: {
     *     // ... data to create a Material
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Material we want to update
     *   }
     * })
     */
    upsert<T extends MaterialUpsertArgs>(args: SelectSubset<T, MaterialUpsertArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Materials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialCountArgs} args - Arguments to filter Materials to count.
     * @example
     * // Count the number of Materials
     * const count = await prisma.material.count({
     *   where: {
     *     // ... the filter for the Materials we want to count
     *   }
     * })
    **/
    count<T extends MaterialCountArgs>(
      args?: Subset<T, MaterialCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MaterialCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Material.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MaterialAggregateArgs>(args: Subset<T, MaterialAggregateArgs>): Prisma.PrismaPromise<GetMaterialAggregateType<T>>

    /**
     * Group by Material.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MaterialGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MaterialGroupByArgs['orderBy'] }
        : { orderBy?: MaterialGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MaterialGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMaterialGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Material model
   */
  readonly fields: MaterialFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Material.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MaterialClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Material model
   */ 
  interface MaterialFieldRefs {
    readonly id: FieldRef<"Material", 'Int'>
    readonly code: FieldRef<"Material", 'String'>
    readonly name: FieldRef<"Material", 'String'>
    readonly description: FieldRef<"Material", 'String'>
    readonly unit: FieldRef<"Material", 'String'>
    readonly category: FieldRef<"Material", 'String'>
    readonly createdAt: FieldRef<"Material", 'DateTime'>
    readonly updatedAt: FieldRef<"Material", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Material findUnique
   */
  export type MaterialFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Filter, which Material to fetch.
     */
    where: MaterialWhereUniqueInput
  }

  /**
   * Material findUniqueOrThrow
   */
  export type MaterialFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Filter, which Material to fetch.
     */
    where: MaterialWhereUniqueInput
  }

  /**
   * Material findFirst
   */
  export type MaterialFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Filter, which Material to fetch.
     */
    where?: MaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Materials to fetch.
     */
    orderBy?: MaterialOrderByWithRelationInput | MaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Materials.
     */
    cursor?: MaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Materials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Materials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Materials.
     */
    distinct?: MaterialScalarFieldEnum | MaterialScalarFieldEnum[]
  }

  /**
   * Material findFirstOrThrow
   */
  export type MaterialFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Filter, which Material to fetch.
     */
    where?: MaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Materials to fetch.
     */
    orderBy?: MaterialOrderByWithRelationInput | MaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Materials.
     */
    cursor?: MaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Materials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Materials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Materials.
     */
    distinct?: MaterialScalarFieldEnum | MaterialScalarFieldEnum[]
  }

  /**
   * Material findMany
   */
  export type MaterialFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Filter, which Materials to fetch.
     */
    where?: MaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Materials to fetch.
     */
    orderBy?: MaterialOrderByWithRelationInput | MaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Materials.
     */
    cursor?: MaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Materials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Materials.
     */
    skip?: number
    distinct?: MaterialScalarFieldEnum | MaterialScalarFieldEnum[]
  }

  /**
   * Material create
   */
  export type MaterialCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * The data needed to create a Material.
     */
    data: XOR<MaterialCreateInput, MaterialUncheckedCreateInput>
  }

  /**
   * Material createMany
   */
  export type MaterialCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Materials.
     */
    data: MaterialCreateManyInput | MaterialCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Material update
   */
  export type MaterialUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * The data needed to update a Material.
     */
    data: XOR<MaterialUpdateInput, MaterialUncheckedUpdateInput>
    /**
     * Choose, which Material to update.
     */
    where: MaterialWhereUniqueInput
  }

  /**
   * Material updateMany
   */
  export type MaterialUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Materials.
     */
    data: XOR<MaterialUpdateManyMutationInput, MaterialUncheckedUpdateManyInput>
    /**
     * Filter which Materials to update
     */
    where?: MaterialWhereInput
  }

  /**
   * Material upsert
   */
  export type MaterialUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * The filter to search for the Material to update in case it exists.
     */
    where: MaterialWhereUniqueInput
    /**
     * In case the Material found by the `where` argument doesn't exist, create a new Material with this data.
     */
    create: XOR<MaterialCreateInput, MaterialUncheckedCreateInput>
    /**
     * In case the Material was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MaterialUpdateInput, MaterialUncheckedUpdateInput>
  }

  /**
   * Material delete
   */
  export type MaterialDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Filter which Material to delete.
     */
    where: MaterialWhereUniqueInput
  }

  /**
   * Material deleteMany
   */
  export type MaterialDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Materials to delete
     */
    where?: MaterialWhereInput
  }

  /**
   * Material without action
   */
  export type MaterialDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
  }


  /**
   * Model Unit
   */

  export type AggregateUnit = {
    _count: UnitCountAggregateOutputType | null
    _avg: UnitAvgAggregateOutputType | null
    _sum: UnitSumAggregateOutputType | null
    _min: UnitMinAggregateOutputType | null
    _max: UnitMaxAggregateOutputType | null
  }

  export type UnitAvgAggregateOutputType = {
    id: number | null
  }

  export type UnitSumAggregateOutputType = {
    id: number | null
  }

  export type UnitMinAggregateOutputType = {
    id: number | null
    name: string | null
    abbreviation: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UnitMaxAggregateOutputType = {
    id: number | null
    name: string | null
    abbreviation: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UnitCountAggregateOutputType = {
    id: number
    name: number
    abbreviation: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UnitAvgAggregateInputType = {
    id?: true
  }

  export type UnitSumAggregateInputType = {
    id?: true
  }

  export type UnitMinAggregateInputType = {
    id?: true
    name?: true
    abbreviation?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UnitMaxAggregateInputType = {
    id?: true
    name?: true
    abbreviation?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UnitCountAggregateInputType = {
    id?: true
    name?: true
    abbreviation?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UnitAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Unit to aggregate.
     */
    where?: UnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Units
    **/
    _count?: true | UnitCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UnitAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UnitSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UnitMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UnitMaxAggregateInputType
  }

  export type GetUnitAggregateType<T extends UnitAggregateArgs> = {
        [P in keyof T & keyof AggregateUnit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUnit[P]>
      : GetScalarType<T[P], AggregateUnit[P]>
  }




  export type UnitGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitWhereInput
    orderBy?: UnitOrderByWithAggregationInput | UnitOrderByWithAggregationInput[]
    by: UnitScalarFieldEnum[] | UnitScalarFieldEnum
    having?: UnitScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UnitCountAggregateInputType | true
    _avg?: UnitAvgAggregateInputType
    _sum?: UnitSumAggregateInputType
    _min?: UnitMinAggregateInputType
    _max?: UnitMaxAggregateInputType
  }

  export type UnitGroupByOutputType = {
    id: number
    name: string
    abbreviation: string
    createdAt: Date
    updatedAt: Date
    _count: UnitCountAggregateOutputType | null
    _avg: UnitAvgAggregateOutputType | null
    _sum: UnitSumAggregateOutputType | null
    _min: UnitMinAggregateOutputType | null
    _max: UnitMaxAggregateOutputType | null
  }

  type GetUnitGroupByPayload<T extends UnitGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UnitGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UnitGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UnitGroupByOutputType[P]>
            : GetScalarType<T[P], UnitGroupByOutputType[P]>
        }
      >
    >


  export type UnitSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    abbreviation?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["unit"]>


  export type UnitSelectScalar = {
    id?: boolean
    name?: boolean
    abbreviation?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $UnitPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Unit"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      abbreviation: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["unit"]>
    composites: {}
  }

  type UnitGetPayload<S extends boolean | null | undefined | UnitDefaultArgs> = $Result.GetResult<Prisma.$UnitPayload, S>

  type UnitCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UnitFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UnitCountAggregateInputType | true
    }

  export interface UnitDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Unit'], meta: { name: 'Unit' } }
    /**
     * Find zero or one Unit that matches the filter.
     * @param {UnitFindUniqueArgs} args - Arguments to find a Unit
     * @example
     * // Get one Unit
     * const unit = await prisma.unit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UnitFindUniqueArgs>(args: SelectSubset<T, UnitFindUniqueArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Unit that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UnitFindUniqueOrThrowArgs} args - Arguments to find a Unit
     * @example
     * // Get one Unit
     * const unit = await prisma.unit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UnitFindUniqueOrThrowArgs>(args: SelectSubset<T, UnitFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Unit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitFindFirstArgs} args - Arguments to find a Unit
     * @example
     * // Get one Unit
     * const unit = await prisma.unit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UnitFindFirstArgs>(args?: SelectSubset<T, UnitFindFirstArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Unit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitFindFirstOrThrowArgs} args - Arguments to find a Unit
     * @example
     * // Get one Unit
     * const unit = await prisma.unit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UnitFindFirstOrThrowArgs>(args?: SelectSubset<T, UnitFindFirstOrThrowArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Units that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Units
     * const units = await prisma.unit.findMany()
     * 
     * // Get first 10 Units
     * const units = await prisma.unit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const unitWithIdOnly = await prisma.unit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UnitFindManyArgs>(args?: SelectSubset<T, UnitFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Unit.
     * @param {UnitCreateArgs} args - Arguments to create a Unit.
     * @example
     * // Create one Unit
     * const Unit = await prisma.unit.create({
     *   data: {
     *     // ... data to create a Unit
     *   }
     * })
     * 
     */
    create<T extends UnitCreateArgs>(args: SelectSubset<T, UnitCreateArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Units.
     * @param {UnitCreateManyArgs} args - Arguments to create many Units.
     * @example
     * // Create many Units
     * const unit = await prisma.unit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UnitCreateManyArgs>(args?: SelectSubset<T, UnitCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Unit.
     * @param {UnitDeleteArgs} args - Arguments to delete one Unit.
     * @example
     * // Delete one Unit
     * const Unit = await prisma.unit.delete({
     *   where: {
     *     // ... filter to delete one Unit
     *   }
     * })
     * 
     */
    delete<T extends UnitDeleteArgs>(args: SelectSubset<T, UnitDeleteArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Unit.
     * @param {UnitUpdateArgs} args - Arguments to update one Unit.
     * @example
     * // Update one Unit
     * const unit = await prisma.unit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UnitUpdateArgs>(args: SelectSubset<T, UnitUpdateArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Units.
     * @param {UnitDeleteManyArgs} args - Arguments to filter Units to delete.
     * @example
     * // Delete a few Units
     * const { count } = await prisma.unit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UnitDeleteManyArgs>(args?: SelectSubset<T, UnitDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Units.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Units
     * const unit = await prisma.unit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UnitUpdateManyArgs>(args: SelectSubset<T, UnitUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Unit.
     * @param {UnitUpsertArgs} args - Arguments to update or create a Unit.
     * @example
     * // Update or create a Unit
     * const unit = await prisma.unit.upsert({
     *   create: {
     *     // ... data to create a Unit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Unit we want to update
     *   }
     * })
     */
    upsert<T extends UnitUpsertArgs>(args: SelectSubset<T, UnitUpsertArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Units.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitCountArgs} args - Arguments to filter Units to count.
     * @example
     * // Count the number of Units
     * const count = await prisma.unit.count({
     *   where: {
     *     // ... the filter for the Units we want to count
     *   }
     * })
    **/
    count<T extends UnitCountArgs>(
      args?: Subset<T, UnitCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UnitCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Unit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UnitAggregateArgs>(args: Subset<T, UnitAggregateArgs>): Prisma.PrismaPromise<GetUnitAggregateType<T>>

    /**
     * Group by Unit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UnitGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UnitGroupByArgs['orderBy'] }
        : { orderBy?: UnitGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UnitGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUnitGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Unit model
   */
  readonly fields: UnitFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Unit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UnitClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Unit model
   */ 
  interface UnitFieldRefs {
    readonly id: FieldRef<"Unit", 'Int'>
    readonly name: FieldRef<"Unit", 'String'>
    readonly abbreviation: FieldRef<"Unit", 'String'>
    readonly createdAt: FieldRef<"Unit", 'DateTime'>
    readonly updatedAt: FieldRef<"Unit", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Unit findUnique
   */
  export type UnitFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Filter, which Unit to fetch.
     */
    where: UnitWhereUniqueInput
  }

  /**
   * Unit findUniqueOrThrow
   */
  export type UnitFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Filter, which Unit to fetch.
     */
    where: UnitWhereUniqueInput
  }

  /**
   * Unit findFirst
   */
  export type UnitFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Filter, which Unit to fetch.
     */
    where?: UnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Units.
     */
    cursor?: UnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Units.
     */
    distinct?: UnitScalarFieldEnum | UnitScalarFieldEnum[]
  }

  /**
   * Unit findFirstOrThrow
   */
  export type UnitFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Filter, which Unit to fetch.
     */
    where?: UnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Units.
     */
    cursor?: UnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Units.
     */
    distinct?: UnitScalarFieldEnum | UnitScalarFieldEnum[]
  }

  /**
   * Unit findMany
   */
  export type UnitFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Filter, which Units to fetch.
     */
    where?: UnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Units.
     */
    cursor?: UnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    distinct?: UnitScalarFieldEnum | UnitScalarFieldEnum[]
  }

  /**
   * Unit create
   */
  export type UnitCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * The data needed to create a Unit.
     */
    data: XOR<UnitCreateInput, UnitUncheckedCreateInput>
  }

  /**
   * Unit createMany
   */
  export type UnitCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Units.
     */
    data: UnitCreateManyInput | UnitCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Unit update
   */
  export type UnitUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * The data needed to update a Unit.
     */
    data: XOR<UnitUpdateInput, UnitUncheckedUpdateInput>
    /**
     * Choose, which Unit to update.
     */
    where: UnitWhereUniqueInput
  }

  /**
   * Unit updateMany
   */
  export type UnitUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Units.
     */
    data: XOR<UnitUpdateManyMutationInput, UnitUncheckedUpdateManyInput>
    /**
     * Filter which Units to update
     */
    where?: UnitWhereInput
  }

  /**
   * Unit upsert
   */
  export type UnitUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * The filter to search for the Unit to update in case it exists.
     */
    where: UnitWhereUniqueInput
    /**
     * In case the Unit found by the `where` argument doesn't exist, create a new Unit with this data.
     */
    create: XOR<UnitCreateInput, UnitUncheckedCreateInput>
    /**
     * In case the Unit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UnitUpdateInput, UnitUncheckedUpdateInput>
  }

  /**
   * Unit delete
   */
  export type UnitDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Filter which Unit to delete.
     */
    where: UnitWhereUniqueInput
  }

  /**
   * Unit deleteMany
   */
  export type UnitDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Units to delete
     */
    where?: UnitWhereInput
  }

  /**
   * Unit without action
   */
  export type UnitDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
  }


  /**
   * Model Category
   */

  export type AggregateCategory = {
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  export type CategoryAvgAggregateOutputType = {
    id: number | null
  }

  export type CategorySumAggregateOutputType = {
    id: number | null
  }

  export type CategoryMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoryMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoryCountAggregateOutputType = {
    id: number
    name: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CategoryAvgAggregateInputType = {
    id?: true
  }

  export type CategorySumAggregateInputType = {
    id?: true
  }

  export type CategoryMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoryMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoryCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Category to aggregate.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categories
    **/
    _count?: true | CategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryMaxAggregateInputType
  }

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>
  }




  export type CategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithAggregationInput | CategoryOrderByWithAggregationInput[]
    by: CategoryScalarFieldEnum[] | CategoryScalarFieldEnum
    having?: CategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryCountAggregateInputType | true
    _avg?: CategoryAvgAggregateInputType
    _sum?: CategorySumAggregateInputType
    _min?: CategoryMinAggregateInputType
    _max?: CategoryMaxAggregateInputType
  }

  export type CategoryGroupByOutputType = {
    id: number
    name: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  type GetCategoryGroupByPayload<T extends CategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryGroupByOutputType[P]>
        }
      >
    >


  export type CategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["category"]>


  export type CategorySelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $CategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Category"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["category"]>
    composites: {}
  }

  type CategoryGetPayload<S extends boolean | null | undefined | CategoryDefaultArgs> = $Result.GetResult<Prisma.$CategoryPayload, S>

  type CategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CategoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CategoryCountAggregateInputType | true
    }

  export interface CategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Category'], meta: { name: 'Category' } }
    /**
     * Find zero or one Category that matches the filter.
     * @param {CategoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CategoryFindUniqueArgs>(args: SelectSubset<T, CategoryFindUniqueArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Category that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CategoryFindUniqueOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, CategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CategoryFindFirstArgs>(args?: SelectSubset<T, CategoryFindFirstArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, CategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CategoryFindManyArgs>(args?: SelectSubset<T, CategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Category.
     * @param {CategoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     * 
     */
    create<T extends CategoryCreateArgs>(args: SelectSubset<T, CategoryCreateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Categories.
     * @param {CategoryCreateManyArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CategoryCreateManyArgs>(args?: SelectSubset<T, CategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Category.
     * @param {CategoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     * 
     */
    delete<T extends CategoryDeleteArgs>(args: SelectSubset<T, CategoryDeleteArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Category.
     * @param {CategoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CategoryUpdateArgs>(args: SelectSubset<T, CategoryUpdateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Categories.
     * @param {CategoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CategoryDeleteManyArgs>(args?: SelectSubset<T, CategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CategoryUpdateManyArgs>(args: SelectSubset<T, CategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Category.
     * @param {CategoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
     */
    upsert<T extends CategoryUpsertArgs>(args: SelectSubset<T, CategoryUpsertArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends CategoryCountArgs>(
      args?: Subset<T, CategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryAggregateArgs>(args: Subset<T, CategoryAggregateArgs>): Prisma.PrismaPromise<GetCategoryAggregateType<T>>

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryGroupByArgs['orderBy'] }
        : { orderBy?: CategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Category model
   */
  readonly fields: CategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Category model
   */ 
  interface CategoryFieldRefs {
    readonly id: FieldRef<"Category", 'Int'>
    readonly name: FieldRef<"Category", 'String'>
    readonly description: FieldRef<"Category", 'String'>
    readonly createdAt: FieldRef<"Category", 'DateTime'>
    readonly updatedAt: FieldRef<"Category", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Category findUnique
   */
  export type CategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findUniqueOrThrow
   */
  export type CategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findFirst
   */
  export type CategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findFirstOrThrow
   */
  export type CategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findMany
   */
  export type CategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category create
   */
  export type CategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * The data needed to create a Category.
     */
    data: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
  }

  /**
   * Category createMany
   */
  export type CategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Category update
   */
  export type CategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * The data needed to update a Category.
     */
    data: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
    /**
     * Choose, which Category to update.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category updateMany
   */
  export type CategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
  }

  /**
   * Category upsert
   */
  export type CategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * The filter to search for the Category to update in case it exists.
     */
    where: CategoryWhereUniqueInput
    /**
     * In case the Category found by the `where` argument doesn't exist, create a new Category with this data.
     */
    create: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
    /**
     * In case the Category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
  }

  /**
   * Category delete
   */
  export type CategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Filter which Category to delete.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category deleteMany
   */
  export type CategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categories to delete
     */
    where?: CategoryWhereInput
  }

  /**
   * Category without action
   */
  export type CategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
  }


  /**
   * Model Warehouse
   */

  export type AggregateWarehouse = {
    _count: WarehouseCountAggregateOutputType | null
    _avg: WarehouseAvgAggregateOutputType | null
    _sum: WarehouseSumAggregateOutputType | null
    _min: WarehouseMinAggregateOutputType | null
    _max: WarehouseMaxAggregateOutputType | null
  }

  export type WarehouseAvgAggregateOutputType = {
    id: number | null
  }

  export type WarehouseSumAggregateOutputType = {
    id: number | null
  }

  export type WarehouseMinAggregateOutputType = {
    id: number | null
    name: string | null
    location: string | null
    type: string | null
  }

  export type WarehouseMaxAggregateOutputType = {
    id: number | null
    name: string | null
    location: string | null
    type: string | null
  }

  export type WarehouseCountAggregateOutputType = {
    id: number
    name: number
    location: number
    type: number
    _all: number
  }


  export type WarehouseAvgAggregateInputType = {
    id?: true
  }

  export type WarehouseSumAggregateInputType = {
    id?: true
  }

  export type WarehouseMinAggregateInputType = {
    id?: true
    name?: true
    location?: true
    type?: true
  }

  export type WarehouseMaxAggregateInputType = {
    id?: true
    name?: true
    location?: true
    type?: true
  }

  export type WarehouseCountAggregateInputType = {
    id?: true
    name?: true
    location?: true
    type?: true
    _all?: true
  }

  export type WarehouseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Warehouse to aggregate.
     */
    where?: WarehouseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Warehouses to fetch.
     */
    orderBy?: WarehouseOrderByWithRelationInput | WarehouseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WarehouseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Warehouses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Warehouses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Warehouses
    **/
    _count?: true | WarehouseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WarehouseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WarehouseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WarehouseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WarehouseMaxAggregateInputType
  }

  export type GetWarehouseAggregateType<T extends WarehouseAggregateArgs> = {
        [P in keyof T & keyof AggregateWarehouse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWarehouse[P]>
      : GetScalarType<T[P], AggregateWarehouse[P]>
  }




  export type WarehouseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WarehouseWhereInput
    orderBy?: WarehouseOrderByWithAggregationInput | WarehouseOrderByWithAggregationInput[]
    by: WarehouseScalarFieldEnum[] | WarehouseScalarFieldEnum
    having?: WarehouseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WarehouseCountAggregateInputType | true
    _avg?: WarehouseAvgAggregateInputType
    _sum?: WarehouseSumAggregateInputType
    _min?: WarehouseMinAggregateInputType
    _max?: WarehouseMaxAggregateInputType
  }

  export type WarehouseGroupByOutputType = {
    id: number
    name: string
    location: string | null
    type: string
    _count: WarehouseCountAggregateOutputType | null
    _avg: WarehouseAvgAggregateOutputType | null
    _sum: WarehouseSumAggregateOutputType | null
    _min: WarehouseMinAggregateOutputType | null
    _max: WarehouseMaxAggregateOutputType | null
  }

  type GetWarehouseGroupByPayload<T extends WarehouseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WarehouseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WarehouseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WarehouseGroupByOutputType[P]>
            : GetScalarType<T[P], WarehouseGroupByOutputType[P]>
        }
      >
    >


  export type WarehouseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    location?: boolean
    type?: boolean
    inventory?: boolean | Warehouse$inventoryArgs<ExtArgs>
    _count?: boolean | WarehouseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["warehouse"]>


  export type WarehouseSelectScalar = {
    id?: boolean
    name?: boolean
    location?: boolean
    type?: boolean
  }

  export type WarehouseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inventory?: boolean | Warehouse$inventoryArgs<ExtArgs>
    _count?: boolean | WarehouseCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $WarehousePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Warehouse"
    objects: {
      inventory: Prisma.$InventoryItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      location: string | null
      type: string
    }, ExtArgs["result"]["warehouse"]>
    composites: {}
  }

  type WarehouseGetPayload<S extends boolean | null | undefined | WarehouseDefaultArgs> = $Result.GetResult<Prisma.$WarehousePayload, S>

  type WarehouseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WarehouseFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WarehouseCountAggregateInputType | true
    }

  export interface WarehouseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Warehouse'], meta: { name: 'Warehouse' } }
    /**
     * Find zero or one Warehouse that matches the filter.
     * @param {WarehouseFindUniqueArgs} args - Arguments to find a Warehouse
     * @example
     * // Get one Warehouse
     * const warehouse = await prisma.warehouse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WarehouseFindUniqueArgs>(args: SelectSubset<T, WarehouseFindUniqueArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Warehouse that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WarehouseFindUniqueOrThrowArgs} args - Arguments to find a Warehouse
     * @example
     * // Get one Warehouse
     * const warehouse = await prisma.warehouse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WarehouseFindUniqueOrThrowArgs>(args: SelectSubset<T, WarehouseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Warehouse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseFindFirstArgs} args - Arguments to find a Warehouse
     * @example
     * // Get one Warehouse
     * const warehouse = await prisma.warehouse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WarehouseFindFirstArgs>(args?: SelectSubset<T, WarehouseFindFirstArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Warehouse that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseFindFirstOrThrowArgs} args - Arguments to find a Warehouse
     * @example
     * // Get one Warehouse
     * const warehouse = await prisma.warehouse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WarehouseFindFirstOrThrowArgs>(args?: SelectSubset<T, WarehouseFindFirstOrThrowArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Warehouses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Warehouses
     * const warehouses = await prisma.warehouse.findMany()
     * 
     * // Get first 10 Warehouses
     * const warehouses = await prisma.warehouse.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const warehouseWithIdOnly = await prisma.warehouse.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WarehouseFindManyArgs>(args?: SelectSubset<T, WarehouseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Warehouse.
     * @param {WarehouseCreateArgs} args - Arguments to create a Warehouse.
     * @example
     * // Create one Warehouse
     * const Warehouse = await prisma.warehouse.create({
     *   data: {
     *     // ... data to create a Warehouse
     *   }
     * })
     * 
     */
    create<T extends WarehouseCreateArgs>(args: SelectSubset<T, WarehouseCreateArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Warehouses.
     * @param {WarehouseCreateManyArgs} args - Arguments to create many Warehouses.
     * @example
     * // Create many Warehouses
     * const warehouse = await prisma.warehouse.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WarehouseCreateManyArgs>(args?: SelectSubset<T, WarehouseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Warehouse.
     * @param {WarehouseDeleteArgs} args - Arguments to delete one Warehouse.
     * @example
     * // Delete one Warehouse
     * const Warehouse = await prisma.warehouse.delete({
     *   where: {
     *     // ... filter to delete one Warehouse
     *   }
     * })
     * 
     */
    delete<T extends WarehouseDeleteArgs>(args: SelectSubset<T, WarehouseDeleteArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Warehouse.
     * @param {WarehouseUpdateArgs} args - Arguments to update one Warehouse.
     * @example
     * // Update one Warehouse
     * const warehouse = await prisma.warehouse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WarehouseUpdateArgs>(args: SelectSubset<T, WarehouseUpdateArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Warehouses.
     * @param {WarehouseDeleteManyArgs} args - Arguments to filter Warehouses to delete.
     * @example
     * // Delete a few Warehouses
     * const { count } = await prisma.warehouse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WarehouseDeleteManyArgs>(args?: SelectSubset<T, WarehouseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Warehouses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Warehouses
     * const warehouse = await prisma.warehouse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WarehouseUpdateManyArgs>(args: SelectSubset<T, WarehouseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Warehouse.
     * @param {WarehouseUpsertArgs} args - Arguments to update or create a Warehouse.
     * @example
     * // Update or create a Warehouse
     * const warehouse = await prisma.warehouse.upsert({
     *   create: {
     *     // ... data to create a Warehouse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Warehouse we want to update
     *   }
     * })
     */
    upsert<T extends WarehouseUpsertArgs>(args: SelectSubset<T, WarehouseUpsertArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Warehouses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseCountArgs} args - Arguments to filter Warehouses to count.
     * @example
     * // Count the number of Warehouses
     * const count = await prisma.warehouse.count({
     *   where: {
     *     // ... the filter for the Warehouses we want to count
     *   }
     * })
    **/
    count<T extends WarehouseCountArgs>(
      args?: Subset<T, WarehouseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WarehouseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Warehouse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WarehouseAggregateArgs>(args: Subset<T, WarehouseAggregateArgs>): Prisma.PrismaPromise<GetWarehouseAggregateType<T>>

    /**
     * Group by Warehouse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WarehouseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WarehouseGroupByArgs['orderBy'] }
        : { orderBy?: WarehouseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WarehouseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWarehouseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Warehouse model
   */
  readonly fields: WarehouseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Warehouse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WarehouseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    inventory<T extends Warehouse$inventoryArgs<ExtArgs> = {}>(args?: Subset<T, Warehouse$inventoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Warehouse model
   */ 
  interface WarehouseFieldRefs {
    readonly id: FieldRef<"Warehouse", 'Int'>
    readonly name: FieldRef<"Warehouse", 'String'>
    readonly location: FieldRef<"Warehouse", 'String'>
    readonly type: FieldRef<"Warehouse", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Warehouse findUnique
   */
  export type WarehouseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    /**
     * Filter, which Warehouse to fetch.
     */
    where: WarehouseWhereUniqueInput
  }

  /**
   * Warehouse findUniqueOrThrow
   */
  export type WarehouseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    /**
     * Filter, which Warehouse to fetch.
     */
    where: WarehouseWhereUniqueInput
  }

  /**
   * Warehouse findFirst
   */
  export type WarehouseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    /**
     * Filter, which Warehouse to fetch.
     */
    where?: WarehouseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Warehouses to fetch.
     */
    orderBy?: WarehouseOrderByWithRelationInput | WarehouseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Warehouses.
     */
    cursor?: WarehouseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Warehouses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Warehouses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Warehouses.
     */
    distinct?: WarehouseScalarFieldEnum | WarehouseScalarFieldEnum[]
  }

  /**
   * Warehouse findFirstOrThrow
   */
  export type WarehouseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    /**
     * Filter, which Warehouse to fetch.
     */
    where?: WarehouseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Warehouses to fetch.
     */
    orderBy?: WarehouseOrderByWithRelationInput | WarehouseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Warehouses.
     */
    cursor?: WarehouseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Warehouses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Warehouses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Warehouses.
     */
    distinct?: WarehouseScalarFieldEnum | WarehouseScalarFieldEnum[]
  }

  /**
   * Warehouse findMany
   */
  export type WarehouseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    /**
     * Filter, which Warehouses to fetch.
     */
    where?: WarehouseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Warehouses to fetch.
     */
    orderBy?: WarehouseOrderByWithRelationInput | WarehouseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Warehouses.
     */
    cursor?: WarehouseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Warehouses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Warehouses.
     */
    skip?: number
    distinct?: WarehouseScalarFieldEnum | WarehouseScalarFieldEnum[]
  }

  /**
   * Warehouse create
   */
  export type WarehouseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    /**
     * The data needed to create a Warehouse.
     */
    data: XOR<WarehouseCreateInput, WarehouseUncheckedCreateInput>
  }

  /**
   * Warehouse createMany
   */
  export type WarehouseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Warehouses.
     */
    data: WarehouseCreateManyInput | WarehouseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Warehouse update
   */
  export type WarehouseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    /**
     * The data needed to update a Warehouse.
     */
    data: XOR<WarehouseUpdateInput, WarehouseUncheckedUpdateInput>
    /**
     * Choose, which Warehouse to update.
     */
    where: WarehouseWhereUniqueInput
  }

  /**
   * Warehouse updateMany
   */
  export type WarehouseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Warehouses.
     */
    data: XOR<WarehouseUpdateManyMutationInput, WarehouseUncheckedUpdateManyInput>
    /**
     * Filter which Warehouses to update
     */
    where?: WarehouseWhereInput
  }

  /**
   * Warehouse upsert
   */
  export type WarehouseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    /**
     * The filter to search for the Warehouse to update in case it exists.
     */
    where: WarehouseWhereUniqueInput
    /**
     * In case the Warehouse found by the `where` argument doesn't exist, create a new Warehouse with this data.
     */
    create: XOR<WarehouseCreateInput, WarehouseUncheckedCreateInput>
    /**
     * In case the Warehouse was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WarehouseUpdateInput, WarehouseUncheckedUpdateInput>
  }

  /**
   * Warehouse delete
   */
  export type WarehouseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    /**
     * Filter which Warehouse to delete.
     */
    where: WarehouseWhereUniqueInput
  }

  /**
   * Warehouse deleteMany
   */
  export type WarehouseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Warehouses to delete
     */
    where?: WarehouseWhereInput
  }

  /**
   * Warehouse.inventory
   */
  export type Warehouse$inventoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    where?: InventoryItemWhereInput
    orderBy?: InventoryItemOrderByWithRelationInput | InventoryItemOrderByWithRelationInput[]
    cursor?: InventoryItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryItemScalarFieldEnum | InventoryItemScalarFieldEnum[]
  }

  /**
   * Warehouse without action
   */
  export type WarehouseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
  }


  /**
   * Model SupplierQuotation
   */

  export type AggregateSupplierQuotation = {
    _count: SupplierQuotationCountAggregateOutputType | null
    _avg: SupplierQuotationAvgAggregateOutputType | null
    _sum: SupplierQuotationSumAggregateOutputType | null
    _min: SupplierQuotationMinAggregateOutputType | null
    _max: SupplierQuotationMaxAggregateOutputType | null
  }

  export type SupplierQuotationAvgAggregateOutputType = {
    id: number | null
    rfqId: number | null
    supplierId: number | null
    totalAmount: Decimal | null
  }

  export type SupplierQuotationSumAggregateOutputType = {
    id: number | null
    rfqId: number | null
    supplierId: number | null
    totalAmount: Decimal | null
  }

  export type SupplierQuotationMinAggregateOutputType = {
    id: number | null
    rfqId: number | null
    supplierId: number | null
    quoteDate: Date | null
    totalAmount: Decimal | null
    currency: string | null
    isSelected: boolean | null
  }

  export type SupplierQuotationMaxAggregateOutputType = {
    id: number | null
    rfqId: number | null
    supplierId: number | null
    quoteDate: Date | null
    totalAmount: Decimal | null
    currency: string | null
    isSelected: boolean | null
  }

  export type SupplierQuotationCountAggregateOutputType = {
    id: number
    rfqId: number
    supplierId: number
    quoteDate: number
    totalAmount: number
    currency: number
    isSelected: number
    _all: number
  }


  export type SupplierQuotationAvgAggregateInputType = {
    id?: true
    rfqId?: true
    supplierId?: true
    totalAmount?: true
  }

  export type SupplierQuotationSumAggregateInputType = {
    id?: true
    rfqId?: true
    supplierId?: true
    totalAmount?: true
  }

  export type SupplierQuotationMinAggregateInputType = {
    id?: true
    rfqId?: true
    supplierId?: true
    quoteDate?: true
    totalAmount?: true
    currency?: true
    isSelected?: true
  }

  export type SupplierQuotationMaxAggregateInputType = {
    id?: true
    rfqId?: true
    supplierId?: true
    quoteDate?: true
    totalAmount?: true
    currency?: true
    isSelected?: true
  }

  export type SupplierQuotationCountAggregateInputType = {
    id?: true
    rfqId?: true
    supplierId?: true
    quoteDate?: true
    totalAmount?: true
    currency?: true
    isSelected?: true
    _all?: true
  }

  export type SupplierQuotationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SupplierQuotation to aggregate.
     */
    where?: SupplierQuotationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupplierQuotations to fetch.
     */
    orderBy?: SupplierQuotationOrderByWithRelationInput | SupplierQuotationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SupplierQuotationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupplierQuotations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupplierQuotations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SupplierQuotations
    **/
    _count?: true | SupplierQuotationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SupplierQuotationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SupplierQuotationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SupplierQuotationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SupplierQuotationMaxAggregateInputType
  }

  export type GetSupplierQuotationAggregateType<T extends SupplierQuotationAggregateArgs> = {
        [P in keyof T & keyof AggregateSupplierQuotation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupplierQuotation[P]>
      : GetScalarType<T[P], AggregateSupplierQuotation[P]>
  }




  export type SupplierQuotationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupplierQuotationWhereInput
    orderBy?: SupplierQuotationOrderByWithAggregationInput | SupplierQuotationOrderByWithAggregationInput[]
    by: SupplierQuotationScalarFieldEnum[] | SupplierQuotationScalarFieldEnum
    having?: SupplierQuotationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SupplierQuotationCountAggregateInputType | true
    _avg?: SupplierQuotationAvgAggregateInputType
    _sum?: SupplierQuotationSumAggregateInputType
    _min?: SupplierQuotationMinAggregateInputType
    _max?: SupplierQuotationMaxAggregateInputType
  }

  export type SupplierQuotationGroupByOutputType = {
    id: number
    rfqId: number
    supplierId: number
    quoteDate: Date
    totalAmount: Decimal
    currency: string
    isSelected: boolean
    _count: SupplierQuotationCountAggregateOutputType | null
    _avg: SupplierQuotationAvgAggregateOutputType | null
    _sum: SupplierQuotationSumAggregateOutputType | null
    _min: SupplierQuotationMinAggregateOutputType | null
    _max: SupplierQuotationMaxAggregateOutputType | null
  }

  type GetSupplierQuotationGroupByPayload<T extends SupplierQuotationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SupplierQuotationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SupplierQuotationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SupplierQuotationGroupByOutputType[P]>
            : GetScalarType<T[P], SupplierQuotationGroupByOutputType[P]>
        }
      >
    >


  export type SupplierQuotationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rfqId?: boolean
    supplierId?: boolean
    quoteDate?: boolean
    totalAmount?: boolean
    currency?: boolean
    isSelected?: boolean
    rfq?: boolean | RFQDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
    items?: boolean | SupplierQuotation$itemsArgs<ExtArgs>
    _count?: boolean | SupplierQuotationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supplierQuotation"]>


  export type SupplierQuotationSelectScalar = {
    id?: boolean
    rfqId?: boolean
    supplierId?: boolean
    quoteDate?: boolean
    totalAmount?: boolean
    currency?: boolean
    isSelected?: boolean
  }

  export type SupplierQuotationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rfq?: boolean | RFQDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
    items?: boolean | SupplierQuotation$itemsArgs<ExtArgs>
    _count?: boolean | SupplierQuotationCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $SupplierQuotationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SupplierQuotation"
    objects: {
      rfq: Prisma.$RFQPayload<ExtArgs>
      supplier: Prisma.$SupplierPayload<ExtArgs>
      items: Prisma.$QuotationItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      rfqId: number
      supplierId: number
      quoteDate: Date
      totalAmount: Prisma.Decimal
      currency: string
      isSelected: boolean
    }, ExtArgs["result"]["supplierQuotation"]>
    composites: {}
  }

  type SupplierQuotationGetPayload<S extends boolean | null | undefined | SupplierQuotationDefaultArgs> = $Result.GetResult<Prisma.$SupplierQuotationPayload, S>

  type SupplierQuotationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SupplierQuotationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SupplierQuotationCountAggregateInputType | true
    }

  export interface SupplierQuotationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SupplierQuotation'], meta: { name: 'SupplierQuotation' } }
    /**
     * Find zero or one SupplierQuotation that matches the filter.
     * @param {SupplierQuotationFindUniqueArgs} args - Arguments to find a SupplierQuotation
     * @example
     * // Get one SupplierQuotation
     * const supplierQuotation = await prisma.supplierQuotation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SupplierQuotationFindUniqueArgs>(args: SelectSubset<T, SupplierQuotationFindUniqueArgs<ExtArgs>>): Prisma__SupplierQuotationClient<$Result.GetResult<Prisma.$SupplierQuotationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SupplierQuotation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SupplierQuotationFindUniqueOrThrowArgs} args - Arguments to find a SupplierQuotation
     * @example
     * // Get one SupplierQuotation
     * const supplierQuotation = await prisma.supplierQuotation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SupplierQuotationFindUniqueOrThrowArgs>(args: SelectSubset<T, SupplierQuotationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SupplierQuotationClient<$Result.GetResult<Prisma.$SupplierQuotationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SupplierQuotation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierQuotationFindFirstArgs} args - Arguments to find a SupplierQuotation
     * @example
     * // Get one SupplierQuotation
     * const supplierQuotation = await prisma.supplierQuotation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SupplierQuotationFindFirstArgs>(args?: SelectSubset<T, SupplierQuotationFindFirstArgs<ExtArgs>>): Prisma__SupplierQuotationClient<$Result.GetResult<Prisma.$SupplierQuotationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SupplierQuotation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierQuotationFindFirstOrThrowArgs} args - Arguments to find a SupplierQuotation
     * @example
     * // Get one SupplierQuotation
     * const supplierQuotation = await prisma.supplierQuotation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SupplierQuotationFindFirstOrThrowArgs>(args?: SelectSubset<T, SupplierQuotationFindFirstOrThrowArgs<ExtArgs>>): Prisma__SupplierQuotationClient<$Result.GetResult<Prisma.$SupplierQuotationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SupplierQuotations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierQuotationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SupplierQuotations
     * const supplierQuotations = await prisma.supplierQuotation.findMany()
     * 
     * // Get first 10 SupplierQuotations
     * const supplierQuotations = await prisma.supplierQuotation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const supplierQuotationWithIdOnly = await prisma.supplierQuotation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SupplierQuotationFindManyArgs>(args?: SelectSubset<T, SupplierQuotationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierQuotationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SupplierQuotation.
     * @param {SupplierQuotationCreateArgs} args - Arguments to create a SupplierQuotation.
     * @example
     * // Create one SupplierQuotation
     * const SupplierQuotation = await prisma.supplierQuotation.create({
     *   data: {
     *     // ... data to create a SupplierQuotation
     *   }
     * })
     * 
     */
    create<T extends SupplierQuotationCreateArgs>(args: SelectSubset<T, SupplierQuotationCreateArgs<ExtArgs>>): Prisma__SupplierQuotationClient<$Result.GetResult<Prisma.$SupplierQuotationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SupplierQuotations.
     * @param {SupplierQuotationCreateManyArgs} args - Arguments to create many SupplierQuotations.
     * @example
     * // Create many SupplierQuotations
     * const supplierQuotation = await prisma.supplierQuotation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SupplierQuotationCreateManyArgs>(args?: SelectSubset<T, SupplierQuotationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SupplierQuotation.
     * @param {SupplierQuotationDeleteArgs} args - Arguments to delete one SupplierQuotation.
     * @example
     * // Delete one SupplierQuotation
     * const SupplierQuotation = await prisma.supplierQuotation.delete({
     *   where: {
     *     // ... filter to delete one SupplierQuotation
     *   }
     * })
     * 
     */
    delete<T extends SupplierQuotationDeleteArgs>(args: SelectSubset<T, SupplierQuotationDeleteArgs<ExtArgs>>): Prisma__SupplierQuotationClient<$Result.GetResult<Prisma.$SupplierQuotationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SupplierQuotation.
     * @param {SupplierQuotationUpdateArgs} args - Arguments to update one SupplierQuotation.
     * @example
     * // Update one SupplierQuotation
     * const supplierQuotation = await prisma.supplierQuotation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SupplierQuotationUpdateArgs>(args: SelectSubset<T, SupplierQuotationUpdateArgs<ExtArgs>>): Prisma__SupplierQuotationClient<$Result.GetResult<Prisma.$SupplierQuotationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SupplierQuotations.
     * @param {SupplierQuotationDeleteManyArgs} args - Arguments to filter SupplierQuotations to delete.
     * @example
     * // Delete a few SupplierQuotations
     * const { count } = await prisma.supplierQuotation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SupplierQuotationDeleteManyArgs>(args?: SelectSubset<T, SupplierQuotationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SupplierQuotations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierQuotationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SupplierQuotations
     * const supplierQuotation = await prisma.supplierQuotation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SupplierQuotationUpdateManyArgs>(args: SelectSubset<T, SupplierQuotationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SupplierQuotation.
     * @param {SupplierQuotationUpsertArgs} args - Arguments to update or create a SupplierQuotation.
     * @example
     * // Update or create a SupplierQuotation
     * const supplierQuotation = await prisma.supplierQuotation.upsert({
     *   create: {
     *     // ... data to create a SupplierQuotation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SupplierQuotation we want to update
     *   }
     * })
     */
    upsert<T extends SupplierQuotationUpsertArgs>(args: SelectSubset<T, SupplierQuotationUpsertArgs<ExtArgs>>): Prisma__SupplierQuotationClient<$Result.GetResult<Prisma.$SupplierQuotationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SupplierQuotations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierQuotationCountArgs} args - Arguments to filter SupplierQuotations to count.
     * @example
     * // Count the number of SupplierQuotations
     * const count = await prisma.supplierQuotation.count({
     *   where: {
     *     // ... the filter for the SupplierQuotations we want to count
     *   }
     * })
    **/
    count<T extends SupplierQuotationCountArgs>(
      args?: Subset<T, SupplierQuotationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SupplierQuotationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SupplierQuotation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierQuotationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SupplierQuotationAggregateArgs>(args: Subset<T, SupplierQuotationAggregateArgs>): Prisma.PrismaPromise<GetSupplierQuotationAggregateType<T>>

    /**
     * Group by SupplierQuotation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierQuotationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SupplierQuotationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SupplierQuotationGroupByArgs['orderBy'] }
        : { orderBy?: SupplierQuotationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SupplierQuotationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSupplierQuotationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SupplierQuotation model
   */
  readonly fields: SupplierQuotationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SupplierQuotation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SupplierQuotationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    rfq<T extends RFQDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RFQDefaultArgs<ExtArgs>>): Prisma__RFQClient<$Result.GetResult<Prisma.$RFQPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    supplier<T extends SupplierDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SupplierDefaultArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    items<T extends SupplierQuotation$itemsArgs<ExtArgs> = {}>(args?: Subset<T, SupplierQuotation$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotationItemPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SupplierQuotation model
   */ 
  interface SupplierQuotationFieldRefs {
    readonly id: FieldRef<"SupplierQuotation", 'Int'>
    readonly rfqId: FieldRef<"SupplierQuotation", 'Int'>
    readonly supplierId: FieldRef<"SupplierQuotation", 'Int'>
    readonly quoteDate: FieldRef<"SupplierQuotation", 'DateTime'>
    readonly totalAmount: FieldRef<"SupplierQuotation", 'Decimal'>
    readonly currency: FieldRef<"SupplierQuotation", 'String'>
    readonly isSelected: FieldRef<"SupplierQuotation", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * SupplierQuotation findUnique
   */
  export type SupplierQuotationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierQuotation
     */
    select?: SupplierQuotationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierQuotationInclude<ExtArgs> | null
    /**
     * Filter, which SupplierQuotation to fetch.
     */
    where: SupplierQuotationWhereUniqueInput
  }

  /**
   * SupplierQuotation findUniqueOrThrow
   */
  export type SupplierQuotationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierQuotation
     */
    select?: SupplierQuotationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierQuotationInclude<ExtArgs> | null
    /**
     * Filter, which SupplierQuotation to fetch.
     */
    where: SupplierQuotationWhereUniqueInput
  }

  /**
   * SupplierQuotation findFirst
   */
  export type SupplierQuotationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierQuotation
     */
    select?: SupplierQuotationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierQuotationInclude<ExtArgs> | null
    /**
     * Filter, which SupplierQuotation to fetch.
     */
    where?: SupplierQuotationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupplierQuotations to fetch.
     */
    orderBy?: SupplierQuotationOrderByWithRelationInput | SupplierQuotationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SupplierQuotations.
     */
    cursor?: SupplierQuotationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupplierQuotations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupplierQuotations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SupplierQuotations.
     */
    distinct?: SupplierQuotationScalarFieldEnum | SupplierQuotationScalarFieldEnum[]
  }

  /**
   * SupplierQuotation findFirstOrThrow
   */
  export type SupplierQuotationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierQuotation
     */
    select?: SupplierQuotationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierQuotationInclude<ExtArgs> | null
    /**
     * Filter, which SupplierQuotation to fetch.
     */
    where?: SupplierQuotationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupplierQuotations to fetch.
     */
    orderBy?: SupplierQuotationOrderByWithRelationInput | SupplierQuotationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SupplierQuotations.
     */
    cursor?: SupplierQuotationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupplierQuotations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupplierQuotations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SupplierQuotations.
     */
    distinct?: SupplierQuotationScalarFieldEnum | SupplierQuotationScalarFieldEnum[]
  }

  /**
   * SupplierQuotation findMany
   */
  export type SupplierQuotationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierQuotation
     */
    select?: SupplierQuotationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierQuotationInclude<ExtArgs> | null
    /**
     * Filter, which SupplierQuotations to fetch.
     */
    where?: SupplierQuotationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupplierQuotations to fetch.
     */
    orderBy?: SupplierQuotationOrderByWithRelationInput | SupplierQuotationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SupplierQuotations.
     */
    cursor?: SupplierQuotationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupplierQuotations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupplierQuotations.
     */
    skip?: number
    distinct?: SupplierQuotationScalarFieldEnum | SupplierQuotationScalarFieldEnum[]
  }

  /**
   * SupplierQuotation create
   */
  export type SupplierQuotationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierQuotation
     */
    select?: SupplierQuotationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierQuotationInclude<ExtArgs> | null
    /**
     * The data needed to create a SupplierQuotation.
     */
    data: XOR<SupplierQuotationCreateInput, SupplierQuotationUncheckedCreateInput>
  }

  /**
   * SupplierQuotation createMany
   */
  export type SupplierQuotationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SupplierQuotations.
     */
    data: SupplierQuotationCreateManyInput | SupplierQuotationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SupplierQuotation update
   */
  export type SupplierQuotationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierQuotation
     */
    select?: SupplierQuotationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierQuotationInclude<ExtArgs> | null
    /**
     * The data needed to update a SupplierQuotation.
     */
    data: XOR<SupplierQuotationUpdateInput, SupplierQuotationUncheckedUpdateInput>
    /**
     * Choose, which SupplierQuotation to update.
     */
    where: SupplierQuotationWhereUniqueInput
  }

  /**
   * SupplierQuotation updateMany
   */
  export type SupplierQuotationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SupplierQuotations.
     */
    data: XOR<SupplierQuotationUpdateManyMutationInput, SupplierQuotationUncheckedUpdateManyInput>
    /**
     * Filter which SupplierQuotations to update
     */
    where?: SupplierQuotationWhereInput
  }

  /**
   * SupplierQuotation upsert
   */
  export type SupplierQuotationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierQuotation
     */
    select?: SupplierQuotationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierQuotationInclude<ExtArgs> | null
    /**
     * The filter to search for the SupplierQuotation to update in case it exists.
     */
    where: SupplierQuotationWhereUniqueInput
    /**
     * In case the SupplierQuotation found by the `where` argument doesn't exist, create a new SupplierQuotation with this data.
     */
    create: XOR<SupplierQuotationCreateInput, SupplierQuotationUncheckedCreateInput>
    /**
     * In case the SupplierQuotation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SupplierQuotationUpdateInput, SupplierQuotationUncheckedUpdateInput>
  }

  /**
   * SupplierQuotation delete
   */
  export type SupplierQuotationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierQuotation
     */
    select?: SupplierQuotationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierQuotationInclude<ExtArgs> | null
    /**
     * Filter which SupplierQuotation to delete.
     */
    where: SupplierQuotationWhereUniqueInput
  }

  /**
   * SupplierQuotation deleteMany
   */
  export type SupplierQuotationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SupplierQuotations to delete
     */
    where?: SupplierQuotationWhereInput
  }

  /**
   * SupplierQuotation.items
   */
  export type SupplierQuotation$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotationItem
     */
    select?: QuotationItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationItemInclude<ExtArgs> | null
    where?: QuotationItemWhereInput
    orderBy?: QuotationItemOrderByWithRelationInput | QuotationItemOrderByWithRelationInput[]
    cursor?: QuotationItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuotationItemScalarFieldEnum | QuotationItemScalarFieldEnum[]
  }

  /**
   * SupplierQuotation without action
   */
  export type SupplierQuotationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierQuotation
     */
    select?: SupplierQuotationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierQuotationInclude<ExtArgs> | null
  }


  /**
   * Model QuotationItem
   */

  export type AggregateQuotationItem = {
    _count: QuotationItemCountAggregateOutputType | null
    _avg: QuotationItemAvgAggregateOutputType | null
    _sum: QuotationItemSumAggregateOutputType | null
    _min: QuotationItemMinAggregateOutputType | null
    _max: QuotationItemMaxAggregateOutputType | null
  }

  export type QuotationItemAvgAggregateOutputType = {
    id: number | null
    supplierQuotationId: number | null
    quantity: Decimal | null
    unitPrice: Decimal | null
    totalPrice: Decimal | null
  }

  export type QuotationItemSumAggregateOutputType = {
    id: number | null
    supplierQuotationId: number | null
    quantity: Decimal | null
    unitPrice: Decimal | null
    totalPrice: Decimal | null
  }

  export type QuotationItemMinAggregateOutputType = {
    id: number | null
    supplierQuotationId: number | null
    materialName: string | null
    quantity: Decimal | null
    unitPrice: Decimal | null
    totalPrice: Decimal | null
    remarks: string | null
  }

  export type QuotationItemMaxAggregateOutputType = {
    id: number | null
    supplierQuotationId: number | null
    materialName: string | null
    quantity: Decimal | null
    unitPrice: Decimal | null
    totalPrice: Decimal | null
    remarks: string | null
  }

  export type QuotationItemCountAggregateOutputType = {
    id: number
    supplierQuotationId: number
    materialName: number
    quantity: number
    unitPrice: number
    totalPrice: number
    remarks: number
    _all: number
  }


  export type QuotationItemAvgAggregateInputType = {
    id?: true
    supplierQuotationId?: true
    quantity?: true
    unitPrice?: true
    totalPrice?: true
  }

  export type QuotationItemSumAggregateInputType = {
    id?: true
    supplierQuotationId?: true
    quantity?: true
    unitPrice?: true
    totalPrice?: true
  }

  export type QuotationItemMinAggregateInputType = {
    id?: true
    supplierQuotationId?: true
    materialName?: true
    quantity?: true
    unitPrice?: true
    totalPrice?: true
    remarks?: true
  }

  export type QuotationItemMaxAggregateInputType = {
    id?: true
    supplierQuotationId?: true
    materialName?: true
    quantity?: true
    unitPrice?: true
    totalPrice?: true
    remarks?: true
  }

  export type QuotationItemCountAggregateInputType = {
    id?: true
    supplierQuotationId?: true
    materialName?: true
    quantity?: true
    unitPrice?: true
    totalPrice?: true
    remarks?: true
    _all?: true
  }

  export type QuotationItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuotationItem to aggregate.
     */
    where?: QuotationItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuotationItems to fetch.
     */
    orderBy?: QuotationItemOrderByWithRelationInput | QuotationItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuotationItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuotationItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuotationItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuotationItems
    **/
    _count?: true | QuotationItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuotationItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuotationItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuotationItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuotationItemMaxAggregateInputType
  }

  export type GetQuotationItemAggregateType<T extends QuotationItemAggregateArgs> = {
        [P in keyof T & keyof AggregateQuotationItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuotationItem[P]>
      : GetScalarType<T[P], AggregateQuotationItem[P]>
  }




  export type QuotationItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuotationItemWhereInput
    orderBy?: QuotationItemOrderByWithAggregationInput | QuotationItemOrderByWithAggregationInput[]
    by: QuotationItemScalarFieldEnum[] | QuotationItemScalarFieldEnum
    having?: QuotationItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuotationItemCountAggregateInputType | true
    _avg?: QuotationItemAvgAggregateInputType
    _sum?: QuotationItemSumAggregateInputType
    _min?: QuotationItemMinAggregateInputType
    _max?: QuotationItemMaxAggregateInputType
  }

  export type QuotationItemGroupByOutputType = {
    id: number
    supplierQuotationId: number
    materialName: string
    quantity: Decimal
    unitPrice: Decimal
    totalPrice: Decimal
    remarks: string | null
    _count: QuotationItemCountAggregateOutputType | null
    _avg: QuotationItemAvgAggregateOutputType | null
    _sum: QuotationItemSumAggregateOutputType | null
    _min: QuotationItemMinAggregateOutputType | null
    _max: QuotationItemMaxAggregateOutputType | null
  }

  type GetQuotationItemGroupByPayload<T extends QuotationItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuotationItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuotationItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuotationItemGroupByOutputType[P]>
            : GetScalarType<T[P], QuotationItemGroupByOutputType[P]>
        }
      >
    >


  export type QuotationItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    supplierQuotationId?: boolean
    materialName?: boolean
    quantity?: boolean
    unitPrice?: boolean
    totalPrice?: boolean
    remarks?: boolean
    supplierQuotation?: boolean | SupplierQuotationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quotationItem"]>


  export type QuotationItemSelectScalar = {
    id?: boolean
    supplierQuotationId?: boolean
    materialName?: boolean
    quantity?: boolean
    unitPrice?: boolean
    totalPrice?: boolean
    remarks?: boolean
  }

  export type QuotationItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    supplierQuotation?: boolean | SupplierQuotationDefaultArgs<ExtArgs>
  }

  export type $QuotationItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QuotationItem"
    objects: {
      supplierQuotation: Prisma.$SupplierQuotationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      supplierQuotationId: number
      materialName: string
      quantity: Prisma.Decimal
      unitPrice: Prisma.Decimal
      totalPrice: Prisma.Decimal
      remarks: string | null
    }, ExtArgs["result"]["quotationItem"]>
    composites: {}
  }

  type QuotationItemGetPayload<S extends boolean | null | undefined | QuotationItemDefaultArgs> = $Result.GetResult<Prisma.$QuotationItemPayload, S>

  type QuotationItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<QuotationItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: QuotationItemCountAggregateInputType | true
    }

  export interface QuotationItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QuotationItem'], meta: { name: 'QuotationItem' } }
    /**
     * Find zero or one QuotationItem that matches the filter.
     * @param {QuotationItemFindUniqueArgs} args - Arguments to find a QuotationItem
     * @example
     * // Get one QuotationItem
     * const quotationItem = await prisma.quotationItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuotationItemFindUniqueArgs>(args: SelectSubset<T, QuotationItemFindUniqueArgs<ExtArgs>>): Prisma__QuotationItemClient<$Result.GetResult<Prisma.$QuotationItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one QuotationItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {QuotationItemFindUniqueOrThrowArgs} args - Arguments to find a QuotationItem
     * @example
     * // Get one QuotationItem
     * const quotationItem = await prisma.quotationItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuotationItemFindUniqueOrThrowArgs>(args: SelectSubset<T, QuotationItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuotationItemClient<$Result.GetResult<Prisma.$QuotationItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first QuotationItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotationItemFindFirstArgs} args - Arguments to find a QuotationItem
     * @example
     * // Get one QuotationItem
     * const quotationItem = await prisma.quotationItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuotationItemFindFirstArgs>(args?: SelectSubset<T, QuotationItemFindFirstArgs<ExtArgs>>): Prisma__QuotationItemClient<$Result.GetResult<Prisma.$QuotationItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first QuotationItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotationItemFindFirstOrThrowArgs} args - Arguments to find a QuotationItem
     * @example
     * // Get one QuotationItem
     * const quotationItem = await prisma.quotationItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuotationItemFindFirstOrThrowArgs>(args?: SelectSubset<T, QuotationItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuotationItemClient<$Result.GetResult<Prisma.$QuotationItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more QuotationItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotationItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuotationItems
     * const quotationItems = await prisma.quotationItem.findMany()
     * 
     * // Get first 10 QuotationItems
     * const quotationItems = await prisma.quotationItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quotationItemWithIdOnly = await prisma.quotationItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuotationItemFindManyArgs>(args?: SelectSubset<T, QuotationItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotationItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a QuotationItem.
     * @param {QuotationItemCreateArgs} args - Arguments to create a QuotationItem.
     * @example
     * // Create one QuotationItem
     * const QuotationItem = await prisma.quotationItem.create({
     *   data: {
     *     // ... data to create a QuotationItem
     *   }
     * })
     * 
     */
    create<T extends QuotationItemCreateArgs>(args: SelectSubset<T, QuotationItemCreateArgs<ExtArgs>>): Prisma__QuotationItemClient<$Result.GetResult<Prisma.$QuotationItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many QuotationItems.
     * @param {QuotationItemCreateManyArgs} args - Arguments to create many QuotationItems.
     * @example
     * // Create many QuotationItems
     * const quotationItem = await prisma.quotationItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuotationItemCreateManyArgs>(args?: SelectSubset<T, QuotationItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a QuotationItem.
     * @param {QuotationItemDeleteArgs} args - Arguments to delete one QuotationItem.
     * @example
     * // Delete one QuotationItem
     * const QuotationItem = await prisma.quotationItem.delete({
     *   where: {
     *     // ... filter to delete one QuotationItem
     *   }
     * })
     * 
     */
    delete<T extends QuotationItemDeleteArgs>(args: SelectSubset<T, QuotationItemDeleteArgs<ExtArgs>>): Prisma__QuotationItemClient<$Result.GetResult<Prisma.$QuotationItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one QuotationItem.
     * @param {QuotationItemUpdateArgs} args - Arguments to update one QuotationItem.
     * @example
     * // Update one QuotationItem
     * const quotationItem = await prisma.quotationItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuotationItemUpdateArgs>(args: SelectSubset<T, QuotationItemUpdateArgs<ExtArgs>>): Prisma__QuotationItemClient<$Result.GetResult<Prisma.$QuotationItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more QuotationItems.
     * @param {QuotationItemDeleteManyArgs} args - Arguments to filter QuotationItems to delete.
     * @example
     * // Delete a few QuotationItems
     * const { count } = await prisma.quotationItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuotationItemDeleteManyArgs>(args?: SelectSubset<T, QuotationItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuotationItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotationItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuotationItems
     * const quotationItem = await prisma.quotationItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuotationItemUpdateManyArgs>(args: SelectSubset<T, QuotationItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one QuotationItem.
     * @param {QuotationItemUpsertArgs} args - Arguments to update or create a QuotationItem.
     * @example
     * // Update or create a QuotationItem
     * const quotationItem = await prisma.quotationItem.upsert({
     *   create: {
     *     // ... data to create a QuotationItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuotationItem we want to update
     *   }
     * })
     */
    upsert<T extends QuotationItemUpsertArgs>(args: SelectSubset<T, QuotationItemUpsertArgs<ExtArgs>>): Prisma__QuotationItemClient<$Result.GetResult<Prisma.$QuotationItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of QuotationItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotationItemCountArgs} args - Arguments to filter QuotationItems to count.
     * @example
     * // Count the number of QuotationItems
     * const count = await prisma.quotationItem.count({
     *   where: {
     *     // ... the filter for the QuotationItems we want to count
     *   }
     * })
    **/
    count<T extends QuotationItemCountArgs>(
      args?: Subset<T, QuotationItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuotationItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuotationItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotationItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuotationItemAggregateArgs>(args: Subset<T, QuotationItemAggregateArgs>): Prisma.PrismaPromise<GetQuotationItemAggregateType<T>>

    /**
     * Group by QuotationItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotationItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuotationItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuotationItemGroupByArgs['orderBy'] }
        : { orderBy?: QuotationItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuotationItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuotationItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QuotationItem model
   */
  readonly fields: QuotationItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QuotationItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuotationItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    supplierQuotation<T extends SupplierQuotationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SupplierQuotationDefaultArgs<ExtArgs>>): Prisma__SupplierQuotationClient<$Result.GetResult<Prisma.$SupplierQuotationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QuotationItem model
   */ 
  interface QuotationItemFieldRefs {
    readonly id: FieldRef<"QuotationItem", 'Int'>
    readonly supplierQuotationId: FieldRef<"QuotationItem", 'Int'>
    readonly materialName: FieldRef<"QuotationItem", 'String'>
    readonly quantity: FieldRef<"QuotationItem", 'Decimal'>
    readonly unitPrice: FieldRef<"QuotationItem", 'Decimal'>
    readonly totalPrice: FieldRef<"QuotationItem", 'Decimal'>
    readonly remarks: FieldRef<"QuotationItem", 'String'>
  }
    

  // Custom InputTypes
  /**
   * QuotationItem findUnique
   */
  export type QuotationItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotationItem
     */
    select?: QuotationItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationItemInclude<ExtArgs> | null
    /**
     * Filter, which QuotationItem to fetch.
     */
    where: QuotationItemWhereUniqueInput
  }

  /**
   * QuotationItem findUniqueOrThrow
   */
  export type QuotationItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotationItem
     */
    select?: QuotationItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationItemInclude<ExtArgs> | null
    /**
     * Filter, which QuotationItem to fetch.
     */
    where: QuotationItemWhereUniqueInput
  }

  /**
   * QuotationItem findFirst
   */
  export type QuotationItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotationItem
     */
    select?: QuotationItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationItemInclude<ExtArgs> | null
    /**
     * Filter, which QuotationItem to fetch.
     */
    where?: QuotationItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuotationItems to fetch.
     */
    orderBy?: QuotationItemOrderByWithRelationInput | QuotationItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuotationItems.
     */
    cursor?: QuotationItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuotationItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuotationItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuotationItems.
     */
    distinct?: QuotationItemScalarFieldEnum | QuotationItemScalarFieldEnum[]
  }

  /**
   * QuotationItem findFirstOrThrow
   */
  export type QuotationItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotationItem
     */
    select?: QuotationItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationItemInclude<ExtArgs> | null
    /**
     * Filter, which QuotationItem to fetch.
     */
    where?: QuotationItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuotationItems to fetch.
     */
    orderBy?: QuotationItemOrderByWithRelationInput | QuotationItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuotationItems.
     */
    cursor?: QuotationItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuotationItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuotationItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuotationItems.
     */
    distinct?: QuotationItemScalarFieldEnum | QuotationItemScalarFieldEnum[]
  }

  /**
   * QuotationItem findMany
   */
  export type QuotationItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotationItem
     */
    select?: QuotationItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationItemInclude<ExtArgs> | null
    /**
     * Filter, which QuotationItems to fetch.
     */
    where?: QuotationItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuotationItems to fetch.
     */
    orderBy?: QuotationItemOrderByWithRelationInput | QuotationItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuotationItems.
     */
    cursor?: QuotationItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuotationItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuotationItems.
     */
    skip?: number
    distinct?: QuotationItemScalarFieldEnum | QuotationItemScalarFieldEnum[]
  }

  /**
   * QuotationItem create
   */
  export type QuotationItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotationItem
     */
    select?: QuotationItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationItemInclude<ExtArgs> | null
    /**
     * The data needed to create a QuotationItem.
     */
    data: XOR<QuotationItemCreateInput, QuotationItemUncheckedCreateInput>
  }

  /**
   * QuotationItem createMany
   */
  export type QuotationItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QuotationItems.
     */
    data: QuotationItemCreateManyInput | QuotationItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuotationItem update
   */
  export type QuotationItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotationItem
     */
    select?: QuotationItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationItemInclude<ExtArgs> | null
    /**
     * The data needed to update a QuotationItem.
     */
    data: XOR<QuotationItemUpdateInput, QuotationItemUncheckedUpdateInput>
    /**
     * Choose, which QuotationItem to update.
     */
    where: QuotationItemWhereUniqueInput
  }

  /**
   * QuotationItem updateMany
   */
  export type QuotationItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QuotationItems.
     */
    data: XOR<QuotationItemUpdateManyMutationInput, QuotationItemUncheckedUpdateManyInput>
    /**
     * Filter which QuotationItems to update
     */
    where?: QuotationItemWhereInput
  }

  /**
   * QuotationItem upsert
   */
  export type QuotationItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotationItem
     */
    select?: QuotationItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationItemInclude<ExtArgs> | null
    /**
     * The filter to search for the QuotationItem to update in case it exists.
     */
    where: QuotationItemWhereUniqueInput
    /**
     * In case the QuotationItem found by the `where` argument doesn't exist, create a new QuotationItem with this data.
     */
    create: XOR<QuotationItemCreateInput, QuotationItemUncheckedCreateInput>
    /**
     * In case the QuotationItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuotationItemUpdateInput, QuotationItemUncheckedUpdateInput>
  }

  /**
   * QuotationItem delete
   */
  export type QuotationItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotationItem
     */
    select?: QuotationItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationItemInclude<ExtArgs> | null
    /**
     * Filter which QuotationItem to delete.
     */
    where: QuotationItemWhereUniqueInput
  }

  /**
   * QuotationItem deleteMany
   */
  export type QuotationItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuotationItems to delete
     */
    where?: QuotationItemWhereInput
  }

  /**
   * QuotationItem without action
   */
  export type QuotationItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotationItem
     */
    select?: QuotationItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationItemInclude<ExtArgs> | null
  }


  /**
   * Model PurchaseOrder
   */

  export type AggregatePurchaseOrder = {
    _count: PurchaseOrderCountAggregateOutputType | null
    _avg: PurchaseOrderAvgAggregateOutputType | null
    _sum: PurchaseOrderSumAggregateOutputType | null
    _min: PurchaseOrderMinAggregateOutputType | null
    _max: PurchaseOrderMaxAggregateOutputType | null
  }

  export type PurchaseOrderAvgAggregateOutputType = {
    id: number | null
    projectId: number | null
    supplierId: number | null
    requesterId: number | null
    approverId: number | null
    totalAmount: Decimal | null
  }

  export type PurchaseOrderSumAggregateOutputType = {
    id: number | null
    projectId: number | null
    supplierId: number | null
    requesterId: number | null
    approverId: number | null
    totalAmount: Decimal | null
  }

  export type PurchaseOrderMinAggregateOutputType = {
    id: number | null
    orderDate: Date | null
    projectId: number | null
    supplierId: number | null
    requesterId: number | null
    approverId: number | null
    status: $Enums.PoStatus | null
    remarks: string | null
    totalAmount: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchaseOrderMaxAggregateOutputType = {
    id: number | null
    orderDate: Date | null
    projectId: number | null
    supplierId: number | null
    requesterId: number | null
    approverId: number | null
    status: $Enums.PoStatus | null
    remarks: string | null
    totalAmount: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchaseOrderCountAggregateOutputType = {
    id: number
    orderDate: number
    projectId: number
    supplierId: number
    requesterId: number
    approverId: number
    status: number
    remarks: number
    totalAmount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PurchaseOrderAvgAggregateInputType = {
    id?: true
    projectId?: true
    supplierId?: true
    requesterId?: true
    approverId?: true
    totalAmount?: true
  }

  export type PurchaseOrderSumAggregateInputType = {
    id?: true
    projectId?: true
    supplierId?: true
    requesterId?: true
    approverId?: true
    totalAmount?: true
  }

  export type PurchaseOrderMinAggregateInputType = {
    id?: true
    orderDate?: true
    projectId?: true
    supplierId?: true
    requesterId?: true
    approverId?: true
    status?: true
    remarks?: true
    totalAmount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchaseOrderMaxAggregateInputType = {
    id?: true
    orderDate?: true
    projectId?: true
    supplierId?: true
    requesterId?: true
    approverId?: true
    status?: true
    remarks?: true
    totalAmount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchaseOrderCountAggregateInputType = {
    id?: true
    orderDate?: true
    projectId?: true
    supplierId?: true
    requesterId?: true
    approverId?: true
    status?: true
    remarks?: true
    totalAmount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PurchaseOrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseOrder to aggregate.
     */
    where?: PurchaseOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrders to fetch.
     */
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PurchaseOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PurchaseOrders
    **/
    _count?: true | PurchaseOrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PurchaseOrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PurchaseOrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchaseOrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchaseOrderMaxAggregateInputType
  }

  export type GetPurchaseOrderAggregateType<T extends PurchaseOrderAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchaseOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchaseOrder[P]>
      : GetScalarType<T[P], AggregatePurchaseOrder[P]>
  }




  export type PurchaseOrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseOrderWhereInput
    orderBy?: PurchaseOrderOrderByWithAggregationInput | PurchaseOrderOrderByWithAggregationInput[]
    by: PurchaseOrderScalarFieldEnum[] | PurchaseOrderScalarFieldEnum
    having?: PurchaseOrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchaseOrderCountAggregateInputType | true
    _avg?: PurchaseOrderAvgAggregateInputType
    _sum?: PurchaseOrderSumAggregateInputType
    _min?: PurchaseOrderMinAggregateInputType
    _max?: PurchaseOrderMaxAggregateInputType
  }

  export type PurchaseOrderGroupByOutputType = {
    id: number
    orderDate: Date
    projectId: number
    supplierId: number | null
    requesterId: number
    approverId: number | null
    status: $Enums.PoStatus
    remarks: string | null
    totalAmount: Decimal
    createdAt: Date
    updatedAt: Date
    _count: PurchaseOrderCountAggregateOutputType | null
    _avg: PurchaseOrderAvgAggregateOutputType | null
    _sum: PurchaseOrderSumAggregateOutputType | null
    _min: PurchaseOrderMinAggregateOutputType | null
    _max: PurchaseOrderMaxAggregateOutputType | null
  }

  type GetPurchaseOrderGroupByPayload<T extends PurchaseOrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PurchaseOrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchaseOrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchaseOrderGroupByOutputType[P]>
            : GetScalarType<T[P], PurchaseOrderGroupByOutputType[P]>
        }
      >
    >


  export type PurchaseOrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderDate?: boolean
    projectId?: boolean
    supplierId?: boolean
    requesterId?: boolean
    approverId?: boolean
    status?: boolean
    remarks?: boolean
    totalAmount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    supplier?: boolean | PurchaseOrder$supplierArgs<ExtArgs>
    requester?: boolean | UserDefaultArgs<ExtArgs>
    approver?: boolean | PurchaseOrder$approverArgs<ExtArgs>
    items?: boolean | PurchaseOrder$itemsArgs<ExtArgs>
    receiving?: boolean | PurchaseOrder$receivingArgs<ExtArgs>
    invoices?: boolean | PurchaseOrder$invoicesArgs<ExtArgs>
    disbursements?: boolean | PurchaseOrder$disbursementsArgs<ExtArgs>
    _count?: boolean | PurchaseOrderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseOrder"]>


  export type PurchaseOrderSelectScalar = {
    id?: boolean
    orderDate?: boolean
    projectId?: boolean
    supplierId?: boolean
    requesterId?: boolean
    approverId?: boolean
    status?: boolean
    remarks?: boolean
    totalAmount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PurchaseOrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    supplier?: boolean | PurchaseOrder$supplierArgs<ExtArgs>
    requester?: boolean | UserDefaultArgs<ExtArgs>
    approver?: boolean | PurchaseOrder$approverArgs<ExtArgs>
    items?: boolean | PurchaseOrder$itemsArgs<ExtArgs>
    receiving?: boolean | PurchaseOrder$receivingArgs<ExtArgs>
    invoices?: boolean | PurchaseOrder$invoicesArgs<ExtArgs>
    disbursements?: boolean | PurchaseOrder$disbursementsArgs<ExtArgs>
    _count?: boolean | PurchaseOrderCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $PurchaseOrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PurchaseOrder"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      supplier: Prisma.$SupplierPayload<ExtArgs> | null
      requester: Prisma.$UserPayload<ExtArgs>
      approver: Prisma.$UserPayload<ExtArgs> | null
      items: Prisma.$PurchaseOrderItemPayload<ExtArgs>[]
      receiving: Prisma.$ReceivingReportPayload<ExtArgs>[]
      invoices: Prisma.$SupplierInvoicePayload<ExtArgs>[]
      disbursements: Prisma.$DisbursementPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      orderDate: Date
      projectId: number
      supplierId: number | null
      requesterId: number
      approverId: number | null
      status: $Enums.PoStatus
      remarks: string | null
      totalAmount: Prisma.Decimal
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["purchaseOrder"]>
    composites: {}
  }

  type PurchaseOrderGetPayload<S extends boolean | null | undefined | PurchaseOrderDefaultArgs> = $Result.GetResult<Prisma.$PurchaseOrderPayload, S>

  type PurchaseOrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PurchaseOrderFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PurchaseOrderCountAggregateInputType | true
    }

  export interface PurchaseOrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PurchaseOrder'], meta: { name: 'PurchaseOrder' } }
    /**
     * Find zero or one PurchaseOrder that matches the filter.
     * @param {PurchaseOrderFindUniqueArgs} args - Arguments to find a PurchaseOrder
     * @example
     * // Get one PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PurchaseOrderFindUniqueArgs>(args: SelectSubset<T, PurchaseOrderFindUniqueArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PurchaseOrder that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PurchaseOrderFindUniqueOrThrowArgs} args - Arguments to find a PurchaseOrder
     * @example
     * // Get one PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PurchaseOrderFindUniqueOrThrowArgs>(args: SelectSubset<T, PurchaseOrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PurchaseOrder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderFindFirstArgs} args - Arguments to find a PurchaseOrder
     * @example
     * // Get one PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PurchaseOrderFindFirstArgs>(args?: SelectSubset<T, PurchaseOrderFindFirstArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PurchaseOrder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderFindFirstOrThrowArgs} args - Arguments to find a PurchaseOrder
     * @example
     * // Get one PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PurchaseOrderFindFirstOrThrowArgs>(args?: SelectSubset<T, PurchaseOrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PurchaseOrders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PurchaseOrders
     * const purchaseOrders = await prisma.purchaseOrder.findMany()
     * 
     * // Get first 10 PurchaseOrders
     * const purchaseOrders = await prisma.purchaseOrder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const purchaseOrderWithIdOnly = await prisma.purchaseOrder.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PurchaseOrderFindManyArgs>(args?: SelectSubset<T, PurchaseOrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PurchaseOrder.
     * @param {PurchaseOrderCreateArgs} args - Arguments to create a PurchaseOrder.
     * @example
     * // Create one PurchaseOrder
     * const PurchaseOrder = await prisma.purchaseOrder.create({
     *   data: {
     *     // ... data to create a PurchaseOrder
     *   }
     * })
     * 
     */
    create<T extends PurchaseOrderCreateArgs>(args: SelectSubset<T, PurchaseOrderCreateArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PurchaseOrders.
     * @param {PurchaseOrderCreateManyArgs} args - Arguments to create many PurchaseOrders.
     * @example
     * // Create many PurchaseOrders
     * const purchaseOrder = await prisma.purchaseOrder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PurchaseOrderCreateManyArgs>(args?: SelectSubset<T, PurchaseOrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PurchaseOrder.
     * @param {PurchaseOrderDeleteArgs} args - Arguments to delete one PurchaseOrder.
     * @example
     * // Delete one PurchaseOrder
     * const PurchaseOrder = await prisma.purchaseOrder.delete({
     *   where: {
     *     // ... filter to delete one PurchaseOrder
     *   }
     * })
     * 
     */
    delete<T extends PurchaseOrderDeleteArgs>(args: SelectSubset<T, PurchaseOrderDeleteArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PurchaseOrder.
     * @param {PurchaseOrderUpdateArgs} args - Arguments to update one PurchaseOrder.
     * @example
     * // Update one PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PurchaseOrderUpdateArgs>(args: SelectSubset<T, PurchaseOrderUpdateArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PurchaseOrders.
     * @param {PurchaseOrderDeleteManyArgs} args - Arguments to filter PurchaseOrders to delete.
     * @example
     * // Delete a few PurchaseOrders
     * const { count } = await prisma.purchaseOrder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PurchaseOrderDeleteManyArgs>(args?: SelectSubset<T, PurchaseOrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PurchaseOrders
     * const purchaseOrder = await prisma.purchaseOrder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PurchaseOrderUpdateManyArgs>(args: SelectSubset<T, PurchaseOrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PurchaseOrder.
     * @param {PurchaseOrderUpsertArgs} args - Arguments to update or create a PurchaseOrder.
     * @example
     * // Update or create a PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.upsert({
     *   create: {
     *     // ... data to create a PurchaseOrder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PurchaseOrder we want to update
     *   }
     * })
     */
    upsert<T extends PurchaseOrderUpsertArgs>(args: SelectSubset<T, PurchaseOrderUpsertArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PurchaseOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderCountArgs} args - Arguments to filter PurchaseOrders to count.
     * @example
     * // Count the number of PurchaseOrders
     * const count = await prisma.purchaseOrder.count({
     *   where: {
     *     // ... the filter for the PurchaseOrders we want to count
     *   }
     * })
    **/
    count<T extends PurchaseOrderCountArgs>(
      args?: Subset<T, PurchaseOrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchaseOrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PurchaseOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchaseOrderAggregateArgs>(args: Subset<T, PurchaseOrderAggregateArgs>): Prisma.PrismaPromise<GetPurchaseOrderAggregateType<T>>

    /**
     * Group by PurchaseOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PurchaseOrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PurchaseOrderGroupByArgs['orderBy'] }
        : { orderBy?: PurchaseOrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PurchaseOrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchaseOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PurchaseOrder model
   */
  readonly fields: PurchaseOrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PurchaseOrder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PurchaseOrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    supplier<T extends PurchaseOrder$supplierArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseOrder$supplierArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    requester<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    approver<T extends PurchaseOrder$approverArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseOrder$approverArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    items<T extends PurchaseOrder$itemsArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseOrder$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderItemPayload<ExtArgs>, T, "findMany"> | Null>
    receiving<T extends PurchaseOrder$receivingArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseOrder$receivingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReceivingReportPayload<ExtArgs>, T, "findMany"> | Null>
    invoices<T extends PurchaseOrder$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseOrder$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierInvoicePayload<ExtArgs>, T, "findMany"> | Null>
    disbursements<T extends PurchaseOrder$disbursementsArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseOrder$disbursementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DisbursementPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PurchaseOrder model
   */ 
  interface PurchaseOrderFieldRefs {
    readonly id: FieldRef<"PurchaseOrder", 'Int'>
    readonly orderDate: FieldRef<"PurchaseOrder", 'DateTime'>
    readonly projectId: FieldRef<"PurchaseOrder", 'Int'>
    readonly supplierId: FieldRef<"PurchaseOrder", 'Int'>
    readonly requesterId: FieldRef<"PurchaseOrder", 'Int'>
    readonly approverId: FieldRef<"PurchaseOrder", 'Int'>
    readonly status: FieldRef<"PurchaseOrder", 'PoStatus'>
    readonly remarks: FieldRef<"PurchaseOrder", 'String'>
    readonly totalAmount: FieldRef<"PurchaseOrder", 'Decimal'>
    readonly createdAt: FieldRef<"PurchaseOrder", 'DateTime'>
    readonly updatedAt: FieldRef<"PurchaseOrder", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PurchaseOrder findUnique
   */
  export type PurchaseOrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrder to fetch.
     */
    where: PurchaseOrderWhereUniqueInput
  }

  /**
   * PurchaseOrder findUniqueOrThrow
   */
  export type PurchaseOrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrder to fetch.
     */
    where: PurchaseOrderWhereUniqueInput
  }

  /**
   * PurchaseOrder findFirst
   */
  export type PurchaseOrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrder to fetch.
     */
    where?: PurchaseOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrders to fetch.
     */
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseOrders.
     */
    cursor?: PurchaseOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseOrders.
     */
    distinct?: PurchaseOrderScalarFieldEnum | PurchaseOrderScalarFieldEnum[]
  }

  /**
   * PurchaseOrder findFirstOrThrow
   */
  export type PurchaseOrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrder to fetch.
     */
    where?: PurchaseOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrders to fetch.
     */
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseOrders.
     */
    cursor?: PurchaseOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseOrders.
     */
    distinct?: PurchaseOrderScalarFieldEnum | PurchaseOrderScalarFieldEnum[]
  }

  /**
   * PurchaseOrder findMany
   */
  export type PurchaseOrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrders to fetch.
     */
    where?: PurchaseOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrders to fetch.
     */
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PurchaseOrders.
     */
    cursor?: PurchaseOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrders.
     */
    skip?: number
    distinct?: PurchaseOrderScalarFieldEnum | PurchaseOrderScalarFieldEnum[]
  }

  /**
   * PurchaseOrder create
   */
  export type PurchaseOrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * The data needed to create a PurchaseOrder.
     */
    data: XOR<PurchaseOrderCreateInput, PurchaseOrderUncheckedCreateInput>
  }

  /**
   * PurchaseOrder createMany
   */
  export type PurchaseOrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PurchaseOrders.
     */
    data: PurchaseOrderCreateManyInput | PurchaseOrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PurchaseOrder update
   */
  export type PurchaseOrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * The data needed to update a PurchaseOrder.
     */
    data: XOR<PurchaseOrderUpdateInput, PurchaseOrderUncheckedUpdateInput>
    /**
     * Choose, which PurchaseOrder to update.
     */
    where: PurchaseOrderWhereUniqueInput
  }

  /**
   * PurchaseOrder updateMany
   */
  export type PurchaseOrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PurchaseOrders.
     */
    data: XOR<PurchaseOrderUpdateManyMutationInput, PurchaseOrderUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseOrders to update
     */
    where?: PurchaseOrderWhereInput
  }

  /**
   * PurchaseOrder upsert
   */
  export type PurchaseOrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * The filter to search for the PurchaseOrder to update in case it exists.
     */
    where: PurchaseOrderWhereUniqueInput
    /**
     * In case the PurchaseOrder found by the `where` argument doesn't exist, create a new PurchaseOrder with this data.
     */
    create: XOR<PurchaseOrderCreateInput, PurchaseOrderUncheckedCreateInput>
    /**
     * In case the PurchaseOrder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PurchaseOrderUpdateInput, PurchaseOrderUncheckedUpdateInput>
  }

  /**
   * PurchaseOrder delete
   */
  export type PurchaseOrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter which PurchaseOrder to delete.
     */
    where: PurchaseOrderWhereUniqueInput
  }

  /**
   * PurchaseOrder deleteMany
   */
  export type PurchaseOrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseOrders to delete
     */
    where?: PurchaseOrderWhereInput
  }

  /**
   * PurchaseOrder.supplier
   */
  export type PurchaseOrder$supplierArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    where?: SupplierWhereInput
  }

  /**
   * PurchaseOrder.approver
   */
  export type PurchaseOrder$approverArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * PurchaseOrder.items
   */
  export type PurchaseOrder$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderItem
     */
    select?: PurchaseOrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderItemInclude<ExtArgs> | null
    where?: PurchaseOrderItemWhereInput
    orderBy?: PurchaseOrderItemOrderByWithRelationInput | PurchaseOrderItemOrderByWithRelationInput[]
    cursor?: PurchaseOrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseOrderItemScalarFieldEnum | PurchaseOrderItemScalarFieldEnum[]
  }

  /**
   * PurchaseOrder.receiving
   */
  export type PurchaseOrder$receivingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceivingReport
     */
    select?: ReceivingReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceivingReportInclude<ExtArgs> | null
    where?: ReceivingReportWhereInput
    orderBy?: ReceivingReportOrderByWithRelationInput | ReceivingReportOrderByWithRelationInput[]
    cursor?: ReceivingReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReceivingReportScalarFieldEnum | ReceivingReportScalarFieldEnum[]
  }

  /**
   * PurchaseOrder.invoices
   */
  export type PurchaseOrder$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierInvoice
     */
    select?: SupplierInvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInvoiceInclude<ExtArgs> | null
    where?: SupplierInvoiceWhereInput
    orderBy?: SupplierInvoiceOrderByWithRelationInput | SupplierInvoiceOrderByWithRelationInput[]
    cursor?: SupplierInvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SupplierInvoiceScalarFieldEnum | SupplierInvoiceScalarFieldEnum[]
  }

  /**
   * PurchaseOrder.disbursements
   */
  export type PurchaseOrder$disbursementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Disbursement
     */
    select?: DisbursementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisbursementInclude<ExtArgs> | null
    where?: DisbursementWhereInput
    orderBy?: DisbursementOrderByWithRelationInput | DisbursementOrderByWithRelationInput[]
    cursor?: DisbursementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DisbursementScalarFieldEnum | DisbursementScalarFieldEnum[]
  }

  /**
   * PurchaseOrder without action
   */
  export type PurchaseOrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
  }


  /**
   * Model PurchaseOrderItem
   */

  export type AggregatePurchaseOrderItem = {
    _count: PurchaseOrderItemCountAggregateOutputType | null
    _avg: PurchaseOrderItemAvgAggregateOutputType | null
    _sum: PurchaseOrderItemSumAggregateOutputType | null
    _min: PurchaseOrderItemMinAggregateOutputType | null
    _max: PurchaseOrderItemMaxAggregateOutputType | null
  }

  export type PurchaseOrderItemAvgAggregateOutputType = {
    id: number | null
    purchaseOrderId: number | null
    quantity: Decimal | null
    unitPrice: Decimal | null
    totalPrice: Decimal | null
  }

  export type PurchaseOrderItemSumAggregateOutputType = {
    id: number | null
    purchaseOrderId: number | null
    quantity: Decimal | null
    unitPrice: Decimal | null
    totalPrice: Decimal | null
  }

  export type PurchaseOrderItemMinAggregateOutputType = {
    id: number | null
    purchaseOrderId: number | null
    materialName: string | null
    description: string | null
    quantity: Decimal | null
    unit: string | null
    unitPrice: Decimal | null
    totalPrice: Decimal | null
  }

  export type PurchaseOrderItemMaxAggregateOutputType = {
    id: number | null
    purchaseOrderId: number | null
    materialName: string | null
    description: string | null
    quantity: Decimal | null
    unit: string | null
    unitPrice: Decimal | null
    totalPrice: Decimal | null
  }

  export type PurchaseOrderItemCountAggregateOutputType = {
    id: number
    purchaseOrderId: number
    materialName: number
    description: number
    quantity: number
    unit: number
    unitPrice: number
    totalPrice: number
    _all: number
  }


  export type PurchaseOrderItemAvgAggregateInputType = {
    id?: true
    purchaseOrderId?: true
    quantity?: true
    unitPrice?: true
    totalPrice?: true
  }

  export type PurchaseOrderItemSumAggregateInputType = {
    id?: true
    purchaseOrderId?: true
    quantity?: true
    unitPrice?: true
    totalPrice?: true
  }

  export type PurchaseOrderItemMinAggregateInputType = {
    id?: true
    purchaseOrderId?: true
    materialName?: true
    description?: true
    quantity?: true
    unit?: true
    unitPrice?: true
    totalPrice?: true
  }

  export type PurchaseOrderItemMaxAggregateInputType = {
    id?: true
    purchaseOrderId?: true
    materialName?: true
    description?: true
    quantity?: true
    unit?: true
    unitPrice?: true
    totalPrice?: true
  }

  export type PurchaseOrderItemCountAggregateInputType = {
    id?: true
    purchaseOrderId?: true
    materialName?: true
    description?: true
    quantity?: true
    unit?: true
    unitPrice?: true
    totalPrice?: true
    _all?: true
  }

  export type PurchaseOrderItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseOrderItem to aggregate.
     */
    where?: PurchaseOrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrderItems to fetch.
     */
    orderBy?: PurchaseOrderItemOrderByWithRelationInput | PurchaseOrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PurchaseOrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PurchaseOrderItems
    **/
    _count?: true | PurchaseOrderItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PurchaseOrderItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PurchaseOrderItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchaseOrderItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchaseOrderItemMaxAggregateInputType
  }

  export type GetPurchaseOrderItemAggregateType<T extends PurchaseOrderItemAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchaseOrderItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchaseOrderItem[P]>
      : GetScalarType<T[P], AggregatePurchaseOrderItem[P]>
  }




  export type PurchaseOrderItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseOrderItemWhereInput
    orderBy?: PurchaseOrderItemOrderByWithAggregationInput | PurchaseOrderItemOrderByWithAggregationInput[]
    by: PurchaseOrderItemScalarFieldEnum[] | PurchaseOrderItemScalarFieldEnum
    having?: PurchaseOrderItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchaseOrderItemCountAggregateInputType | true
    _avg?: PurchaseOrderItemAvgAggregateInputType
    _sum?: PurchaseOrderItemSumAggregateInputType
    _min?: PurchaseOrderItemMinAggregateInputType
    _max?: PurchaseOrderItemMaxAggregateInputType
  }

  export type PurchaseOrderItemGroupByOutputType = {
    id: number
    purchaseOrderId: number
    materialName: string
    description: string | null
    quantity: Decimal
    unit: string
    unitPrice: Decimal
    totalPrice: Decimal
    _count: PurchaseOrderItemCountAggregateOutputType | null
    _avg: PurchaseOrderItemAvgAggregateOutputType | null
    _sum: PurchaseOrderItemSumAggregateOutputType | null
    _min: PurchaseOrderItemMinAggregateOutputType | null
    _max: PurchaseOrderItemMaxAggregateOutputType | null
  }

  type GetPurchaseOrderItemGroupByPayload<T extends PurchaseOrderItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PurchaseOrderItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchaseOrderItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchaseOrderItemGroupByOutputType[P]>
            : GetScalarType<T[P], PurchaseOrderItemGroupByOutputType[P]>
        }
      >
    >


  export type PurchaseOrderItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    purchaseOrderId?: boolean
    materialName?: boolean
    description?: boolean
    quantity?: boolean
    unit?: boolean
    unitPrice?: boolean
    totalPrice?: boolean
    purchaseOrder?: boolean | PurchaseOrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseOrderItem"]>


  export type PurchaseOrderItemSelectScalar = {
    id?: boolean
    purchaseOrderId?: boolean
    materialName?: boolean
    description?: boolean
    quantity?: boolean
    unit?: boolean
    unitPrice?: boolean
    totalPrice?: boolean
  }

  export type PurchaseOrderItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchaseOrder?: boolean | PurchaseOrderDefaultArgs<ExtArgs>
  }

  export type $PurchaseOrderItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PurchaseOrderItem"
    objects: {
      purchaseOrder: Prisma.$PurchaseOrderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      purchaseOrderId: number
      materialName: string
      description: string | null
      quantity: Prisma.Decimal
      unit: string
      unitPrice: Prisma.Decimal
      totalPrice: Prisma.Decimal
    }, ExtArgs["result"]["purchaseOrderItem"]>
    composites: {}
  }

  type PurchaseOrderItemGetPayload<S extends boolean | null | undefined | PurchaseOrderItemDefaultArgs> = $Result.GetResult<Prisma.$PurchaseOrderItemPayload, S>

  type PurchaseOrderItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PurchaseOrderItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PurchaseOrderItemCountAggregateInputType | true
    }

  export interface PurchaseOrderItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PurchaseOrderItem'], meta: { name: 'PurchaseOrderItem' } }
    /**
     * Find zero or one PurchaseOrderItem that matches the filter.
     * @param {PurchaseOrderItemFindUniqueArgs} args - Arguments to find a PurchaseOrderItem
     * @example
     * // Get one PurchaseOrderItem
     * const purchaseOrderItem = await prisma.purchaseOrderItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PurchaseOrderItemFindUniqueArgs>(args: SelectSubset<T, PurchaseOrderItemFindUniqueArgs<ExtArgs>>): Prisma__PurchaseOrderItemClient<$Result.GetResult<Prisma.$PurchaseOrderItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PurchaseOrderItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PurchaseOrderItemFindUniqueOrThrowArgs} args - Arguments to find a PurchaseOrderItem
     * @example
     * // Get one PurchaseOrderItem
     * const purchaseOrderItem = await prisma.purchaseOrderItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PurchaseOrderItemFindUniqueOrThrowArgs>(args: SelectSubset<T, PurchaseOrderItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PurchaseOrderItemClient<$Result.GetResult<Prisma.$PurchaseOrderItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PurchaseOrderItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderItemFindFirstArgs} args - Arguments to find a PurchaseOrderItem
     * @example
     * // Get one PurchaseOrderItem
     * const purchaseOrderItem = await prisma.purchaseOrderItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PurchaseOrderItemFindFirstArgs>(args?: SelectSubset<T, PurchaseOrderItemFindFirstArgs<ExtArgs>>): Prisma__PurchaseOrderItemClient<$Result.GetResult<Prisma.$PurchaseOrderItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PurchaseOrderItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderItemFindFirstOrThrowArgs} args - Arguments to find a PurchaseOrderItem
     * @example
     * // Get one PurchaseOrderItem
     * const purchaseOrderItem = await prisma.purchaseOrderItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PurchaseOrderItemFindFirstOrThrowArgs>(args?: SelectSubset<T, PurchaseOrderItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__PurchaseOrderItemClient<$Result.GetResult<Prisma.$PurchaseOrderItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PurchaseOrderItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PurchaseOrderItems
     * const purchaseOrderItems = await prisma.purchaseOrderItem.findMany()
     * 
     * // Get first 10 PurchaseOrderItems
     * const purchaseOrderItems = await prisma.purchaseOrderItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const purchaseOrderItemWithIdOnly = await prisma.purchaseOrderItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PurchaseOrderItemFindManyArgs>(args?: SelectSubset<T, PurchaseOrderItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PurchaseOrderItem.
     * @param {PurchaseOrderItemCreateArgs} args - Arguments to create a PurchaseOrderItem.
     * @example
     * // Create one PurchaseOrderItem
     * const PurchaseOrderItem = await prisma.purchaseOrderItem.create({
     *   data: {
     *     // ... data to create a PurchaseOrderItem
     *   }
     * })
     * 
     */
    create<T extends PurchaseOrderItemCreateArgs>(args: SelectSubset<T, PurchaseOrderItemCreateArgs<ExtArgs>>): Prisma__PurchaseOrderItemClient<$Result.GetResult<Prisma.$PurchaseOrderItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PurchaseOrderItems.
     * @param {PurchaseOrderItemCreateManyArgs} args - Arguments to create many PurchaseOrderItems.
     * @example
     * // Create many PurchaseOrderItems
     * const purchaseOrderItem = await prisma.purchaseOrderItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PurchaseOrderItemCreateManyArgs>(args?: SelectSubset<T, PurchaseOrderItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PurchaseOrderItem.
     * @param {PurchaseOrderItemDeleteArgs} args - Arguments to delete one PurchaseOrderItem.
     * @example
     * // Delete one PurchaseOrderItem
     * const PurchaseOrderItem = await prisma.purchaseOrderItem.delete({
     *   where: {
     *     // ... filter to delete one PurchaseOrderItem
     *   }
     * })
     * 
     */
    delete<T extends PurchaseOrderItemDeleteArgs>(args: SelectSubset<T, PurchaseOrderItemDeleteArgs<ExtArgs>>): Prisma__PurchaseOrderItemClient<$Result.GetResult<Prisma.$PurchaseOrderItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PurchaseOrderItem.
     * @param {PurchaseOrderItemUpdateArgs} args - Arguments to update one PurchaseOrderItem.
     * @example
     * // Update one PurchaseOrderItem
     * const purchaseOrderItem = await prisma.purchaseOrderItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PurchaseOrderItemUpdateArgs>(args: SelectSubset<T, PurchaseOrderItemUpdateArgs<ExtArgs>>): Prisma__PurchaseOrderItemClient<$Result.GetResult<Prisma.$PurchaseOrderItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PurchaseOrderItems.
     * @param {PurchaseOrderItemDeleteManyArgs} args - Arguments to filter PurchaseOrderItems to delete.
     * @example
     * // Delete a few PurchaseOrderItems
     * const { count } = await prisma.purchaseOrderItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PurchaseOrderItemDeleteManyArgs>(args?: SelectSubset<T, PurchaseOrderItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseOrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PurchaseOrderItems
     * const purchaseOrderItem = await prisma.purchaseOrderItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PurchaseOrderItemUpdateManyArgs>(args: SelectSubset<T, PurchaseOrderItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PurchaseOrderItem.
     * @param {PurchaseOrderItemUpsertArgs} args - Arguments to update or create a PurchaseOrderItem.
     * @example
     * // Update or create a PurchaseOrderItem
     * const purchaseOrderItem = await prisma.purchaseOrderItem.upsert({
     *   create: {
     *     // ... data to create a PurchaseOrderItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PurchaseOrderItem we want to update
     *   }
     * })
     */
    upsert<T extends PurchaseOrderItemUpsertArgs>(args: SelectSubset<T, PurchaseOrderItemUpsertArgs<ExtArgs>>): Prisma__PurchaseOrderItemClient<$Result.GetResult<Prisma.$PurchaseOrderItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PurchaseOrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderItemCountArgs} args - Arguments to filter PurchaseOrderItems to count.
     * @example
     * // Count the number of PurchaseOrderItems
     * const count = await prisma.purchaseOrderItem.count({
     *   where: {
     *     // ... the filter for the PurchaseOrderItems we want to count
     *   }
     * })
    **/
    count<T extends PurchaseOrderItemCountArgs>(
      args?: Subset<T, PurchaseOrderItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchaseOrderItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PurchaseOrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchaseOrderItemAggregateArgs>(args: Subset<T, PurchaseOrderItemAggregateArgs>): Prisma.PrismaPromise<GetPurchaseOrderItemAggregateType<T>>

    /**
     * Group by PurchaseOrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PurchaseOrderItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PurchaseOrderItemGroupByArgs['orderBy'] }
        : { orderBy?: PurchaseOrderItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PurchaseOrderItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchaseOrderItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PurchaseOrderItem model
   */
  readonly fields: PurchaseOrderItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PurchaseOrderItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PurchaseOrderItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    purchaseOrder<T extends PurchaseOrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseOrderDefaultArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PurchaseOrderItem model
   */ 
  interface PurchaseOrderItemFieldRefs {
    readonly id: FieldRef<"PurchaseOrderItem", 'Int'>
    readonly purchaseOrderId: FieldRef<"PurchaseOrderItem", 'Int'>
    readonly materialName: FieldRef<"PurchaseOrderItem", 'String'>
    readonly description: FieldRef<"PurchaseOrderItem", 'String'>
    readonly quantity: FieldRef<"PurchaseOrderItem", 'Decimal'>
    readonly unit: FieldRef<"PurchaseOrderItem", 'String'>
    readonly unitPrice: FieldRef<"PurchaseOrderItem", 'Decimal'>
    readonly totalPrice: FieldRef<"PurchaseOrderItem", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * PurchaseOrderItem findUnique
   */
  export type PurchaseOrderItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderItem
     */
    select?: PurchaseOrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrderItem to fetch.
     */
    where: PurchaseOrderItemWhereUniqueInput
  }

  /**
   * PurchaseOrderItem findUniqueOrThrow
   */
  export type PurchaseOrderItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderItem
     */
    select?: PurchaseOrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrderItem to fetch.
     */
    where: PurchaseOrderItemWhereUniqueInput
  }

  /**
   * PurchaseOrderItem findFirst
   */
  export type PurchaseOrderItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderItem
     */
    select?: PurchaseOrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrderItem to fetch.
     */
    where?: PurchaseOrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrderItems to fetch.
     */
    orderBy?: PurchaseOrderItemOrderByWithRelationInput | PurchaseOrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseOrderItems.
     */
    cursor?: PurchaseOrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseOrderItems.
     */
    distinct?: PurchaseOrderItemScalarFieldEnum | PurchaseOrderItemScalarFieldEnum[]
  }

  /**
   * PurchaseOrderItem findFirstOrThrow
   */
  export type PurchaseOrderItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderItem
     */
    select?: PurchaseOrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrderItem to fetch.
     */
    where?: PurchaseOrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrderItems to fetch.
     */
    orderBy?: PurchaseOrderItemOrderByWithRelationInput | PurchaseOrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseOrderItems.
     */
    cursor?: PurchaseOrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseOrderItems.
     */
    distinct?: PurchaseOrderItemScalarFieldEnum | PurchaseOrderItemScalarFieldEnum[]
  }

  /**
   * PurchaseOrderItem findMany
   */
  export type PurchaseOrderItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderItem
     */
    select?: PurchaseOrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrderItems to fetch.
     */
    where?: PurchaseOrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrderItems to fetch.
     */
    orderBy?: PurchaseOrderItemOrderByWithRelationInput | PurchaseOrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PurchaseOrderItems.
     */
    cursor?: PurchaseOrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrderItems.
     */
    skip?: number
    distinct?: PurchaseOrderItemScalarFieldEnum | PurchaseOrderItemScalarFieldEnum[]
  }

  /**
   * PurchaseOrderItem create
   */
  export type PurchaseOrderItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderItem
     */
    select?: PurchaseOrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderItemInclude<ExtArgs> | null
    /**
     * The data needed to create a PurchaseOrderItem.
     */
    data: XOR<PurchaseOrderItemCreateInput, PurchaseOrderItemUncheckedCreateInput>
  }

  /**
   * PurchaseOrderItem createMany
   */
  export type PurchaseOrderItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PurchaseOrderItems.
     */
    data: PurchaseOrderItemCreateManyInput | PurchaseOrderItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PurchaseOrderItem update
   */
  export type PurchaseOrderItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderItem
     */
    select?: PurchaseOrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderItemInclude<ExtArgs> | null
    /**
     * The data needed to update a PurchaseOrderItem.
     */
    data: XOR<PurchaseOrderItemUpdateInput, PurchaseOrderItemUncheckedUpdateInput>
    /**
     * Choose, which PurchaseOrderItem to update.
     */
    where: PurchaseOrderItemWhereUniqueInput
  }

  /**
   * PurchaseOrderItem updateMany
   */
  export type PurchaseOrderItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PurchaseOrderItems.
     */
    data: XOR<PurchaseOrderItemUpdateManyMutationInput, PurchaseOrderItemUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseOrderItems to update
     */
    where?: PurchaseOrderItemWhereInput
  }

  /**
   * PurchaseOrderItem upsert
   */
  export type PurchaseOrderItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderItem
     */
    select?: PurchaseOrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderItemInclude<ExtArgs> | null
    /**
     * The filter to search for the PurchaseOrderItem to update in case it exists.
     */
    where: PurchaseOrderItemWhereUniqueInput
    /**
     * In case the PurchaseOrderItem found by the `where` argument doesn't exist, create a new PurchaseOrderItem with this data.
     */
    create: XOR<PurchaseOrderItemCreateInput, PurchaseOrderItemUncheckedCreateInput>
    /**
     * In case the PurchaseOrderItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PurchaseOrderItemUpdateInput, PurchaseOrderItemUncheckedUpdateInput>
  }

  /**
   * PurchaseOrderItem delete
   */
  export type PurchaseOrderItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderItem
     */
    select?: PurchaseOrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderItemInclude<ExtArgs> | null
    /**
     * Filter which PurchaseOrderItem to delete.
     */
    where: PurchaseOrderItemWhereUniqueInput
  }

  /**
   * PurchaseOrderItem deleteMany
   */
  export type PurchaseOrderItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseOrderItems to delete
     */
    where?: PurchaseOrderItemWhereInput
  }

  /**
   * PurchaseOrderItem without action
   */
  export type PurchaseOrderItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderItem
     */
    select?: PurchaseOrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderItemInclude<ExtArgs> | null
  }


  /**
   * Model ReceivingReport
   */

  export type AggregateReceivingReport = {
    _count: ReceivingReportCountAggregateOutputType | null
    _avg: ReceivingReportAvgAggregateOutputType | null
    _sum: ReceivingReportSumAggregateOutputType | null
    _min: ReceivingReportMinAggregateOutputType | null
    _max: ReceivingReportMaxAggregateOutputType | null
  }

  export type ReceivingReportAvgAggregateOutputType = {
    id: number | null
    purchaseOrderId: number | null
    receivedById: number | null
  }

  export type ReceivingReportSumAggregateOutputType = {
    id: number | null
    purchaseOrderId: number | null
    receivedById: number | null
  }

  export type ReceivingReportMinAggregateOutputType = {
    id: number | null
    purchaseOrderId: number | null
    receivedById: number | null
    receivedDate: Date | null
    deliveryNoteNo: string | null
    notes: string | null
  }

  export type ReceivingReportMaxAggregateOutputType = {
    id: number | null
    purchaseOrderId: number | null
    receivedById: number | null
    receivedDate: Date | null
    deliveryNoteNo: string | null
    notes: string | null
  }

  export type ReceivingReportCountAggregateOutputType = {
    id: number
    purchaseOrderId: number
    receivedById: number
    receivedDate: number
    deliveryNoteNo: number
    notes: number
    _all: number
  }


  export type ReceivingReportAvgAggregateInputType = {
    id?: true
    purchaseOrderId?: true
    receivedById?: true
  }

  export type ReceivingReportSumAggregateInputType = {
    id?: true
    purchaseOrderId?: true
    receivedById?: true
  }

  export type ReceivingReportMinAggregateInputType = {
    id?: true
    purchaseOrderId?: true
    receivedById?: true
    receivedDate?: true
    deliveryNoteNo?: true
    notes?: true
  }

  export type ReceivingReportMaxAggregateInputType = {
    id?: true
    purchaseOrderId?: true
    receivedById?: true
    receivedDate?: true
    deliveryNoteNo?: true
    notes?: true
  }

  export type ReceivingReportCountAggregateInputType = {
    id?: true
    purchaseOrderId?: true
    receivedById?: true
    receivedDate?: true
    deliveryNoteNo?: true
    notes?: true
    _all?: true
  }

  export type ReceivingReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReceivingReport to aggregate.
     */
    where?: ReceivingReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReceivingReports to fetch.
     */
    orderBy?: ReceivingReportOrderByWithRelationInput | ReceivingReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReceivingReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReceivingReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReceivingReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReceivingReports
    **/
    _count?: true | ReceivingReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReceivingReportAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReceivingReportSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReceivingReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReceivingReportMaxAggregateInputType
  }

  export type GetReceivingReportAggregateType<T extends ReceivingReportAggregateArgs> = {
        [P in keyof T & keyof AggregateReceivingReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReceivingReport[P]>
      : GetScalarType<T[P], AggregateReceivingReport[P]>
  }




  export type ReceivingReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReceivingReportWhereInput
    orderBy?: ReceivingReportOrderByWithAggregationInput | ReceivingReportOrderByWithAggregationInput[]
    by: ReceivingReportScalarFieldEnum[] | ReceivingReportScalarFieldEnum
    having?: ReceivingReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReceivingReportCountAggregateInputType | true
    _avg?: ReceivingReportAvgAggregateInputType
    _sum?: ReceivingReportSumAggregateInputType
    _min?: ReceivingReportMinAggregateInputType
    _max?: ReceivingReportMaxAggregateInputType
  }

  export type ReceivingReportGroupByOutputType = {
    id: number
    purchaseOrderId: number
    receivedById: number
    receivedDate: Date
    deliveryNoteNo: string | null
    notes: string | null
    _count: ReceivingReportCountAggregateOutputType | null
    _avg: ReceivingReportAvgAggregateOutputType | null
    _sum: ReceivingReportSumAggregateOutputType | null
    _min: ReceivingReportMinAggregateOutputType | null
    _max: ReceivingReportMaxAggregateOutputType | null
  }

  type GetReceivingReportGroupByPayload<T extends ReceivingReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReceivingReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReceivingReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReceivingReportGroupByOutputType[P]>
            : GetScalarType<T[P], ReceivingReportGroupByOutputType[P]>
        }
      >
    >


  export type ReceivingReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    purchaseOrderId?: boolean
    receivedById?: boolean
    receivedDate?: boolean
    deliveryNoteNo?: boolean
    notes?: boolean
    purchaseOrder?: boolean | PurchaseOrderDefaultArgs<ExtArgs>
    receivedBy?: boolean | UserDefaultArgs<ExtArgs>
    items?: boolean | ReceivingReport$itemsArgs<ExtArgs>
    invoices?: boolean | ReceivingReport$invoicesArgs<ExtArgs>
    _count?: boolean | ReceivingReportCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["receivingReport"]>


  export type ReceivingReportSelectScalar = {
    id?: boolean
    purchaseOrderId?: boolean
    receivedById?: boolean
    receivedDate?: boolean
    deliveryNoteNo?: boolean
    notes?: boolean
  }

  export type ReceivingReportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchaseOrder?: boolean | PurchaseOrderDefaultArgs<ExtArgs>
    receivedBy?: boolean | UserDefaultArgs<ExtArgs>
    items?: boolean | ReceivingReport$itemsArgs<ExtArgs>
    invoices?: boolean | ReceivingReport$invoicesArgs<ExtArgs>
    _count?: boolean | ReceivingReportCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ReceivingReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReceivingReport"
    objects: {
      purchaseOrder: Prisma.$PurchaseOrderPayload<ExtArgs>
      receivedBy: Prisma.$UserPayload<ExtArgs>
      items: Prisma.$ReceivingItemPayload<ExtArgs>[]
      invoices: Prisma.$SupplierInvoicePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      purchaseOrderId: number
      receivedById: number
      receivedDate: Date
      deliveryNoteNo: string | null
      notes: string | null
    }, ExtArgs["result"]["receivingReport"]>
    composites: {}
  }

  type ReceivingReportGetPayload<S extends boolean | null | undefined | ReceivingReportDefaultArgs> = $Result.GetResult<Prisma.$ReceivingReportPayload, S>

  type ReceivingReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReceivingReportFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReceivingReportCountAggregateInputType | true
    }

  export interface ReceivingReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReceivingReport'], meta: { name: 'ReceivingReport' } }
    /**
     * Find zero or one ReceivingReport that matches the filter.
     * @param {ReceivingReportFindUniqueArgs} args - Arguments to find a ReceivingReport
     * @example
     * // Get one ReceivingReport
     * const receivingReport = await prisma.receivingReport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReceivingReportFindUniqueArgs>(args: SelectSubset<T, ReceivingReportFindUniqueArgs<ExtArgs>>): Prisma__ReceivingReportClient<$Result.GetResult<Prisma.$ReceivingReportPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ReceivingReport that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ReceivingReportFindUniqueOrThrowArgs} args - Arguments to find a ReceivingReport
     * @example
     * // Get one ReceivingReport
     * const receivingReport = await prisma.receivingReport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReceivingReportFindUniqueOrThrowArgs>(args: SelectSubset<T, ReceivingReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReceivingReportClient<$Result.GetResult<Prisma.$ReceivingReportPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ReceivingReport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceivingReportFindFirstArgs} args - Arguments to find a ReceivingReport
     * @example
     * // Get one ReceivingReport
     * const receivingReport = await prisma.receivingReport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReceivingReportFindFirstArgs>(args?: SelectSubset<T, ReceivingReportFindFirstArgs<ExtArgs>>): Prisma__ReceivingReportClient<$Result.GetResult<Prisma.$ReceivingReportPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ReceivingReport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceivingReportFindFirstOrThrowArgs} args - Arguments to find a ReceivingReport
     * @example
     * // Get one ReceivingReport
     * const receivingReport = await prisma.receivingReport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReceivingReportFindFirstOrThrowArgs>(args?: SelectSubset<T, ReceivingReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReceivingReportClient<$Result.GetResult<Prisma.$ReceivingReportPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ReceivingReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceivingReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReceivingReports
     * const receivingReports = await prisma.receivingReport.findMany()
     * 
     * // Get first 10 ReceivingReports
     * const receivingReports = await prisma.receivingReport.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const receivingReportWithIdOnly = await prisma.receivingReport.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReceivingReportFindManyArgs>(args?: SelectSubset<T, ReceivingReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReceivingReportPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ReceivingReport.
     * @param {ReceivingReportCreateArgs} args - Arguments to create a ReceivingReport.
     * @example
     * // Create one ReceivingReport
     * const ReceivingReport = await prisma.receivingReport.create({
     *   data: {
     *     // ... data to create a ReceivingReport
     *   }
     * })
     * 
     */
    create<T extends ReceivingReportCreateArgs>(args: SelectSubset<T, ReceivingReportCreateArgs<ExtArgs>>): Prisma__ReceivingReportClient<$Result.GetResult<Prisma.$ReceivingReportPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ReceivingReports.
     * @param {ReceivingReportCreateManyArgs} args - Arguments to create many ReceivingReports.
     * @example
     * // Create many ReceivingReports
     * const receivingReport = await prisma.receivingReport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReceivingReportCreateManyArgs>(args?: SelectSubset<T, ReceivingReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ReceivingReport.
     * @param {ReceivingReportDeleteArgs} args - Arguments to delete one ReceivingReport.
     * @example
     * // Delete one ReceivingReport
     * const ReceivingReport = await prisma.receivingReport.delete({
     *   where: {
     *     // ... filter to delete one ReceivingReport
     *   }
     * })
     * 
     */
    delete<T extends ReceivingReportDeleteArgs>(args: SelectSubset<T, ReceivingReportDeleteArgs<ExtArgs>>): Prisma__ReceivingReportClient<$Result.GetResult<Prisma.$ReceivingReportPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ReceivingReport.
     * @param {ReceivingReportUpdateArgs} args - Arguments to update one ReceivingReport.
     * @example
     * // Update one ReceivingReport
     * const receivingReport = await prisma.receivingReport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReceivingReportUpdateArgs>(args: SelectSubset<T, ReceivingReportUpdateArgs<ExtArgs>>): Prisma__ReceivingReportClient<$Result.GetResult<Prisma.$ReceivingReportPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ReceivingReports.
     * @param {ReceivingReportDeleteManyArgs} args - Arguments to filter ReceivingReports to delete.
     * @example
     * // Delete a few ReceivingReports
     * const { count } = await prisma.receivingReport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReceivingReportDeleteManyArgs>(args?: SelectSubset<T, ReceivingReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReceivingReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceivingReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReceivingReports
     * const receivingReport = await prisma.receivingReport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReceivingReportUpdateManyArgs>(args: SelectSubset<T, ReceivingReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ReceivingReport.
     * @param {ReceivingReportUpsertArgs} args - Arguments to update or create a ReceivingReport.
     * @example
     * // Update or create a ReceivingReport
     * const receivingReport = await prisma.receivingReport.upsert({
     *   create: {
     *     // ... data to create a ReceivingReport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReceivingReport we want to update
     *   }
     * })
     */
    upsert<T extends ReceivingReportUpsertArgs>(args: SelectSubset<T, ReceivingReportUpsertArgs<ExtArgs>>): Prisma__ReceivingReportClient<$Result.GetResult<Prisma.$ReceivingReportPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ReceivingReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceivingReportCountArgs} args - Arguments to filter ReceivingReports to count.
     * @example
     * // Count the number of ReceivingReports
     * const count = await prisma.receivingReport.count({
     *   where: {
     *     // ... the filter for the ReceivingReports we want to count
     *   }
     * })
    **/
    count<T extends ReceivingReportCountArgs>(
      args?: Subset<T, ReceivingReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReceivingReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReceivingReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceivingReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReceivingReportAggregateArgs>(args: Subset<T, ReceivingReportAggregateArgs>): Prisma.PrismaPromise<GetReceivingReportAggregateType<T>>

    /**
     * Group by ReceivingReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceivingReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReceivingReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReceivingReportGroupByArgs['orderBy'] }
        : { orderBy?: ReceivingReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReceivingReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReceivingReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReceivingReport model
   */
  readonly fields: ReceivingReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReceivingReport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReceivingReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    purchaseOrder<T extends PurchaseOrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseOrderDefaultArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    receivedBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    items<T extends ReceivingReport$itemsArgs<ExtArgs> = {}>(args?: Subset<T, ReceivingReport$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReceivingItemPayload<ExtArgs>, T, "findMany"> | Null>
    invoices<T extends ReceivingReport$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, ReceivingReport$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierInvoicePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReceivingReport model
   */ 
  interface ReceivingReportFieldRefs {
    readonly id: FieldRef<"ReceivingReport", 'Int'>
    readonly purchaseOrderId: FieldRef<"ReceivingReport", 'Int'>
    readonly receivedById: FieldRef<"ReceivingReport", 'Int'>
    readonly receivedDate: FieldRef<"ReceivingReport", 'DateTime'>
    readonly deliveryNoteNo: FieldRef<"ReceivingReport", 'String'>
    readonly notes: FieldRef<"ReceivingReport", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ReceivingReport findUnique
   */
  export type ReceivingReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceivingReport
     */
    select?: ReceivingReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceivingReportInclude<ExtArgs> | null
    /**
     * Filter, which ReceivingReport to fetch.
     */
    where: ReceivingReportWhereUniqueInput
  }

  /**
   * ReceivingReport findUniqueOrThrow
   */
  export type ReceivingReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceivingReport
     */
    select?: ReceivingReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceivingReportInclude<ExtArgs> | null
    /**
     * Filter, which ReceivingReport to fetch.
     */
    where: ReceivingReportWhereUniqueInput
  }

  /**
   * ReceivingReport findFirst
   */
  export type ReceivingReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceivingReport
     */
    select?: ReceivingReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceivingReportInclude<ExtArgs> | null
    /**
     * Filter, which ReceivingReport to fetch.
     */
    where?: ReceivingReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReceivingReports to fetch.
     */
    orderBy?: ReceivingReportOrderByWithRelationInput | ReceivingReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReceivingReports.
     */
    cursor?: ReceivingReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReceivingReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReceivingReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReceivingReports.
     */
    distinct?: ReceivingReportScalarFieldEnum | ReceivingReportScalarFieldEnum[]
  }

  /**
   * ReceivingReport findFirstOrThrow
   */
  export type ReceivingReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceivingReport
     */
    select?: ReceivingReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceivingReportInclude<ExtArgs> | null
    /**
     * Filter, which ReceivingReport to fetch.
     */
    where?: ReceivingReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReceivingReports to fetch.
     */
    orderBy?: ReceivingReportOrderByWithRelationInput | ReceivingReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReceivingReports.
     */
    cursor?: ReceivingReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReceivingReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReceivingReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReceivingReports.
     */
    distinct?: ReceivingReportScalarFieldEnum | ReceivingReportScalarFieldEnum[]
  }

  /**
   * ReceivingReport findMany
   */
  export type ReceivingReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceivingReport
     */
    select?: ReceivingReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceivingReportInclude<ExtArgs> | null
    /**
     * Filter, which ReceivingReports to fetch.
     */
    where?: ReceivingReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReceivingReports to fetch.
     */
    orderBy?: ReceivingReportOrderByWithRelationInput | ReceivingReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReceivingReports.
     */
    cursor?: ReceivingReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReceivingReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReceivingReports.
     */
    skip?: number
    distinct?: ReceivingReportScalarFieldEnum | ReceivingReportScalarFieldEnum[]
  }

  /**
   * ReceivingReport create
   */
  export type ReceivingReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceivingReport
     */
    select?: ReceivingReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceivingReportInclude<ExtArgs> | null
    /**
     * The data needed to create a ReceivingReport.
     */
    data: XOR<ReceivingReportCreateInput, ReceivingReportUncheckedCreateInput>
  }

  /**
   * ReceivingReport createMany
   */
  export type ReceivingReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReceivingReports.
     */
    data: ReceivingReportCreateManyInput | ReceivingReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReceivingReport update
   */
  export type ReceivingReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceivingReport
     */
    select?: ReceivingReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceivingReportInclude<ExtArgs> | null
    /**
     * The data needed to update a ReceivingReport.
     */
    data: XOR<ReceivingReportUpdateInput, ReceivingReportUncheckedUpdateInput>
    /**
     * Choose, which ReceivingReport to update.
     */
    where: ReceivingReportWhereUniqueInput
  }

  /**
   * ReceivingReport updateMany
   */
  export type ReceivingReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReceivingReports.
     */
    data: XOR<ReceivingReportUpdateManyMutationInput, ReceivingReportUncheckedUpdateManyInput>
    /**
     * Filter which ReceivingReports to update
     */
    where?: ReceivingReportWhereInput
  }

  /**
   * ReceivingReport upsert
   */
  export type ReceivingReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceivingReport
     */
    select?: ReceivingReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceivingReportInclude<ExtArgs> | null
    /**
     * The filter to search for the ReceivingReport to update in case it exists.
     */
    where: ReceivingReportWhereUniqueInput
    /**
     * In case the ReceivingReport found by the `where` argument doesn't exist, create a new ReceivingReport with this data.
     */
    create: XOR<ReceivingReportCreateInput, ReceivingReportUncheckedCreateInput>
    /**
     * In case the ReceivingReport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReceivingReportUpdateInput, ReceivingReportUncheckedUpdateInput>
  }

  /**
   * ReceivingReport delete
   */
  export type ReceivingReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceivingReport
     */
    select?: ReceivingReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceivingReportInclude<ExtArgs> | null
    /**
     * Filter which ReceivingReport to delete.
     */
    where: ReceivingReportWhereUniqueInput
  }

  /**
   * ReceivingReport deleteMany
   */
  export type ReceivingReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReceivingReports to delete
     */
    where?: ReceivingReportWhereInput
  }

  /**
   * ReceivingReport.items
   */
  export type ReceivingReport$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceivingItem
     */
    select?: ReceivingItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceivingItemInclude<ExtArgs> | null
    where?: ReceivingItemWhereInput
    orderBy?: ReceivingItemOrderByWithRelationInput | ReceivingItemOrderByWithRelationInput[]
    cursor?: ReceivingItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReceivingItemScalarFieldEnum | ReceivingItemScalarFieldEnum[]
  }

  /**
   * ReceivingReport.invoices
   */
  export type ReceivingReport$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierInvoice
     */
    select?: SupplierInvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInvoiceInclude<ExtArgs> | null
    where?: SupplierInvoiceWhereInput
    orderBy?: SupplierInvoiceOrderByWithRelationInput | SupplierInvoiceOrderByWithRelationInput[]
    cursor?: SupplierInvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SupplierInvoiceScalarFieldEnum | SupplierInvoiceScalarFieldEnum[]
  }

  /**
   * ReceivingReport without action
   */
  export type ReceivingReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceivingReport
     */
    select?: ReceivingReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceivingReportInclude<ExtArgs> | null
  }


  /**
   * Model ReceivingItem
   */

  export type AggregateReceivingItem = {
    _count: ReceivingItemCountAggregateOutputType | null
    _avg: ReceivingItemAvgAggregateOutputType | null
    _sum: ReceivingItemSumAggregateOutputType | null
    _min: ReceivingItemMinAggregateOutputType | null
    _max: ReceivingItemMaxAggregateOutputType | null
  }

  export type ReceivingItemAvgAggregateOutputType = {
    id: number | null
    receivingReportId: number | null
    quantityReceived: Decimal | null
  }

  export type ReceivingItemSumAggregateOutputType = {
    id: number | null
    receivingReportId: number | null
    quantityReceived: Decimal | null
  }

  export type ReceivingItemMinAggregateOutputType = {
    id: number | null
    receivingReportId: number | null
    materialName: string | null
    quantityReceived: Decimal | null
    status: string | null
  }

  export type ReceivingItemMaxAggregateOutputType = {
    id: number | null
    receivingReportId: number | null
    materialName: string | null
    quantityReceived: Decimal | null
    status: string | null
  }

  export type ReceivingItemCountAggregateOutputType = {
    id: number
    receivingReportId: number
    materialName: number
    quantityReceived: number
    status: number
    _all: number
  }


  export type ReceivingItemAvgAggregateInputType = {
    id?: true
    receivingReportId?: true
    quantityReceived?: true
  }

  export type ReceivingItemSumAggregateInputType = {
    id?: true
    receivingReportId?: true
    quantityReceived?: true
  }

  export type ReceivingItemMinAggregateInputType = {
    id?: true
    receivingReportId?: true
    materialName?: true
    quantityReceived?: true
    status?: true
  }

  export type ReceivingItemMaxAggregateInputType = {
    id?: true
    receivingReportId?: true
    materialName?: true
    quantityReceived?: true
    status?: true
  }

  export type ReceivingItemCountAggregateInputType = {
    id?: true
    receivingReportId?: true
    materialName?: true
    quantityReceived?: true
    status?: true
    _all?: true
  }

  export type ReceivingItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReceivingItem to aggregate.
     */
    where?: ReceivingItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReceivingItems to fetch.
     */
    orderBy?: ReceivingItemOrderByWithRelationInput | ReceivingItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReceivingItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReceivingItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReceivingItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReceivingItems
    **/
    _count?: true | ReceivingItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReceivingItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReceivingItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReceivingItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReceivingItemMaxAggregateInputType
  }

  export type GetReceivingItemAggregateType<T extends ReceivingItemAggregateArgs> = {
        [P in keyof T & keyof AggregateReceivingItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReceivingItem[P]>
      : GetScalarType<T[P], AggregateReceivingItem[P]>
  }




  export type ReceivingItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReceivingItemWhereInput
    orderBy?: ReceivingItemOrderByWithAggregationInput | ReceivingItemOrderByWithAggregationInput[]
    by: ReceivingItemScalarFieldEnum[] | ReceivingItemScalarFieldEnum
    having?: ReceivingItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReceivingItemCountAggregateInputType | true
    _avg?: ReceivingItemAvgAggregateInputType
    _sum?: ReceivingItemSumAggregateInputType
    _min?: ReceivingItemMinAggregateInputType
    _max?: ReceivingItemMaxAggregateInputType
  }

  export type ReceivingItemGroupByOutputType = {
    id: number
    receivingReportId: number
    materialName: string
    quantityReceived: Decimal
    status: string
    _count: ReceivingItemCountAggregateOutputType | null
    _avg: ReceivingItemAvgAggregateOutputType | null
    _sum: ReceivingItemSumAggregateOutputType | null
    _min: ReceivingItemMinAggregateOutputType | null
    _max: ReceivingItemMaxAggregateOutputType | null
  }

  type GetReceivingItemGroupByPayload<T extends ReceivingItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReceivingItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReceivingItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReceivingItemGroupByOutputType[P]>
            : GetScalarType<T[P], ReceivingItemGroupByOutputType[P]>
        }
      >
    >


  export type ReceivingItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    receivingReportId?: boolean
    materialName?: boolean
    quantityReceived?: boolean
    status?: boolean
    receivingReport?: boolean | ReceivingReportDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["receivingItem"]>


  export type ReceivingItemSelectScalar = {
    id?: boolean
    receivingReportId?: boolean
    materialName?: boolean
    quantityReceived?: boolean
    status?: boolean
  }

  export type ReceivingItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    receivingReport?: boolean | ReceivingReportDefaultArgs<ExtArgs>
  }

  export type $ReceivingItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReceivingItem"
    objects: {
      receivingReport: Prisma.$ReceivingReportPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      receivingReportId: number
      materialName: string
      quantityReceived: Prisma.Decimal
      status: string
    }, ExtArgs["result"]["receivingItem"]>
    composites: {}
  }

  type ReceivingItemGetPayload<S extends boolean | null | undefined | ReceivingItemDefaultArgs> = $Result.GetResult<Prisma.$ReceivingItemPayload, S>

  type ReceivingItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReceivingItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReceivingItemCountAggregateInputType | true
    }

  export interface ReceivingItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReceivingItem'], meta: { name: 'ReceivingItem' } }
    /**
     * Find zero or one ReceivingItem that matches the filter.
     * @param {ReceivingItemFindUniqueArgs} args - Arguments to find a ReceivingItem
     * @example
     * // Get one ReceivingItem
     * const receivingItem = await prisma.receivingItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReceivingItemFindUniqueArgs>(args: SelectSubset<T, ReceivingItemFindUniqueArgs<ExtArgs>>): Prisma__ReceivingItemClient<$Result.GetResult<Prisma.$ReceivingItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ReceivingItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ReceivingItemFindUniqueOrThrowArgs} args - Arguments to find a ReceivingItem
     * @example
     * // Get one ReceivingItem
     * const receivingItem = await prisma.receivingItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReceivingItemFindUniqueOrThrowArgs>(args: SelectSubset<T, ReceivingItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReceivingItemClient<$Result.GetResult<Prisma.$ReceivingItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ReceivingItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceivingItemFindFirstArgs} args - Arguments to find a ReceivingItem
     * @example
     * // Get one ReceivingItem
     * const receivingItem = await prisma.receivingItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReceivingItemFindFirstArgs>(args?: SelectSubset<T, ReceivingItemFindFirstArgs<ExtArgs>>): Prisma__ReceivingItemClient<$Result.GetResult<Prisma.$ReceivingItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ReceivingItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceivingItemFindFirstOrThrowArgs} args - Arguments to find a ReceivingItem
     * @example
     * // Get one ReceivingItem
     * const receivingItem = await prisma.receivingItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReceivingItemFindFirstOrThrowArgs>(args?: SelectSubset<T, ReceivingItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReceivingItemClient<$Result.GetResult<Prisma.$ReceivingItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ReceivingItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceivingItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReceivingItems
     * const receivingItems = await prisma.receivingItem.findMany()
     * 
     * // Get first 10 ReceivingItems
     * const receivingItems = await prisma.receivingItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const receivingItemWithIdOnly = await prisma.receivingItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReceivingItemFindManyArgs>(args?: SelectSubset<T, ReceivingItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReceivingItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ReceivingItem.
     * @param {ReceivingItemCreateArgs} args - Arguments to create a ReceivingItem.
     * @example
     * // Create one ReceivingItem
     * const ReceivingItem = await prisma.receivingItem.create({
     *   data: {
     *     // ... data to create a ReceivingItem
     *   }
     * })
     * 
     */
    create<T extends ReceivingItemCreateArgs>(args: SelectSubset<T, ReceivingItemCreateArgs<ExtArgs>>): Prisma__ReceivingItemClient<$Result.GetResult<Prisma.$ReceivingItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ReceivingItems.
     * @param {ReceivingItemCreateManyArgs} args - Arguments to create many ReceivingItems.
     * @example
     * // Create many ReceivingItems
     * const receivingItem = await prisma.receivingItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReceivingItemCreateManyArgs>(args?: SelectSubset<T, ReceivingItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ReceivingItem.
     * @param {ReceivingItemDeleteArgs} args - Arguments to delete one ReceivingItem.
     * @example
     * // Delete one ReceivingItem
     * const ReceivingItem = await prisma.receivingItem.delete({
     *   where: {
     *     // ... filter to delete one ReceivingItem
     *   }
     * })
     * 
     */
    delete<T extends ReceivingItemDeleteArgs>(args: SelectSubset<T, ReceivingItemDeleteArgs<ExtArgs>>): Prisma__ReceivingItemClient<$Result.GetResult<Prisma.$ReceivingItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ReceivingItem.
     * @param {ReceivingItemUpdateArgs} args - Arguments to update one ReceivingItem.
     * @example
     * // Update one ReceivingItem
     * const receivingItem = await prisma.receivingItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReceivingItemUpdateArgs>(args: SelectSubset<T, ReceivingItemUpdateArgs<ExtArgs>>): Prisma__ReceivingItemClient<$Result.GetResult<Prisma.$ReceivingItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ReceivingItems.
     * @param {ReceivingItemDeleteManyArgs} args - Arguments to filter ReceivingItems to delete.
     * @example
     * // Delete a few ReceivingItems
     * const { count } = await prisma.receivingItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReceivingItemDeleteManyArgs>(args?: SelectSubset<T, ReceivingItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReceivingItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceivingItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReceivingItems
     * const receivingItem = await prisma.receivingItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReceivingItemUpdateManyArgs>(args: SelectSubset<T, ReceivingItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ReceivingItem.
     * @param {ReceivingItemUpsertArgs} args - Arguments to update or create a ReceivingItem.
     * @example
     * // Update or create a ReceivingItem
     * const receivingItem = await prisma.receivingItem.upsert({
     *   create: {
     *     // ... data to create a ReceivingItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReceivingItem we want to update
     *   }
     * })
     */
    upsert<T extends ReceivingItemUpsertArgs>(args: SelectSubset<T, ReceivingItemUpsertArgs<ExtArgs>>): Prisma__ReceivingItemClient<$Result.GetResult<Prisma.$ReceivingItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ReceivingItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceivingItemCountArgs} args - Arguments to filter ReceivingItems to count.
     * @example
     * // Count the number of ReceivingItems
     * const count = await prisma.receivingItem.count({
     *   where: {
     *     // ... the filter for the ReceivingItems we want to count
     *   }
     * })
    **/
    count<T extends ReceivingItemCountArgs>(
      args?: Subset<T, ReceivingItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReceivingItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReceivingItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceivingItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReceivingItemAggregateArgs>(args: Subset<T, ReceivingItemAggregateArgs>): Prisma.PrismaPromise<GetReceivingItemAggregateType<T>>

    /**
     * Group by ReceivingItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceivingItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReceivingItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReceivingItemGroupByArgs['orderBy'] }
        : { orderBy?: ReceivingItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReceivingItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReceivingItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReceivingItem model
   */
  readonly fields: ReceivingItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReceivingItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReceivingItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    receivingReport<T extends ReceivingReportDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ReceivingReportDefaultArgs<ExtArgs>>): Prisma__ReceivingReportClient<$Result.GetResult<Prisma.$ReceivingReportPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReceivingItem model
   */ 
  interface ReceivingItemFieldRefs {
    readonly id: FieldRef<"ReceivingItem", 'Int'>
    readonly receivingReportId: FieldRef<"ReceivingItem", 'Int'>
    readonly materialName: FieldRef<"ReceivingItem", 'String'>
    readonly quantityReceived: FieldRef<"ReceivingItem", 'Decimal'>
    readonly status: FieldRef<"ReceivingItem", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ReceivingItem findUnique
   */
  export type ReceivingItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceivingItem
     */
    select?: ReceivingItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceivingItemInclude<ExtArgs> | null
    /**
     * Filter, which ReceivingItem to fetch.
     */
    where: ReceivingItemWhereUniqueInput
  }

  /**
   * ReceivingItem findUniqueOrThrow
   */
  export type ReceivingItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceivingItem
     */
    select?: ReceivingItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceivingItemInclude<ExtArgs> | null
    /**
     * Filter, which ReceivingItem to fetch.
     */
    where: ReceivingItemWhereUniqueInput
  }

  /**
   * ReceivingItem findFirst
   */
  export type ReceivingItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceivingItem
     */
    select?: ReceivingItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceivingItemInclude<ExtArgs> | null
    /**
     * Filter, which ReceivingItem to fetch.
     */
    where?: ReceivingItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReceivingItems to fetch.
     */
    orderBy?: ReceivingItemOrderByWithRelationInput | ReceivingItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReceivingItems.
     */
    cursor?: ReceivingItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReceivingItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReceivingItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReceivingItems.
     */
    distinct?: ReceivingItemScalarFieldEnum | ReceivingItemScalarFieldEnum[]
  }

  /**
   * ReceivingItem findFirstOrThrow
   */
  export type ReceivingItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceivingItem
     */
    select?: ReceivingItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceivingItemInclude<ExtArgs> | null
    /**
     * Filter, which ReceivingItem to fetch.
     */
    where?: ReceivingItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReceivingItems to fetch.
     */
    orderBy?: ReceivingItemOrderByWithRelationInput | ReceivingItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReceivingItems.
     */
    cursor?: ReceivingItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReceivingItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReceivingItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReceivingItems.
     */
    distinct?: ReceivingItemScalarFieldEnum | ReceivingItemScalarFieldEnum[]
  }

  /**
   * ReceivingItem findMany
   */
  export type ReceivingItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceivingItem
     */
    select?: ReceivingItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceivingItemInclude<ExtArgs> | null
    /**
     * Filter, which ReceivingItems to fetch.
     */
    where?: ReceivingItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReceivingItems to fetch.
     */
    orderBy?: ReceivingItemOrderByWithRelationInput | ReceivingItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReceivingItems.
     */
    cursor?: ReceivingItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReceivingItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReceivingItems.
     */
    skip?: number
    distinct?: ReceivingItemScalarFieldEnum | ReceivingItemScalarFieldEnum[]
  }

  /**
   * ReceivingItem create
   */
  export type ReceivingItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceivingItem
     */
    select?: ReceivingItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceivingItemInclude<ExtArgs> | null
    /**
     * The data needed to create a ReceivingItem.
     */
    data: XOR<ReceivingItemCreateInput, ReceivingItemUncheckedCreateInput>
  }

  /**
   * ReceivingItem createMany
   */
  export type ReceivingItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReceivingItems.
     */
    data: ReceivingItemCreateManyInput | ReceivingItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReceivingItem update
   */
  export type ReceivingItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceivingItem
     */
    select?: ReceivingItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceivingItemInclude<ExtArgs> | null
    /**
     * The data needed to update a ReceivingItem.
     */
    data: XOR<ReceivingItemUpdateInput, ReceivingItemUncheckedUpdateInput>
    /**
     * Choose, which ReceivingItem to update.
     */
    where: ReceivingItemWhereUniqueInput
  }

  /**
   * ReceivingItem updateMany
   */
  export type ReceivingItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReceivingItems.
     */
    data: XOR<ReceivingItemUpdateManyMutationInput, ReceivingItemUncheckedUpdateManyInput>
    /**
     * Filter which ReceivingItems to update
     */
    where?: ReceivingItemWhereInput
  }

  /**
   * ReceivingItem upsert
   */
  export type ReceivingItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceivingItem
     */
    select?: ReceivingItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceivingItemInclude<ExtArgs> | null
    /**
     * The filter to search for the ReceivingItem to update in case it exists.
     */
    where: ReceivingItemWhereUniqueInput
    /**
     * In case the ReceivingItem found by the `where` argument doesn't exist, create a new ReceivingItem with this data.
     */
    create: XOR<ReceivingItemCreateInput, ReceivingItemUncheckedCreateInput>
    /**
     * In case the ReceivingItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReceivingItemUpdateInput, ReceivingItemUncheckedUpdateInput>
  }

  /**
   * ReceivingItem delete
   */
  export type ReceivingItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceivingItem
     */
    select?: ReceivingItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceivingItemInclude<ExtArgs> | null
    /**
     * Filter which ReceivingItem to delete.
     */
    where: ReceivingItemWhereUniqueInput
  }

  /**
   * ReceivingItem deleteMany
   */
  export type ReceivingItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReceivingItems to delete
     */
    where?: ReceivingItemWhereInput
  }

  /**
   * ReceivingItem without action
   */
  export type ReceivingItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceivingItem
     */
    select?: ReceivingItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceivingItemInclude<ExtArgs> | null
  }


  /**
   * Model InventoryItem
   */

  export type AggregateInventoryItem = {
    _count: InventoryItemCountAggregateOutputType | null
    _avg: InventoryItemAvgAggregateOutputType | null
    _sum: InventoryItemSumAggregateOutputType | null
    _min: InventoryItemMinAggregateOutputType | null
    _max: InventoryItemMaxAggregateOutputType | null
  }

  export type InventoryItemAvgAggregateOutputType = {
    id: number | null
    projectId: number | null
    warehouseId: number | null
    quantity: Decimal | null
  }

  export type InventoryItemSumAggregateOutputType = {
    id: number | null
    projectId: number | null
    warehouseId: number | null
    quantity: Decimal | null
  }

  export type InventoryItemMinAggregateOutputType = {
    id: number | null
    materialName: string | null
    projectId: number | null
    warehouseId: number | null
    quantity: Decimal | null
    unit: string | null
    lastUpdated: Date | null
  }

  export type InventoryItemMaxAggregateOutputType = {
    id: number | null
    materialName: string | null
    projectId: number | null
    warehouseId: number | null
    quantity: Decimal | null
    unit: string | null
    lastUpdated: Date | null
  }

  export type InventoryItemCountAggregateOutputType = {
    id: number
    materialName: number
    projectId: number
    warehouseId: number
    quantity: number
    unit: number
    lastUpdated: number
    _all: number
  }


  export type InventoryItemAvgAggregateInputType = {
    id?: true
    projectId?: true
    warehouseId?: true
    quantity?: true
  }

  export type InventoryItemSumAggregateInputType = {
    id?: true
    projectId?: true
    warehouseId?: true
    quantity?: true
  }

  export type InventoryItemMinAggregateInputType = {
    id?: true
    materialName?: true
    projectId?: true
    warehouseId?: true
    quantity?: true
    unit?: true
    lastUpdated?: true
  }

  export type InventoryItemMaxAggregateInputType = {
    id?: true
    materialName?: true
    projectId?: true
    warehouseId?: true
    quantity?: true
    unit?: true
    lastUpdated?: true
  }

  export type InventoryItemCountAggregateInputType = {
    id?: true
    materialName?: true
    projectId?: true
    warehouseId?: true
    quantity?: true
    unit?: true
    lastUpdated?: true
    _all?: true
  }

  export type InventoryItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryItem to aggregate.
     */
    where?: InventoryItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryItems to fetch.
     */
    orderBy?: InventoryItemOrderByWithRelationInput | InventoryItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InventoryItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InventoryItems
    **/
    _count?: true | InventoryItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InventoryItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InventoryItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InventoryItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InventoryItemMaxAggregateInputType
  }

  export type GetInventoryItemAggregateType<T extends InventoryItemAggregateArgs> = {
        [P in keyof T & keyof AggregateInventoryItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInventoryItem[P]>
      : GetScalarType<T[P], AggregateInventoryItem[P]>
  }




  export type InventoryItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryItemWhereInput
    orderBy?: InventoryItemOrderByWithAggregationInput | InventoryItemOrderByWithAggregationInput[]
    by: InventoryItemScalarFieldEnum[] | InventoryItemScalarFieldEnum
    having?: InventoryItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InventoryItemCountAggregateInputType | true
    _avg?: InventoryItemAvgAggregateInputType
    _sum?: InventoryItemSumAggregateInputType
    _min?: InventoryItemMinAggregateInputType
    _max?: InventoryItemMaxAggregateInputType
  }

  export type InventoryItemGroupByOutputType = {
    id: number
    materialName: string
    projectId: number | null
    warehouseId: number | null
    quantity: Decimal
    unit: string
    lastUpdated: Date
    _count: InventoryItemCountAggregateOutputType | null
    _avg: InventoryItemAvgAggregateOutputType | null
    _sum: InventoryItemSumAggregateOutputType | null
    _min: InventoryItemMinAggregateOutputType | null
    _max: InventoryItemMaxAggregateOutputType | null
  }

  type GetInventoryItemGroupByPayload<T extends InventoryItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InventoryItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InventoryItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InventoryItemGroupByOutputType[P]>
            : GetScalarType<T[P], InventoryItemGroupByOutputType[P]>
        }
      >
    >


  export type InventoryItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    materialName?: boolean
    projectId?: boolean
    warehouseId?: boolean
    quantity?: boolean
    unit?: boolean
    lastUpdated?: boolean
    project?: boolean | InventoryItem$projectArgs<ExtArgs>
    warehouse?: boolean | InventoryItem$warehouseArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryItem"]>


  export type InventoryItemSelectScalar = {
    id?: boolean
    materialName?: boolean
    projectId?: boolean
    warehouseId?: boolean
    quantity?: boolean
    unit?: boolean
    lastUpdated?: boolean
  }

  export type InventoryItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | InventoryItem$projectArgs<ExtArgs>
    warehouse?: boolean | InventoryItem$warehouseArgs<ExtArgs>
  }

  export type $InventoryItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InventoryItem"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs> | null
      warehouse: Prisma.$WarehousePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      materialName: string
      projectId: number | null
      warehouseId: number | null
      quantity: Prisma.Decimal
      unit: string
      lastUpdated: Date
    }, ExtArgs["result"]["inventoryItem"]>
    composites: {}
  }

  type InventoryItemGetPayload<S extends boolean | null | undefined | InventoryItemDefaultArgs> = $Result.GetResult<Prisma.$InventoryItemPayload, S>

  type InventoryItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InventoryItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InventoryItemCountAggregateInputType | true
    }

  export interface InventoryItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InventoryItem'], meta: { name: 'InventoryItem' } }
    /**
     * Find zero or one InventoryItem that matches the filter.
     * @param {InventoryItemFindUniqueArgs} args - Arguments to find a InventoryItem
     * @example
     * // Get one InventoryItem
     * const inventoryItem = await prisma.inventoryItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InventoryItemFindUniqueArgs>(args: SelectSubset<T, InventoryItemFindUniqueArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one InventoryItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InventoryItemFindUniqueOrThrowArgs} args - Arguments to find a InventoryItem
     * @example
     * // Get one InventoryItem
     * const inventoryItem = await prisma.inventoryItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InventoryItemFindUniqueOrThrowArgs>(args: SelectSubset<T, InventoryItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first InventoryItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemFindFirstArgs} args - Arguments to find a InventoryItem
     * @example
     * // Get one InventoryItem
     * const inventoryItem = await prisma.inventoryItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InventoryItemFindFirstArgs>(args?: SelectSubset<T, InventoryItemFindFirstArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first InventoryItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemFindFirstOrThrowArgs} args - Arguments to find a InventoryItem
     * @example
     * // Get one InventoryItem
     * const inventoryItem = await prisma.inventoryItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InventoryItemFindFirstOrThrowArgs>(args?: SelectSubset<T, InventoryItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more InventoryItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InventoryItems
     * const inventoryItems = await prisma.inventoryItem.findMany()
     * 
     * // Get first 10 InventoryItems
     * const inventoryItems = await prisma.inventoryItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inventoryItemWithIdOnly = await prisma.inventoryItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InventoryItemFindManyArgs>(args?: SelectSubset<T, InventoryItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a InventoryItem.
     * @param {InventoryItemCreateArgs} args - Arguments to create a InventoryItem.
     * @example
     * // Create one InventoryItem
     * const InventoryItem = await prisma.inventoryItem.create({
     *   data: {
     *     // ... data to create a InventoryItem
     *   }
     * })
     * 
     */
    create<T extends InventoryItemCreateArgs>(args: SelectSubset<T, InventoryItemCreateArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many InventoryItems.
     * @param {InventoryItemCreateManyArgs} args - Arguments to create many InventoryItems.
     * @example
     * // Create many InventoryItems
     * const inventoryItem = await prisma.inventoryItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InventoryItemCreateManyArgs>(args?: SelectSubset<T, InventoryItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a InventoryItem.
     * @param {InventoryItemDeleteArgs} args - Arguments to delete one InventoryItem.
     * @example
     * // Delete one InventoryItem
     * const InventoryItem = await prisma.inventoryItem.delete({
     *   where: {
     *     // ... filter to delete one InventoryItem
     *   }
     * })
     * 
     */
    delete<T extends InventoryItemDeleteArgs>(args: SelectSubset<T, InventoryItemDeleteArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one InventoryItem.
     * @param {InventoryItemUpdateArgs} args - Arguments to update one InventoryItem.
     * @example
     * // Update one InventoryItem
     * const inventoryItem = await prisma.inventoryItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InventoryItemUpdateArgs>(args: SelectSubset<T, InventoryItemUpdateArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more InventoryItems.
     * @param {InventoryItemDeleteManyArgs} args - Arguments to filter InventoryItems to delete.
     * @example
     * // Delete a few InventoryItems
     * const { count } = await prisma.inventoryItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InventoryItemDeleteManyArgs>(args?: SelectSubset<T, InventoryItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InventoryItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InventoryItems
     * const inventoryItem = await prisma.inventoryItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InventoryItemUpdateManyArgs>(args: SelectSubset<T, InventoryItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InventoryItem.
     * @param {InventoryItemUpsertArgs} args - Arguments to update or create a InventoryItem.
     * @example
     * // Update or create a InventoryItem
     * const inventoryItem = await prisma.inventoryItem.upsert({
     *   create: {
     *     // ... data to create a InventoryItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InventoryItem we want to update
     *   }
     * })
     */
    upsert<T extends InventoryItemUpsertArgs>(args: SelectSubset<T, InventoryItemUpsertArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of InventoryItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemCountArgs} args - Arguments to filter InventoryItems to count.
     * @example
     * // Count the number of InventoryItems
     * const count = await prisma.inventoryItem.count({
     *   where: {
     *     // ... the filter for the InventoryItems we want to count
     *   }
     * })
    **/
    count<T extends InventoryItemCountArgs>(
      args?: Subset<T, InventoryItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InventoryItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InventoryItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InventoryItemAggregateArgs>(args: Subset<T, InventoryItemAggregateArgs>): Prisma.PrismaPromise<GetInventoryItemAggregateType<T>>

    /**
     * Group by InventoryItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InventoryItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InventoryItemGroupByArgs['orderBy'] }
        : { orderBy?: InventoryItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InventoryItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInventoryItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InventoryItem model
   */
  readonly fields: InventoryItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InventoryItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InventoryItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends InventoryItem$projectArgs<ExtArgs> = {}>(args?: Subset<T, InventoryItem$projectArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    warehouse<T extends InventoryItem$warehouseArgs<ExtArgs> = {}>(args?: Subset<T, InventoryItem$warehouseArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InventoryItem model
   */ 
  interface InventoryItemFieldRefs {
    readonly id: FieldRef<"InventoryItem", 'Int'>
    readonly materialName: FieldRef<"InventoryItem", 'String'>
    readonly projectId: FieldRef<"InventoryItem", 'Int'>
    readonly warehouseId: FieldRef<"InventoryItem", 'Int'>
    readonly quantity: FieldRef<"InventoryItem", 'Decimal'>
    readonly unit: FieldRef<"InventoryItem", 'String'>
    readonly lastUpdated: FieldRef<"InventoryItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InventoryItem findUnique
   */
  export type InventoryItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * Filter, which InventoryItem to fetch.
     */
    where: InventoryItemWhereUniqueInput
  }

  /**
   * InventoryItem findUniqueOrThrow
   */
  export type InventoryItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * Filter, which InventoryItem to fetch.
     */
    where: InventoryItemWhereUniqueInput
  }

  /**
   * InventoryItem findFirst
   */
  export type InventoryItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * Filter, which InventoryItem to fetch.
     */
    where?: InventoryItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryItems to fetch.
     */
    orderBy?: InventoryItemOrderByWithRelationInput | InventoryItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryItems.
     */
    cursor?: InventoryItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryItems.
     */
    distinct?: InventoryItemScalarFieldEnum | InventoryItemScalarFieldEnum[]
  }

  /**
   * InventoryItem findFirstOrThrow
   */
  export type InventoryItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * Filter, which InventoryItem to fetch.
     */
    where?: InventoryItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryItems to fetch.
     */
    orderBy?: InventoryItemOrderByWithRelationInput | InventoryItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryItems.
     */
    cursor?: InventoryItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryItems.
     */
    distinct?: InventoryItemScalarFieldEnum | InventoryItemScalarFieldEnum[]
  }

  /**
   * InventoryItem findMany
   */
  export type InventoryItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * Filter, which InventoryItems to fetch.
     */
    where?: InventoryItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryItems to fetch.
     */
    orderBy?: InventoryItemOrderByWithRelationInput | InventoryItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InventoryItems.
     */
    cursor?: InventoryItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryItems.
     */
    skip?: number
    distinct?: InventoryItemScalarFieldEnum | InventoryItemScalarFieldEnum[]
  }

  /**
   * InventoryItem create
   */
  export type InventoryItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * The data needed to create a InventoryItem.
     */
    data: XOR<InventoryItemCreateInput, InventoryItemUncheckedCreateInput>
  }

  /**
   * InventoryItem createMany
   */
  export type InventoryItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InventoryItems.
     */
    data: InventoryItemCreateManyInput | InventoryItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InventoryItem update
   */
  export type InventoryItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * The data needed to update a InventoryItem.
     */
    data: XOR<InventoryItemUpdateInput, InventoryItemUncheckedUpdateInput>
    /**
     * Choose, which InventoryItem to update.
     */
    where: InventoryItemWhereUniqueInput
  }

  /**
   * InventoryItem updateMany
   */
  export type InventoryItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InventoryItems.
     */
    data: XOR<InventoryItemUpdateManyMutationInput, InventoryItemUncheckedUpdateManyInput>
    /**
     * Filter which InventoryItems to update
     */
    where?: InventoryItemWhereInput
  }

  /**
   * InventoryItem upsert
   */
  export type InventoryItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * The filter to search for the InventoryItem to update in case it exists.
     */
    where: InventoryItemWhereUniqueInput
    /**
     * In case the InventoryItem found by the `where` argument doesn't exist, create a new InventoryItem with this data.
     */
    create: XOR<InventoryItemCreateInput, InventoryItemUncheckedCreateInput>
    /**
     * In case the InventoryItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InventoryItemUpdateInput, InventoryItemUncheckedUpdateInput>
  }

  /**
   * InventoryItem delete
   */
  export type InventoryItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * Filter which InventoryItem to delete.
     */
    where: InventoryItemWhereUniqueInput
  }

  /**
   * InventoryItem deleteMany
   */
  export type InventoryItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryItems to delete
     */
    where?: InventoryItemWhereInput
  }

  /**
   * InventoryItem.project
   */
  export type InventoryItem$projectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
  }

  /**
   * InventoryItem.warehouse
   */
  export type InventoryItem$warehouseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    where?: WarehouseWhereInput
  }

  /**
   * InventoryItem without action
   */
  export type InventoryItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
  }


  /**
   * Model WorkflowRule
   */

  export type AggregateWorkflowRule = {
    _count: WorkflowRuleCountAggregateOutputType | null
    _avg: WorkflowRuleAvgAggregateOutputType | null
    _sum: WorkflowRuleSumAggregateOutputType | null
    _min: WorkflowRuleMinAggregateOutputType | null
    _max: WorkflowRuleMaxAggregateOutputType | null
  }

  export type WorkflowRuleAvgAggregateOutputType = {
    id: number | null
    minAmount: Decimal | null
    maxAmount: Decimal | null
    stepOrder: number | null
  }

  export type WorkflowRuleSumAggregateOutputType = {
    id: number | null
    minAmount: Decimal | null
    maxAmount: Decimal | null
    stepOrder: number | null
  }

  export type WorkflowRuleMinAggregateOutputType = {
    id: number | null
    processType: string | null
    minAmount: Decimal | null
    maxAmount: Decimal | null
    approverRole: $Enums.UserRole | null
    stepOrder: number | null
    updatedAt: Date | null
  }

  export type WorkflowRuleMaxAggregateOutputType = {
    id: number | null
    processType: string | null
    minAmount: Decimal | null
    maxAmount: Decimal | null
    approverRole: $Enums.UserRole | null
    stepOrder: number | null
    updatedAt: Date | null
  }

  export type WorkflowRuleCountAggregateOutputType = {
    id: number
    processType: number
    minAmount: number
    maxAmount: number
    approverRole: number
    stepOrder: number
    updatedAt: number
    _all: number
  }


  export type WorkflowRuleAvgAggregateInputType = {
    id?: true
    minAmount?: true
    maxAmount?: true
    stepOrder?: true
  }

  export type WorkflowRuleSumAggregateInputType = {
    id?: true
    minAmount?: true
    maxAmount?: true
    stepOrder?: true
  }

  export type WorkflowRuleMinAggregateInputType = {
    id?: true
    processType?: true
    minAmount?: true
    maxAmount?: true
    approverRole?: true
    stepOrder?: true
    updatedAt?: true
  }

  export type WorkflowRuleMaxAggregateInputType = {
    id?: true
    processType?: true
    minAmount?: true
    maxAmount?: true
    approverRole?: true
    stepOrder?: true
    updatedAt?: true
  }

  export type WorkflowRuleCountAggregateInputType = {
    id?: true
    processType?: true
    minAmount?: true
    maxAmount?: true
    approverRole?: true
    stepOrder?: true
    updatedAt?: true
    _all?: true
  }

  export type WorkflowRuleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkflowRule to aggregate.
     */
    where?: WorkflowRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkflowRules to fetch.
     */
    orderBy?: WorkflowRuleOrderByWithRelationInput | WorkflowRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkflowRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkflowRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkflowRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkflowRules
    **/
    _count?: true | WorkflowRuleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WorkflowRuleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WorkflowRuleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkflowRuleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkflowRuleMaxAggregateInputType
  }

  export type GetWorkflowRuleAggregateType<T extends WorkflowRuleAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkflowRule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkflowRule[P]>
      : GetScalarType<T[P], AggregateWorkflowRule[P]>
  }




  export type WorkflowRuleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkflowRuleWhereInput
    orderBy?: WorkflowRuleOrderByWithAggregationInput | WorkflowRuleOrderByWithAggregationInput[]
    by: WorkflowRuleScalarFieldEnum[] | WorkflowRuleScalarFieldEnum
    having?: WorkflowRuleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkflowRuleCountAggregateInputType | true
    _avg?: WorkflowRuleAvgAggregateInputType
    _sum?: WorkflowRuleSumAggregateInputType
    _min?: WorkflowRuleMinAggregateInputType
    _max?: WorkflowRuleMaxAggregateInputType
  }

  export type WorkflowRuleGroupByOutputType = {
    id: number
    processType: string
    minAmount: Decimal
    maxAmount: Decimal | null
    approverRole: $Enums.UserRole
    stepOrder: number
    updatedAt: Date
    _count: WorkflowRuleCountAggregateOutputType | null
    _avg: WorkflowRuleAvgAggregateOutputType | null
    _sum: WorkflowRuleSumAggregateOutputType | null
    _min: WorkflowRuleMinAggregateOutputType | null
    _max: WorkflowRuleMaxAggregateOutputType | null
  }

  type GetWorkflowRuleGroupByPayload<T extends WorkflowRuleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkflowRuleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkflowRuleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkflowRuleGroupByOutputType[P]>
            : GetScalarType<T[P], WorkflowRuleGroupByOutputType[P]>
        }
      >
    >


  export type WorkflowRuleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    processType?: boolean
    minAmount?: boolean
    maxAmount?: boolean
    approverRole?: boolean
    stepOrder?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["workflowRule"]>


  export type WorkflowRuleSelectScalar = {
    id?: boolean
    processType?: boolean
    minAmount?: boolean
    maxAmount?: boolean
    approverRole?: boolean
    stepOrder?: boolean
    updatedAt?: boolean
  }


  export type $WorkflowRulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkflowRule"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      processType: string
      minAmount: Prisma.Decimal
      maxAmount: Prisma.Decimal | null
      approverRole: $Enums.UserRole
      stepOrder: number
      updatedAt: Date
    }, ExtArgs["result"]["workflowRule"]>
    composites: {}
  }

  type WorkflowRuleGetPayload<S extends boolean | null | undefined | WorkflowRuleDefaultArgs> = $Result.GetResult<Prisma.$WorkflowRulePayload, S>

  type WorkflowRuleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WorkflowRuleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WorkflowRuleCountAggregateInputType | true
    }

  export interface WorkflowRuleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkflowRule'], meta: { name: 'WorkflowRule' } }
    /**
     * Find zero or one WorkflowRule that matches the filter.
     * @param {WorkflowRuleFindUniqueArgs} args - Arguments to find a WorkflowRule
     * @example
     * // Get one WorkflowRule
     * const workflowRule = await prisma.workflowRule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkflowRuleFindUniqueArgs>(args: SelectSubset<T, WorkflowRuleFindUniqueArgs<ExtArgs>>): Prisma__WorkflowRuleClient<$Result.GetResult<Prisma.$WorkflowRulePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WorkflowRule that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WorkflowRuleFindUniqueOrThrowArgs} args - Arguments to find a WorkflowRule
     * @example
     * // Get one WorkflowRule
     * const workflowRule = await prisma.workflowRule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkflowRuleFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkflowRuleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkflowRuleClient<$Result.GetResult<Prisma.$WorkflowRulePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WorkflowRule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowRuleFindFirstArgs} args - Arguments to find a WorkflowRule
     * @example
     * // Get one WorkflowRule
     * const workflowRule = await prisma.workflowRule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkflowRuleFindFirstArgs>(args?: SelectSubset<T, WorkflowRuleFindFirstArgs<ExtArgs>>): Prisma__WorkflowRuleClient<$Result.GetResult<Prisma.$WorkflowRulePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WorkflowRule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowRuleFindFirstOrThrowArgs} args - Arguments to find a WorkflowRule
     * @example
     * // Get one WorkflowRule
     * const workflowRule = await prisma.workflowRule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkflowRuleFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkflowRuleFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkflowRuleClient<$Result.GetResult<Prisma.$WorkflowRulePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WorkflowRules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowRuleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkflowRules
     * const workflowRules = await prisma.workflowRule.findMany()
     * 
     * // Get first 10 WorkflowRules
     * const workflowRules = await prisma.workflowRule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workflowRuleWithIdOnly = await prisma.workflowRule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkflowRuleFindManyArgs>(args?: SelectSubset<T, WorkflowRuleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowRulePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WorkflowRule.
     * @param {WorkflowRuleCreateArgs} args - Arguments to create a WorkflowRule.
     * @example
     * // Create one WorkflowRule
     * const WorkflowRule = await prisma.workflowRule.create({
     *   data: {
     *     // ... data to create a WorkflowRule
     *   }
     * })
     * 
     */
    create<T extends WorkflowRuleCreateArgs>(args: SelectSubset<T, WorkflowRuleCreateArgs<ExtArgs>>): Prisma__WorkflowRuleClient<$Result.GetResult<Prisma.$WorkflowRulePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WorkflowRules.
     * @param {WorkflowRuleCreateManyArgs} args - Arguments to create many WorkflowRules.
     * @example
     * // Create many WorkflowRules
     * const workflowRule = await prisma.workflowRule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkflowRuleCreateManyArgs>(args?: SelectSubset<T, WorkflowRuleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a WorkflowRule.
     * @param {WorkflowRuleDeleteArgs} args - Arguments to delete one WorkflowRule.
     * @example
     * // Delete one WorkflowRule
     * const WorkflowRule = await prisma.workflowRule.delete({
     *   where: {
     *     // ... filter to delete one WorkflowRule
     *   }
     * })
     * 
     */
    delete<T extends WorkflowRuleDeleteArgs>(args: SelectSubset<T, WorkflowRuleDeleteArgs<ExtArgs>>): Prisma__WorkflowRuleClient<$Result.GetResult<Prisma.$WorkflowRulePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WorkflowRule.
     * @param {WorkflowRuleUpdateArgs} args - Arguments to update one WorkflowRule.
     * @example
     * // Update one WorkflowRule
     * const workflowRule = await prisma.workflowRule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkflowRuleUpdateArgs>(args: SelectSubset<T, WorkflowRuleUpdateArgs<ExtArgs>>): Prisma__WorkflowRuleClient<$Result.GetResult<Prisma.$WorkflowRulePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WorkflowRules.
     * @param {WorkflowRuleDeleteManyArgs} args - Arguments to filter WorkflowRules to delete.
     * @example
     * // Delete a few WorkflowRules
     * const { count } = await prisma.workflowRule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkflowRuleDeleteManyArgs>(args?: SelectSubset<T, WorkflowRuleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkflowRules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowRuleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkflowRules
     * const workflowRule = await prisma.workflowRule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkflowRuleUpdateManyArgs>(args: SelectSubset<T, WorkflowRuleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WorkflowRule.
     * @param {WorkflowRuleUpsertArgs} args - Arguments to update or create a WorkflowRule.
     * @example
     * // Update or create a WorkflowRule
     * const workflowRule = await prisma.workflowRule.upsert({
     *   create: {
     *     // ... data to create a WorkflowRule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkflowRule we want to update
     *   }
     * })
     */
    upsert<T extends WorkflowRuleUpsertArgs>(args: SelectSubset<T, WorkflowRuleUpsertArgs<ExtArgs>>): Prisma__WorkflowRuleClient<$Result.GetResult<Prisma.$WorkflowRulePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WorkflowRules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowRuleCountArgs} args - Arguments to filter WorkflowRules to count.
     * @example
     * // Count the number of WorkflowRules
     * const count = await prisma.workflowRule.count({
     *   where: {
     *     // ... the filter for the WorkflowRules we want to count
     *   }
     * })
    **/
    count<T extends WorkflowRuleCountArgs>(
      args?: Subset<T, WorkflowRuleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkflowRuleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkflowRule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowRuleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkflowRuleAggregateArgs>(args: Subset<T, WorkflowRuleAggregateArgs>): Prisma.PrismaPromise<GetWorkflowRuleAggregateType<T>>

    /**
     * Group by WorkflowRule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowRuleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkflowRuleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkflowRuleGroupByArgs['orderBy'] }
        : { orderBy?: WorkflowRuleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkflowRuleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkflowRuleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkflowRule model
   */
  readonly fields: WorkflowRuleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkflowRule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkflowRuleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkflowRule model
   */ 
  interface WorkflowRuleFieldRefs {
    readonly id: FieldRef<"WorkflowRule", 'Int'>
    readonly processType: FieldRef<"WorkflowRule", 'String'>
    readonly minAmount: FieldRef<"WorkflowRule", 'Decimal'>
    readonly maxAmount: FieldRef<"WorkflowRule", 'Decimal'>
    readonly approverRole: FieldRef<"WorkflowRule", 'UserRole'>
    readonly stepOrder: FieldRef<"WorkflowRule", 'Int'>
    readonly updatedAt: FieldRef<"WorkflowRule", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WorkflowRule findUnique
   */
  export type WorkflowRuleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowRule
     */
    select?: WorkflowRuleSelect<ExtArgs> | null
    /**
     * Filter, which WorkflowRule to fetch.
     */
    where: WorkflowRuleWhereUniqueInput
  }

  /**
   * WorkflowRule findUniqueOrThrow
   */
  export type WorkflowRuleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowRule
     */
    select?: WorkflowRuleSelect<ExtArgs> | null
    /**
     * Filter, which WorkflowRule to fetch.
     */
    where: WorkflowRuleWhereUniqueInput
  }

  /**
   * WorkflowRule findFirst
   */
  export type WorkflowRuleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowRule
     */
    select?: WorkflowRuleSelect<ExtArgs> | null
    /**
     * Filter, which WorkflowRule to fetch.
     */
    where?: WorkflowRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkflowRules to fetch.
     */
    orderBy?: WorkflowRuleOrderByWithRelationInput | WorkflowRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkflowRules.
     */
    cursor?: WorkflowRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkflowRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkflowRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkflowRules.
     */
    distinct?: WorkflowRuleScalarFieldEnum | WorkflowRuleScalarFieldEnum[]
  }

  /**
   * WorkflowRule findFirstOrThrow
   */
  export type WorkflowRuleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowRule
     */
    select?: WorkflowRuleSelect<ExtArgs> | null
    /**
     * Filter, which WorkflowRule to fetch.
     */
    where?: WorkflowRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkflowRules to fetch.
     */
    orderBy?: WorkflowRuleOrderByWithRelationInput | WorkflowRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkflowRules.
     */
    cursor?: WorkflowRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkflowRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkflowRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkflowRules.
     */
    distinct?: WorkflowRuleScalarFieldEnum | WorkflowRuleScalarFieldEnum[]
  }

  /**
   * WorkflowRule findMany
   */
  export type WorkflowRuleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowRule
     */
    select?: WorkflowRuleSelect<ExtArgs> | null
    /**
     * Filter, which WorkflowRules to fetch.
     */
    where?: WorkflowRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkflowRules to fetch.
     */
    orderBy?: WorkflowRuleOrderByWithRelationInput | WorkflowRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkflowRules.
     */
    cursor?: WorkflowRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkflowRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkflowRules.
     */
    skip?: number
    distinct?: WorkflowRuleScalarFieldEnum | WorkflowRuleScalarFieldEnum[]
  }

  /**
   * WorkflowRule create
   */
  export type WorkflowRuleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowRule
     */
    select?: WorkflowRuleSelect<ExtArgs> | null
    /**
     * The data needed to create a WorkflowRule.
     */
    data: XOR<WorkflowRuleCreateInput, WorkflowRuleUncheckedCreateInput>
  }

  /**
   * WorkflowRule createMany
   */
  export type WorkflowRuleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkflowRules.
     */
    data: WorkflowRuleCreateManyInput | WorkflowRuleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorkflowRule update
   */
  export type WorkflowRuleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowRule
     */
    select?: WorkflowRuleSelect<ExtArgs> | null
    /**
     * The data needed to update a WorkflowRule.
     */
    data: XOR<WorkflowRuleUpdateInput, WorkflowRuleUncheckedUpdateInput>
    /**
     * Choose, which WorkflowRule to update.
     */
    where: WorkflowRuleWhereUniqueInput
  }

  /**
   * WorkflowRule updateMany
   */
  export type WorkflowRuleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkflowRules.
     */
    data: XOR<WorkflowRuleUpdateManyMutationInput, WorkflowRuleUncheckedUpdateManyInput>
    /**
     * Filter which WorkflowRules to update
     */
    where?: WorkflowRuleWhereInput
  }

  /**
   * WorkflowRule upsert
   */
  export type WorkflowRuleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowRule
     */
    select?: WorkflowRuleSelect<ExtArgs> | null
    /**
     * The filter to search for the WorkflowRule to update in case it exists.
     */
    where: WorkflowRuleWhereUniqueInput
    /**
     * In case the WorkflowRule found by the `where` argument doesn't exist, create a new WorkflowRule with this data.
     */
    create: XOR<WorkflowRuleCreateInput, WorkflowRuleUncheckedCreateInput>
    /**
     * In case the WorkflowRule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkflowRuleUpdateInput, WorkflowRuleUncheckedUpdateInput>
  }

  /**
   * WorkflowRule delete
   */
  export type WorkflowRuleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowRule
     */
    select?: WorkflowRuleSelect<ExtArgs> | null
    /**
     * Filter which WorkflowRule to delete.
     */
    where: WorkflowRuleWhereUniqueInput
  }

  /**
   * WorkflowRule deleteMany
   */
  export type WorkflowRuleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkflowRules to delete
     */
    where?: WorkflowRuleWhereInput
  }

  /**
   * WorkflowRule without action
   */
  export type WorkflowRuleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowRule
     */
    select?: WorkflowRuleSelect<ExtArgs> | null
  }


  /**
   * Model SupplierInvoice
   */

  export type AggregateSupplierInvoice = {
    _count: SupplierInvoiceCountAggregateOutputType | null
    _avg: SupplierInvoiceAvgAggregateOutputType | null
    _sum: SupplierInvoiceSumAggregateOutputType | null
    _min: SupplierInvoiceMinAggregateOutputType | null
    _max: SupplierInvoiceMaxAggregateOutputType | null
  }

  export type SupplierInvoiceAvgAggregateOutputType = {
    id: number | null
    supplierId: number | null
    purchaseOrderId: number | null
    receivingReportId: number | null
    totalAmount: Decimal | null
  }

  export type SupplierInvoiceSumAggregateOutputType = {
    id: number | null
    supplierId: number | null
    purchaseOrderId: number | null
    receivingReportId: number | null
    totalAmount: Decimal | null
  }

  export type SupplierInvoiceMinAggregateOutputType = {
    id: number | null
    invoiceNumber: string | null
    invoiceDate: Date | null
    supplierId: number | null
    purchaseOrderId: number | null
    receivingReportId: number | null
    totalAmount: Decimal | null
    status: string | null
    createdAt: Date | null
  }

  export type SupplierInvoiceMaxAggregateOutputType = {
    id: number | null
    invoiceNumber: string | null
    invoiceDate: Date | null
    supplierId: number | null
    purchaseOrderId: number | null
    receivingReportId: number | null
    totalAmount: Decimal | null
    status: string | null
    createdAt: Date | null
  }

  export type SupplierInvoiceCountAggregateOutputType = {
    id: number
    invoiceNumber: number
    invoiceDate: number
    supplierId: number
    purchaseOrderId: number
    receivingReportId: number
    totalAmount: number
    status: number
    createdAt: number
    _all: number
  }


  export type SupplierInvoiceAvgAggregateInputType = {
    id?: true
    supplierId?: true
    purchaseOrderId?: true
    receivingReportId?: true
    totalAmount?: true
  }

  export type SupplierInvoiceSumAggregateInputType = {
    id?: true
    supplierId?: true
    purchaseOrderId?: true
    receivingReportId?: true
    totalAmount?: true
  }

  export type SupplierInvoiceMinAggregateInputType = {
    id?: true
    invoiceNumber?: true
    invoiceDate?: true
    supplierId?: true
    purchaseOrderId?: true
    receivingReportId?: true
    totalAmount?: true
    status?: true
    createdAt?: true
  }

  export type SupplierInvoiceMaxAggregateInputType = {
    id?: true
    invoiceNumber?: true
    invoiceDate?: true
    supplierId?: true
    purchaseOrderId?: true
    receivingReportId?: true
    totalAmount?: true
    status?: true
    createdAt?: true
  }

  export type SupplierInvoiceCountAggregateInputType = {
    id?: true
    invoiceNumber?: true
    invoiceDate?: true
    supplierId?: true
    purchaseOrderId?: true
    receivingReportId?: true
    totalAmount?: true
    status?: true
    createdAt?: true
    _all?: true
  }

  export type SupplierInvoiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SupplierInvoice to aggregate.
     */
    where?: SupplierInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupplierInvoices to fetch.
     */
    orderBy?: SupplierInvoiceOrderByWithRelationInput | SupplierInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SupplierInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupplierInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupplierInvoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SupplierInvoices
    **/
    _count?: true | SupplierInvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SupplierInvoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SupplierInvoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SupplierInvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SupplierInvoiceMaxAggregateInputType
  }

  export type GetSupplierInvoiceAggregateType<T extends SupplierInvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateSupplierInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupplierInvoice[P]>
      : GetScalarType<T[P], AggregateSupplierInvoice[P]>
  }




  export type SupplierInvoiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupplierInvoiceWhereInput
    orderBy?: SupplierInvoiceOrderByWithAggregationInput | SupplierInvoiceOrderByWithAggregationInput[]
    by: SupplierInvoiceScalarFieldEnum[] | SupplierInvoiceScalarFieldEnum
    having?: SupplierInvoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SupplierInvoiceCountAggregateInputType | true
    _avg?: SupplierInvoiceAvgAggregateInputType
    _sum?: SupplierInvoiceSumAggregateInputType
    _min?: SupplierInvoiceMinAggregateInputType
    _max?: SupplierInvoiceMaxAggregateInputType
  }

  export type SupplierInvoiceGroupByOutputType = {
    id: number
    invoiceNumber: string
    invoiceDate: Date
    supplierId: number
    purchaseOrderId: number | null
    receivingReportId: number | null
    totalAmount: Decimal
    status: string
    createdAt: Date
    _count: SupplierInvoiceCountAggregateOutputType | null
    _avg: SupplierInvoiceAvgAggregateOutputType | null
    _sum: SupplierInvoiceSumAggregateOutputType | null
    _min: SupplierInvoiceMinAggregateOutputType | null
    _max: SupplierInvoiceMaxAggregateOutputType | null
  }

  type GetSupplierInvoiceGroupByPayload<T extends SupplierInvoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SupplierInvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SupplierInvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SupplierInvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], SupplierInvoiceGroupByOutputType[P]>
        }
      >
    >


  export type SupplierInvoiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceNumber?: boolean
    invoiceDate?: boolean
    supplierId?: boolean
    purchaseOrderId?: boolean
    receivingReportId?: boolean
    totalAmount?: boolean
    status?: boolean
    createdAt?: boolean
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
    purchaseOrder?: boolean | SupplierInvoice$purchaseOrderArgs<ExtArgs>
    receivingReport?: boolean | SupplierInvoice$receivingReportArgs<ExtArgs>
  }, ExtArgs["result"]["supplierInvoice"]>


  export type SupplierInvoiceSelectScalar = {
    id?: boolean
    invoiceNumber?: boolean
    invoiceDate?: boolean
    supplierId?: boolean
    purchaseOrderId?: boolean
    receivingReportId?: boolean
    totalAmount?: boolean
    status?: boolean
    createdAt?: boolean
  }

  export type SupplierInvoiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
    purchaseOrder?: boolean | SupplierInvoice$purchaseOrderArgs<ExtArgs>
    receivingReport?: boolean | SupplierInvoice$receivingReportArgs<ExtArgs>
  }

  export type $SupplierInvoicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SupplierInvoice"
    objects: {
      supplier: Prisma.$SupplierPayload<ExtArgs>
      purchaseOrder: Prisma.$PurchaseOrderPayload<ExtArgs> | null
      receivingReport: Prisma.$ReceivingReportPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      invoiceNumber: string
      invoiceDate: Date
      supplierId: number
      purchaseOrderId: number | null
      receivingReportId: number | null
      totalAmount: Prisma.Decimal
      status: string
      createdAt: Date
    }, ExtArgs["result"]["supplierInvoice"]>
    composites: {}
  }

  type SupplierInvoiceGetPayload<S extends boolean | null | undefined | SupplierInvoiceDefaultArgs> = $Result.GetResult<Prisma.$SupplierInvoicePayload, S>

  type SupplierInvoiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SupplierInvoiceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SupplierInvoiceCountAggregateInputType | true
    }

  export interface SupplierInvoiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SupplierInvoice'], meta: { name: 'SupplierInvoice' } }
    /**
     * Find zero or one SupplierInvoice that matches the filter.
     * @param {SupplierInvoiceFindUniqueArgs} args - Arguments to find a SupplierInvoice
     * @example
     * // Get one SupplierInvoice
     * const supplierInvoice = await prisma.supplierInvoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SupplierInvoiceFindUniqueArgs>(args: SelectSubset<T, SupplierInvoiceFindUniqueArgs<ExtArgs>>): Prisma__SupplierInvoiceClient<$Result.GetResult<Prisma.$SupplierInvoicePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SupplierInvoice that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SupplierInvoiceFindUniqueOrThrowArgs} args - Arguments to find a SupplierInvoice
     * @example
     * // Get one SupplierInvoice
     * const supplierInvoice = await prisma.supplierInvoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SupplierInvoiceFindUniqueOrThrowArgs>(args: SelectSubset<T, SupplierInvoiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SupplierInvoiceClient<$Result.GetResult<Prisma.$SupplierInvoicePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SupplierInvoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierInvoiceFindFirstArgs} args - Arguments to find a SupplierInvoice
     * @example
     * // Get one SupplierInvoice
     * const supplierInvoice = await prisma.supplierInvoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SupplierInvoiceFindFirstArgs>(args?: SelectSubset<T, SupplierInvoiceFindFirstArgs<ExtArgs>>): Prisma__SupplierInvoiceClient<$Result.GetResult<Prisma.$SupplierInvoicePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SupplierInvoice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierInvoiceFindFirstOrThrowArgs} args - Arguments to find a SupplierInvoice
     * @example
     * // Get one SupplierInvoice
     * const supplierInvoice = await prisma.supplierInvoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SupplierInvoiceFindFirstOrThrowArgs>(args?: SelectSubset<T, SupplierInvoiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__SupplierInvoiceClient<$Result.GetResult<Prisma.$SupplierInvoicePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SupplierInvoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierInvoiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SupplierInvoices
     * const supplierInvoices = await prisma.supplierInvoice.findMany()
     * 
     * // Get first 10 SupplierInvoices
     * const supplierInvoices = await prisma.supplierInvoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const supplierInvoiceWithIdOnly = await prisma.supplierInvoice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SupplierInvoiceFindManyArgs>(args?: SelectSubset<T, SupplierInvoiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierInvoicePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SupplierInvoice.
     * @param {SupplierInvoiceCreateArgs} args - Arguments to create a SupplierInvoice.
     * @example
     * // Create one SupplierInvoice
     * const SupplierInvoice = await prisma.supplierInvoice.create({
     *   data: {
     *     // ... data to create a SupplierInvoice
     *   }
     * })
     * 
     */
    create<T extends SupplierInvoiceCreateArgs>(args: SelectSubset<T, SupplierInvoiceCreateArgs<ExtArgs>>): Prisma__SupplierInvoiceClient<$Result.GetResult<Prisma.$SupplierInvoicePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SupplierInvoices.
     * @param {SupplierInvoiceCreateManyArgs} args - Arguments to create many SupplierInvoices.
     * @example
     * // Create many SupplierInvoices
     * const supplierInvoice = await prisma.supplierInvoice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SupplierInvoiceCreateManyArgs>(args?: SelectSubset<T, SupplierInvoiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SupplierInvoice.
     * @param {SupplierInvoiceDeleteArgs} args - Arguments to delete one SupplierInvoice.
     * @example
     * // Delete one SupplierInvoice
     * const SupplierInvoice = await prisma.supplierInvoice.delete({
     *   where: {
     *     // ... filter to delete one SupplierInvoice
     *   }
     * })
     * 
     */
    delete<T extends SupplierInvoiceDeleteArgs>(args: SelectSubset<T, SupplierInvoiceDeleteArgs<ExtArgs>>): Prisma__SupplierInvoiceClient<$Result.GetResult<Prisma.$SupplierInvoicePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SupplierInvoice.
     * @param {SupplierInvoiceUpdateArgs} args - Arguments to update one SupplierInvoice.
     * @example
     * // Update one SupplierInvoice
     * const supplierInvoice = await prisma.supplierInvoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SupplierInvoiceUpdateArgs>(args: SelectSubset<T, SupplierInvoiceUpdateArgs<ExtArgs>>): Prisma__SupplierInvoiceClient<$Result.GetResult<Prisma.$SupplierInvoicePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SupplierInvoices.
     * @param {SupplierInvoiceDeleteManyArgs} args - Arguments to filter SupplierInvoices to delete.
     * @example
     * // Delete a few SupplierInvoices
     * const { count } = await prisma.supplierInvoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SupplierInvoiceDeleteManyArgs>(args?: SelectSubset<T, SupplierInvoiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SupplierInvoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierInvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SupplierInvoices
     * const supplierInvoice = await prisma.supplierInvoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SupplierInvoiceUpdateManyArgs>(args: SelectSubset<T, SupplierInvoiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SupplierInvoice.
     * @param {SupplierInvoiceUpsertArgs} args - Arguments to update or create a SupplierInvoice.
     * @example
     * // Update or create a SupplierInvoice
     * const supplierInvoice = await prisma.supplierInvoice.upsert({
     *   create: {
     *     // ... data to create a SupplierInvoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SupplierInvoice we want to update
     *   }
     * })
     */
    upsert<T extends SupplierInvoiceUpsertArgs>(args: SelectSubset<T, SupplierInvoiceUpsertArgs<ExtArgs>>): Prisma__SupplierInvoiceClient<$Result.GetResult<Prisma.$SupplierInvoicePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SupplierInvoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierInvoiceCountArgs} args - Arguments to filter SupplierInvoices to count.
     * @example
     * // Count the number of SupplierInvoices
     * const count = await prisma.supplierInvoice.count({
     *   where: {
     *     // ... the filter for the SupplierInvoices we want to count
     *   }
     * })
    **/
    count<T extends SupplierInvoiceCountArgs>(
      args?: Subset<T, SupplierInvoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SupplierInvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SupplierInvoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierInvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SupplierInvoiceAggregateArgs>(args: Subset<T, SupplierInvoiceAggregateArgs>): Prisma.PrismaPromise<GetSupplierInvoiceAggregateType<T>>

    /**
     * Group by SupplierInvoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierInvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SupplierInvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SupplierInvoiceGroupByArgs['orderBy'] }
        : { orderBy?: SupplierInvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SupplierInvoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSupplierInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SupplierInvoice model
   */
  readonly fields: SupplierInvoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SupplierInvoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SupplierInvoiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    supplier<T extends SupplierDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SupplierDefaultArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    purchaseOrder<T extends SupplierInvoice$purchaseOrderArgs<ExtArgs> = {}>(args?: Subset<T, SupplierInvoice$purchaseOrderArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    receivingReport<T extends SupplierInvoice$receivingReportArgs<ExtArgs> = {}>(args?: Subset<T, SupplierInvoice$receivingReportArgs<ExtArgs>>): Prisma__ReceivingReportClient<$Result.GetResult<Prisma.$ReceivingReportPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SupplierInvoice model
   */ 
  interface SupplierInvoiceFieldRefs {
    readonly id: FieldRef<"SupplierInvoice", 'Int'>
    readonly invoiceNumber: FieldRef<"SupplierInvoice", 'String'>
    readonly invoiceDate: FieldRef<"SupplierInvoice", 'DateTime'>
    readonly supplierId: FieldRef<"SupplierInvoice", 'Int'>
    readonly purchaseOrderId: FieldRef<"SupplierInvoice", 'Int'>
    readonly receivingReportId: FieldRef<"SupplierInvoice", 'Int'>
    readonly totalAmount: FieldRef<"SupplierInvoice", 'Decimal'>
    readonly status: FieldRef<"SupplierInvoice", 'String'>
    readonly createdAt: FieldRef<"SupplierInvoice", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SupplierInvoice findUnique
   */
  export type SupplierInvoiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierInvoice
     */
    select?: SupplierInvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which SupplierInvoice to fetch.
     */
    where: SupplierInvoiceWhereUniqueInput
  }

  /**
   * SupplierInvoice findUniqueOrThrow
   */
  export type SupplierInvoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierInvoice
     */
    select?: SupplierInvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which SupplierInvoice to fetch.
     */
    where: SupplierInvoiceWhereUniqueInput
  }

  /**
   * SupplierInvoice findFirst
   */
  export type SupplierInvoiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierInvoice
     */
    select?: SupplierInvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which SupplierInvoice to fetch.
     */
    where?: SupplierInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupplierInvoices to fetch.
     */
    orderBy?: SupplierInvoiceOrderByWithRelationInput | SupplierInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SupplierInvoices.
     */
    cursor?: SupplierInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupplierInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupplierInvoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SupplierInvoices.
     */
    distinct?: SupplierInvoiceScalarFieldEnum | SupplierInvoiceScalarFieldEnum[]
  }

  /**
   * SupplierInvoice findFirstOrThrow
   */
  export type SupplierInvoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierInvoice
     */
    select?: SupplierInvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which SupplierInvoice to fetch.
     */
    where?: SupplierInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupplierInvoices to fetch.
     */
    orderBy?: SupplierInvoiceOrderByWithRelationInput | SupplierInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SupplierInvoices.
     */
    cursor?: SupplierInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupplierInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupplierInvoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SupplierInvoices.
     */
    distinct?: SupplierInvoiceScalarFieldEnum | SupplierInvoiceScalarFieldEnum[]
  }

  /**
   * SupplierInvoice findMany
   */
  export type SupplierInvoiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierInvoice
     */
    select?: SupplierInvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which SupplierInvoices to fetch.
     */
    where?: SupplierInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupplierInvoices to fetch.
     */
    orderBy?: SupplierInvoiceOrderByWithRelationInput | SupplierInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SupplierInvoices.
     */
    cursor?: SupplierInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupplierInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupplierInvoices.
     */
    skip?: number
    distinct?: SupplierInvoiceScalarFieldEnum | SupplierInvoiceScalarFieldEnum[]
  }

  /**
   * SupplierInvoice create
   */
  export type SupplierInvoiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierInvoice
     */
    select?: SupplierInvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInvoiceInclude<ExtArgs> | null
    /**
     * The data needed to create a SupplierInvoice.
     */
    data: XOR<SupplierInvoiceCreateInput, SupplierInvoiceUncheckedCreateInput>
  }

  /**
   * SupplierInvoice createMany
   */
  export type SupplierInvoiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SupplierInvoices.
     */
    data: SupplierInvoiceCreateManyInput | SupplierInvoiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SupplierInvoice update
   */
  export type SupplierInvoiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierInvoice
     */
    select?: SupplierInvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInvoiceInclude<ExtArgs> | null
    /**
     * The data needed to update a SupplierInvoice.
     */
    data: XOR<SupplierInvoiceUpdateInput, SupplierInvoiceUncheckedUpdateInput>
    /**
     * Choose, which SupplierInvoice to update.
     */
    where: SupplierInvoiceWhereUniqueInput
  }

  /**
   * SupplierInvoice updateMany
   */
  export type SupplierInvoiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SupplierInvoices.
     */
    data: XOR<SupplierInvoiceUpdateManyMutationInput, SupplierInvoiceUncheckedUpdateManyInput>
    /**
     * Filter which SupplierInvoices to update
     */
    where?: SupplierInvoiceWhereInput
  }

  /**
   * SupplierInvoice upsert
   */
  export type SupplierInvoiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierInvoice
     */
    select?: SupplierInvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInvoiceInclude<ExtArgs> | null
    /**
     * The filter to search for the SupplierInvoice to update in case it exists.
     */
    where: SupplierInvoiceWhereUniqueInput
    /**
     * In case the SupplierInvoice found by the `where` argument doesn't exist, create a new SupplierInvoice with this data.
     */
    create: XOR<SupplierInvoiceCreateInput, SupplierInvoiceUncheckedCreateInput>
    /**
     * In case the SupplierInvoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SupplierInvoiceUpdateInput, SupplierInvoiceUncheckedUpdateInput>
  }

  /**
   * SupplierInvoice delete
   */
  export type SupplierInvoiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierInvoice
     */
    select?: SupplierInvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInvoiceInclude<ExtArgs> | null
    /**
     * Filter which SupplierInvoice to delete.
     */
    where: SupplierInvoiceWhereUniqueInput
  }

  /**
   * SupplierInvoice deleteMany
   */
  export type SupplierInvoiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SupplierInvoices to delete
     */
    where?: SupplierInvoiceWhereInput
  }

  /**
   * SupplierInvoice.purchaseOrder
   */
  export type SupplierInvoice$purchaseOrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    where?: PurchaseOrderWhereInput
  }

  /**
   * SupplierInvoice.receivingReport
   */
  export type SupplierInvoice$receivingReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceivingReport
     */
    select?: ReceivingReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceivingReportInclude<ExtArgs> | null
    where?: ReceivingReportWhereInput
  }

  /**
   * SupplierInvoice without action
   */
  export type SupplierInvoiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierInvoice
     */
    select?: SupplierInvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInvoiceInclude<ExtArgs> | null
  }


  /**
   * Model Disbursement
   */

  export type AggregateDisbursement = {
    _count: DisbursementCountAggregateOutputType | null
    _avg: DisbursementAvgAggregateOutputType | null
    _sum: DisbursementSumAggregateOutputType | null
    _min: DisbursementMinAggregateOutputType | null
    _max: DisbursementMaxAggregateOutputType | null
  }

  export type DisbursementAvgAggregateOutputType = {
    id: number | null
    purchaseOrderId: number | null
    processedById: number | null
    amount: Decimal | null
  }

  export type DisbursementSumAggregateOutputType = {
    id: number | null
    purchaseOrderId: number | null
    processedById: number | null
    amount: Decimal | null
  }

  export type DisbursementMinAggregateOutputType = {
    id: number | null
    purchaseOrderId: number | null
    processedById: number | null
    amount: Decimal | null
    paymentDate: Date | null
    method: $Enums.PaymentMethod | null
    referenceNumber: string | null
    status: string | null
  }

  export type DisbursementMaxAggregateOutputType = {
    id: number | null
    purchaseOrderId: number | null
    processedById: number | null
    amount: Decimal | null
    paymentDate: Date | null
    method: $Enums.PaymentMethod | null
    referenceNumber: string | null
    status: string | null
  }

  export type DisbursementCountAggregateOutputType = {
    id: number
    purchaseOrderId: number
    processedById: number
    amount: number
    paymentDate: number
    method: number
    referenceNumber: number
    status: number
    _all: number
  }


  export type DisbursementAvgAggregateInputType = {
    id?: true
    purchaseOrderId?: true
    processedById?: true
    amount?: true
  }

  export type DisbursementSumAggregateInputType = {
    id?: true
    purchaseOrderId?: true
    processedById?: true
    amount?: true
  }

  export type DisbursementMinAggregateInputType = {
    id?: true
    purchaseOrderId?: true
    processedById?: true
    amount?: true
    paymentDate?: true
    method?: true
    referenceNumber?: true
    status?: true
  }

  export type DisbursementMaxAggregateInputType = {
    id?: true
    purchaseOrderId?: true
    processedById?: true
    amount?: true
    paymentDate?: true
    method?: true
    referenceNumber?: true
    status?: true
  }

  export type DisbursementCountAggregateInputType = {
    id?: true
    purchaseOrderId?: true
    processedById?: true
    amount?: true
    paymentDate?: true
    method?: true
    referenceNumber?: true
    status?: true
    _all?: true
  }

  export type DisbursementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Disbursement to aggregate.
     */
    where?: DisbursementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Disbursements to fetch.
     */
    orderBy?: DisbursementOrderByWithRelationInput | DisbursementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DisbursementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Disbursements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Disbursements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Disbursements
    **/
    _count?: true | DisbursementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DisbursementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DisbursementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DisbursementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DisbursementMaxAggregateInputType
  }

  export type GetDisbursementAggregateType<T extends DisbursementAggregateArgs> = {
        [P in keyof T & keyof AggregateDisbursement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDisbursement[P]>
      : GetScalarType<T[P], AggregateDisbursement[P]>
  }




  export type DisbursementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DisbursementWhereInput
    orderBy?: DisbursementOrderByWithAggregationInput | DisbursementOrderByWithAggregationInput[]
    by: DisbursementScalarFieldEnum[] | DisbursementScalarFieldEnum
    having?: DisbursementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DisbursementCountAggregateInputType | true
    _avg?: DisbursementAvgAggregateInputType
    _sum?: DisbursementSumAggregateInputType
    _min?: DisbursementMinAggregateInputType
    _max?: DisbursementMaxAggregateInputType
  }

  export type DisbursementGroupByOutputType = {
    id: number
    purchaseOrderId: number | null
    processedById: number
    amount: Decimal
    paymentDate: Date
    method: $Enums.PaymentMethod
    referenceNumber: string | null
    status: string
    _count: DisbursementCountAggregateOutputType | null
    _avg: DisbursementAvgAggregateOutputType | null
    _sum: DisbursementSumAggregateOutputType | null
    _min: DisbursementMinAggregateOutputType | null
    _max: DisbursementMaxAggregateOutputType | null
  }

  type GetDisbursementGroupByPayload<T extends DisbursementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DisbursementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DisbursementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DisbursementGroupByOutputType[P]>
            : GetScalarType<T[P], DisbursementGroupByOutputType[P]>
        }
      >
    >


  export type DisbursementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    purchaseOrderId?: boolean
    processedById?: boolean
    amount?: boolean
    paymentDate?: boolean
    method?: boolean
    referenceNumber?: boolean
    status?: boolean
    purchaseOrder?: boolean | Disbursement$purchaseOrderArgs<ExtArgs>
    processedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["disbursement"]>


  export type DisbursementSelectScalar = {
    id?: boolean
    purchaseOrderId?: boolean
    processedById?: boolean
    amount?: boolean
    paymentDate?: boolean
    method?: boolean
    referenceNumber?: boolean
    status?: boolean
  }

  export type DisbursementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchaseOrder?: boolean | Disbursement$purchaseOrderArgs<ExtArgs>
    processedBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DisbursementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Disbursement"
    objects: {
      purchaseOrder: Prisma.$PurchaseOrderPayload<ExtArgs> | null
      processedBy: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      purchaseOrderId: number | null
      processedById: number
      amount: Prisma.Decimal
      paymentDate: Date
      method: $Enums.PaymentMethod
      referenceNumber: string | null
      status: string
    }, ExtArgs["result"]["disbursement"]>
    composites: {}
  }

  type DisbursementGetPayload<S extends boolean | null | undefined | DisbursementDefaultArgs> = $Result.GetResult<Prisma.$DisbursementPayload, S>

  type DisbursementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DisbursementFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DisbursementCountAggregateInputType | true
    }

  export interface DisbursementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Disbursement'], meta: { name: 'Disbursement' } }
    /**
     * Find zero or one Disbursement that matches the filter.
     * @param {DisbursementFindUniqueArgs} args - Arguments to find a Disbursement
     * @example
     * // Get one Disbursement
     * const disbursement = await prisma.disbursement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DisbursementFindUniqueArgs>(args: SelectSubset<T, DisbursementFindUniqueArgs<ExtArgs>>): Prisma__DisbursementClient<$Result.GetResult<Prisma.$DisbursementPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Disbursement that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DisbursementFindUniqueOrThrowArgs} args - Arguments to find a Disbursement
     * @example
     * // Get one Disbursement
     * const disbursement = await prisma.disbursement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DisbursementFindUniqueOrThrowArgs>(args: SelectSubset<T, DisbursementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DisbursementClient<$Result.GetResult<Prisma.$DisbursementPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Disbursement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisbursementFindFirstArgs} args - Arguments to find a Disbursement
     * @example
     * // Get one Disbursement
     * const disbursement = await prisma.disbursement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DisbursementFindFirstArgs>(args?: SelectSubset<T, DisbursementFindFirstArgs<ExtArgs>>): Prisma__DisbursementClient<$Result.GetResult<Prisma.$DisbursementPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Disbursement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisbursementFindFirstOrThrowArgs} args - Arguments to find a Disbursement
     * @example
     * // Get one Disbursement
     * const disbursement = await prisma.disbursement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DisbursementFindFirstOrThrowArgs>(args?: SelectSubset<T, DisbursementFindFirstOrThrowArgs<ExtArgs>>): Prisma__DisbursementClient<$Result.GetResult<Prisma.$DisbursementPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Disbursements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisbursementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Disbursements
     * const disbursements = await prisma.disbursement.findMany()
     * 
     * // Get first 10 Disbursements
     * const disbursements = await prisma.disbursement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const disbursementWithIdOnly = await prisma.disbursement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DisbursementFindManyArgs>(args?: SelectSubset<T, DisbursementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DisbursementPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Disbursement.
     * @param {DisbursementCreateArgs} args - Arguments to create a Disbursement.
     * @example
     * // Create one Disbursement
     * const Disbursement = await prisma.disbursement.create({
     *   data: {
     *     // ... data to create a Disbursement
     *   }
     * })
     * 
     */
    create<T extends DisbursementCreateArgs>(args: SelectSubset<T, DisbursementCreateArgs<ExtArgs>>): Prisma__DisbursementClient<$Result.GetResult<Prisma.$DisbursementPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Disbursements.
     * @param {DisbursementCreateManyArgs} args - Arguments to create many Disbursements.
     * @example
     * // Create many Disbursements
     * const disbursement = await prisma.disbursement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DisbursementCreateManyArgs>(args?: SelectSubset<T, DisbursementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Disbursement.
     * @param {DisbursementDeleteArgs} args - Arguments to delete one Disbursement.
     * @example
     * // Delete one Disbursement
     * const Disbursement = await prisma.disbursement.delete({
     *   where: {
     *     // ... filter to delete one Disbursement
     *   }
     * })
     * 
     */
    delete<T extends DisbursementDeleteArgs>(args: SelectSubset<T, DisbursementDeleteArgs<ExtArgs>>): Prisma__DisbursementClient<$Result.GetResult<Prisma.$DisbursementPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Disbursement.
     * @param {DisbursementUpdateArgs} args - Arguments to update one Disbursement.
     * @example
     * // Update one Disbursement
     * const disbursement = await prisma.disbursement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DisbursementUpdateArgs>(args: SelectSubset<T, DisbursementUpdateArgs<ExtArgs>>): Prisma__DisbursementClient<$Result.GetResult<Prisma.$DisbursementPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Disbursements.
     * @param {DisbursementDeleteManyArgs} args - Arguments to filter Disbursements to delete.
     * @example
     * // Delete a few Disbursements
     * const { count } = await prisma.disbursement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DisbursementDeleteManyArgs>(args?: SelectSubset<T, DisbursementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Disbursements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisbursementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Disbursements
     * const disbursement = await prisma.disbursement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DisbursementUpdateManyArgs>(args: SelectSubset<T, DisbursementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Disbursement.
     * @param {DisbursementUpsertArgs} args - Arguments to update or create a Disbursement.
     * @example
     * // Update or create a Disbursement
     * const disbursement = await prisma.disbursement.upsert({
     *   create: {
     *     // ... data to create a Disbursement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Disbursement we want to update
     *   }
     * })
     */
    upsert<T extends DisbursementUpsertArgs>(args: SelectSubset<T, DisbursementUpsertArgs<ExtArgs>>): Prisma__DisbursementClient<$Result.GetResult<Prisma.$DisbursementPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Disbursements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisbursementCountArgs} args - Arguments to filter Disbursements to count.
     * @example
     * // Count the number of Disbursements
     * const count = await prisma.disbursement.count({
     *   where: {
     *     // ... the filter for the Disbursements we want to count
     *   }
     * })
    **/
    count<T extends DisbursementCountArgs>(
      args?: Subset<T, DisbursementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DisbursementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Disbursement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisbursementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DisbursementAggregateArgs>(args: Subset<T, DisbursementAggregateArgs>): Prisma.PrismaPromise<GetDisbursementAggregateType<T>>

    /**
     * Group by Disbursement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisbursementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DisbursementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DisbursementGroupByArgs['orderBy'] }
        : { orderBy?: DisbursementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DisbursementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDisbursementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Disbursement model
   */
  readonly fields: DisbursementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Disbursement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DisbursementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    purchaseOrder<T extends Disbursement$purchaseOrderArgs<ExtArgs> = {}>(args?: Subset<T, Disbursement$purchaseOrderArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    processedBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Disbursement model
   */ 
  interface DisbursementFieldRefs {
    readonly id: FieldRef<"Disbursement", 'Int'>
    readonly purchaseOrderId: FieldRef<"Disbursement", 'Int'>
    readonly processedById: FieldRef<"Disbursement", 'Int'>
    readonly amount: FieldRef<"Disbursement", 'Decimal'>
    readonly paymentDate: FieldRef<"Disbursement", 'DateTime'>
    readonly method: FieldRef<"Disbursement", 'PaymentMethod'>
    readonly referenceNumber: FieldRef<"Disbursement", 'String'>
    readonly status: FieldRef<"Disbursement", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Disbursement findUnique
   */
  export type DisbursementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Disbursement
     */
    select?: DisbursementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisbursementInclude<ExtArgs> | null
    /**
     * Filter, which Disbursement to fetch.
     */
    where: DisbursementWhereUniqueInput
  }

  /**
   * Disbursement findUniqueOrThrow
   */
  export type DisbursementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Disbursement
     */
    select?: DisbursementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisbursementInclude<ExtArgs> | null
    /**
     * Filter, which Disbursement to fetch.
     */
    where: DisbursementWhereUniqueInput
  }

  /**
   * Disbursement findFirst
   */
  export type DisbursementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Disbursement
     */
    select?: DisbursementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisbursementInclude<ExtArgs> | null
    /**
     * Filter, which Disbursement to fetch.
     */
    where?: DisbursementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Disbursements to fetch.
     */
    orderBy?: DisbursementOrderByWithRelationInput | DisbursementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Disbursements.
     */
    cursor?: DisbursementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Disbursements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Disbursements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Disbursements.
     */
    distinct?: DisbursementScalarFieldEnum | DisbursementScalarFieldEnum[]
  }

  /**
   * Disbursement findFirstOrThrow
   */
  export type DisbursementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Disbursement
     */
    select?: DisbursementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisbursementInclude<ExtArgs> | null
    /**
     * Filter, which Disbursement to fetch.
     */
    where?: DisbursementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Disbursements to fetch.
     */
    orderBy?: DisbursementOrderByWithRelationInput | DisbursementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Disbursements.
     */
    cursor?: DisbursementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Disbursements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Disbursements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Disbursements.
     */
    distinct?: DisbursementScalarFieldEnum | DisbursementScalarFieldEnum[]
  }

  /**
   * Disbursement findMany
   */
  export type DisbursementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Disbursement
     */
    select?: DisbursementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisbursementInclude<ExtArgs> | null
    /**
     * Filter, which Disbursements to fetch.
     */
    where?: DisbursementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Disbursements to fetch.
     */
    orderBy?: DisbursementOrderByWithRelationInput | DisbursementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Disbursements.
     */
    cursor?: DisbursementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Disbursements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Disbursements.
     */
    skip?: number
    distinct?: DisbursementScalarFieldEnum | DisbursementScalarFieldEnum[]
  }

  /**
   * Disbursement create
   */
  export type DisbursementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Disbursement
     */
    select?: DisbursementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisbursementInclude<ExtArgs> | null
    /**
     * The data needed to create a Disbursement.
     */
    data: XOR<DisbursementCreateInput, DisbursementUncheckedCreateInput>
  }

  /**
   * Disbursement createMany
   */
  export type DisbursementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Disbursements.
     */
    data: DisbursementCreateManyInput | DisbursementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Disbursement update
   */
  export type DisbursementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Disbursement
     */
    select?: DisbursementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisbursementInclude<ExtArgs> | null
    /**
     * The data needed to update a Disbursement.
     */
    data: XOR<DisbursementUpdateInput, DisbursementUncheckedUpdateInput>
    /**
     * Choose, which Disbursement to update.
     */
    where: DisbursementWhereUniqueInput
  }

  /**
   * Disbursement updateMany
   */
  export type DisbursementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Disbursements.
     */
    data: XOR<DisbursementUpdateManyMutationInput, DisbursementUncheckedUpdateManyInput>
    /**
     * Filter which Disbursements to update
     */
    where?: DisbursementWhereInput
  }

  /**
   * Disbursement upsert
   */
  export type DisbursementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Disbursement
     */
    select?: DisbursementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisbursementInclude<ExtArgs> | null
    /**
     * The filter to search for the Disbursement to update in case it exists.
     */
    where: DisbursementWhereUniqueInput
    /**
     * In case the Disbursement found by the `where` argument doesn't exist, create a new Disbursement with this data.
     */
    create: XOR<DisbursementCreateInput, DisbursementUncheckedCreateInput>
    /**
     * In case the Disbursement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DisbursementUpdateInput, DisbursementUncheckedUpdateInput>
  }

  /**
   * Disbursement delete
   */
  export type DisbursementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Disbursement
     */
    select?: DisbursementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisbursementInclude<ExtArgs> | null
    /**
     * Filter which Disbursement to delete.
     */
    where: DisbursementWhereUniqueInput
  }

  /**
   * Disbursement deleteMany
   */
  export type DisbursementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Disbursements to delete
     */
    where?: DisbursementWhereInput
  }

  /**
   * Disbursement.purchaseOrder
   */
  export type Disbursement$purchaseOrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    where?: PurchaseOrderWhereInput
  }

  /**
   * Disbursement without action
   */
  export type DisbursementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Disbursement
     */
    select?: DisbursementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisbursementInclude<ExtArgs> | null
  }


  /**
   * Model FinancialTransaction
   */

  export type AggregateFinancialTransaction = {
    _count: FinancialTransactionCountAggregateOutputType | null
    _avg: FinancialTransactionAvgAggregateOutputType | null
    _sum: FinancialTransactionSumAggregateOutputType | null
    _min: FinancialTransactionMinAggregateOutputType | null
    _max: FinancialTransactionMaxAggregateOutputType | null
  }

  export type FinancialTransactionAvgAggregateOutputType = {
    id: number | null
    projectId: number | null
    amount: Decimal | null
  }

  export type FinancialTransactionSumAggregateOutputType = {
    id: number | null
    projectId: number | null
    amount: Decimal | null
  }

  export type FinancialTransactionMinAggregateOutputType = {
    id: number | null
    projectId: number | null
    date: Date | null
    type: string | null
    category: string | null
    description: string | null
    amount: Decimal | null
    reference: string | null
  }

  export type FinancialTransactionMaxAggregateOutputType = {
    id: number | null
    projectId: number | null
    date: Date | null
    type: string | null
    category: string | null
    description: string | null
    amount: Decimal | null
    reference: string | null
  }

  export type FinancialTransactionCountAggregateOutputType = {
    id: number
    projectId: number
    date: number
    type: number
    category: number
    description: number
    amount: number
    reference: number
    metadata: number
    _all: number
  }


  export type FinancialTransactionAvgAggregateInputType = {
    id?: true
    projectId?: true
    amount?: true
  }

  export type FinancialTransactionSumAggregateInputType = {
    id?: true
    projectId?: true
    amount?: true
  }

  export type FinancialTransactionMinAggregateInputType = {
    id?: true
    projectId?: true
    date?: true
    type?: true
    category?: true
    description?: true
    amount?: true
    reference?: true
  }

  export type FinancialTransactionMaxAggregateInputType = {
    id?: true
    projectId?: true
    date?: true
    type?: true
    category?: true
    description?: true
    amount?: true
    reference?: true
  }

  export type FinancialTransactionCountAggregateInputType = {
    id?: true
    projectId?: true
    date?: true
    type?: true
    category?: true
    description?: true
    amount?: true
    reference?: true
    metadata?: true
    _all?: true
  }

  export type FinancialTransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FinancialTransaction to aggregate.
     */
    where?: FinancialTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FinancialTransactions to fetch.
     */
    orderBy?: FinancialTransactionOrderByWithRelationInput | FinancialTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FinancialTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FinancialTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FinancialTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FinancialTransactions
    **/
    _count?: true | FinancialTransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FinancialTransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FinancialTransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FinancialTransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FinancialTransactionMaxAggregateInputType
  }

  export type GetFinancialTransactionAggregateType<T extends FinancialTransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateFinancialTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFinancialTransaction[P]>
      : GetScalarType<T[P], AggregateFinancialTransaction[P]>
  }




  export type FinancialTransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FinancialTransactionWhereInput
    orderBy?: FinancialTransactionOrderByWithAggregationInput | FinancialTransactionOrderByWithAggregationInput[]
    by: FinancialTransactionScalarFieldEnum[] | FinancialTransactionScalarFieldEnum
    having?: FinancialTransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FinancialTransactionCountAggregateInputType | true
    _avg?: FinancialTransactionAvgAggregateInputType
    _sum?: FinancialTransactionSumAggregateInputType
    _min?: FinancialTransactionMinAggregateInputType
    _max?: FinancialTransactionMaxAggregateInputType
  }

  export type FinancialTransactionGroupByOutputType = {
    id: number
    projectId: number | null
    date: Date
    type: string
    category: string
    description: string | null
    amount: Decimal
    reference: string | null
    metadata: JsonValue | null
    _count: FinancialTransactionCountAggregateOutputType | null
    _avg: FinancialTransactionAvgAggregateOutputType | null
    _sum: FinancialTransactionSumAggregateOutputType | null
    _min: FinancialTransactionMinAggregateOutputType | null
    _max: FinancialTransactionMaxAggregateOutputType | null
  }

  type GetFinancialTransactionGroupByPayload<T extends FinancialTransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FinancialTransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FinancialTransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FinancialTransactionGroupByOutputType[P]>
            : GetScalarType<T[P], FinancialTransactionGroupByOutputType[P]>
        }
      >
    >


  export type FinancialTransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    date?: boolean
    type?: boolean
    category?: boolean
    description?: boolean
    amount?: boolean
    reference?: boolean
    metadata?: boolean
    project?: boolean | FinancialTransaction$projectArgs<ExtArgs>
  }, ExtArgs["result"]["financialTransaction"]>


  export type FinancialTransactionSelectScalar = {
    id?: boolean
    projectId?: boolean
    date?: boolean
    type?: boolean
    category?: boolean
    description?: boolean
    amount?: boolean
    reference?: boolean
    metadata?: boolean
  }

  export type FinancialTransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | FinancialTransaction$projectArgs<ExtArgs>
  }

  export type $FinancialTransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FinancialTransaction"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      projectId: number | null
      date: Date
      type: string
      category: string
      description: string | null
      amount: Prisma.Decimal
      reference: string | null
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["financialTransaction"]>
    composites: {}
  }

  type FinancialTransactionGetPayload<S extends boolean | null | undefined | FinancialTransactionDefaultArgs> = $Result.GetResult<Prisma.$FinancialTransactionPayload, S>

  type FinancialTransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FinancialTransactionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FinancialTransactionCountAggregateInputType | true
    }

  export interface FinancialTransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FinancialTransaction'], meta: { name: 'FinancialTransaction' } }
    /**
     * Find zero or one FinancialTransaction that matches the filter.
     * @param {FinancialTransactionFindUniqueArgs} args - Arguments to find a FinancialTransaction
     * @example
     * // Get one FinancialTransaction
     * const financialTransaction = await prisma.financialTransaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FinancialTransactionFindUniqueArgs>(args: SelectSubset<T, FinancialTransactionFindUniqueArgs<ExtArgs>>): Prisma__FinancialTransactionClient<$Result.GetResult<Prisma.$FinancialTransactionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one FinancialTransaction that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FinancialTransactionFindUniqueOrThrowArgs} args - Arguments to find a FinancialTransaction
     * @example
     * // Get one FinancialTransaction
     * const financialTransaction = await prisma.financialTransaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FinancialTransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, FinancialTransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FinancialTransactionClient<$Result.GetResult<Prisma.$FinancialTransactionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first FinancialTransaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialTransactionFindFirstArgs} args - Arguments to find a FinancialTransaction
     * @example
     * // Get one FinancialTransaction
     * const financialTransaction = await prisma.financialTransaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FinancialTransactionFindFirstArgs>(args?: SelectSubset<T, FinancialTransactionFindFirstArgs<ExtArgs>>): Prisma__FinancialTransactionClient<$Result.GetResult<Prisma.$FinancialTransactionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first FinancialTransaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialTransactionFindFirstOrThrowArgs} args - Arguments to find a FinancialTransaction
     * @example
     * // Get one FinancialTransaction
     * const financialTransaction = await prisma.financialTransaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FinancialTransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, FinancialTransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__FinancialTransactionClient<$Result.GetResult<Prisma.$FinancialTransactionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more FinancialTransactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialTransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FinancialTransactions
     * const financialTransactions = await prisma.financialTransaction.findMany()
     * 
     * // Get first 10 FinancialTransactions
     * const financialTransactions = await prisma.financialTransaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const financialTransactionWithIdOnly = await prisma.financialTransaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FinancialTransactionFindManyArgs>(args?: SelectSubset<T, FinancialTransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinancialTransactionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a FinancialTransaction.
     * @param {FinancialTransactionCreateArgs} args - Arguments to create a FinancialTransaction.
     * @example
     * // Create one FinancialTransaction
     * const FinancialTransaction = await prisma.financialTransaction.create({
     *   data: {
     *     // ... data to create a FinancialTransaction
     *   }
     * })
     * 
     */
    create<T extends FinancialTransactionCreateArgs>(args: SelectSubset<T, FinancialTransactionCreateArgs<ExtArgs>>): Prisma__FinancialTransactionClient<$Result.GetResult<Prisma.$FinancialTransactionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many FinancialTransactions.
     * @param {FinancialTransactionCreateManyArgs} args - Arguments to create many FinancialTransactions.
     * @example
     * // Create many FinancialTransactions
     * const financialTransaction = await prisma.financialTransaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FinancialTransactionCreateManyArgs>(args?: SelectSubset<T, FinancialTransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FinancialTransaction.
     * @param {FinancialTransactionDeleteArgs} args - Arguments to delete one FinancialTransaction.
     * @example
     * // Delete one FinancialTransaction
     * const FinancialTransaction = await prisma.financialTransaction.delete({
     *   where: {
     *     // ... filter to delete one FinancialTransaction
     *   }
     * })
     * 
     */
    delete<T extends FinancialTransactionDeleteArgs>(args: SelectSubset<T, FinancialTransactionDeleteArgs<ExtArgs>>): Prisma__FinancialTransactionClient<$Result.GetResult<Prisma.$FinancialTransactionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one FinancialTransaction.
     * @param {FinancialTransactionUpdateArgs} args - Arguments to update one FinancialTransaction.
     * @example
     * // Update one FinancialTransaction
     * const financialTransaction = await prisma.financialTransaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FinancialTransactionUpdateArgs>(args: SelectSubset<T, FinancialTransactionUpdateArgs<ExtArgs>>): Prisma__FinancialTransactionClient<$Result.GetResult<Prisma.$FinancialTransactionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more FinancialTransactions.
     * @param {FinancialTransactionDeleteManyArgs} args - Arguments to filter FinancialTransactions to delete.
     * @example
     * // Delete a few FinancialTransactions
     * const { count } = await prisma.financialTransaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FinancialTransactionDeleteManyArgs>(args?: SelectSubset<T, FinancialTransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FinancialTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialTransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FinancialTransactions
     * const financialTransaction = await prisma.financialTransaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FinancialTransactionUpdateManyArgs>(args: SelectSubset<T, FinancialTransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FinancialTransaction.
     * @param {FinancialTransactionUpsertArgs} args - Arguments to update or create a FinancialTransaction.
     * @example
     * // Update or create a FinancialTransaction
     * const financialTransaction = await prisma.financialTransaction.upsert({
     *   create: {
     *     // ... data to create a FinancialTransaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FinancialTransaction we want to update
     *   }
     * })
     */
    upsert<T extends FinancialTransactionUpsertArgs>(args: SelectSubset<T, FinancialTransactionUpsertArgs<ExtArgs>>): Prisma__FinancialTransactionClient<$Result.GetResult<Prisma.$FinancialTransactionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of FinancialTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialTransactionCountArgs} args - Arguments to filter FinancialTransactions to count.
     * @example
     * // Count the number of FinancialTransactions
     * const count = await prisma.financialTransaction.count({
     *   where: {
     *     // ... the filter for the FinancialTransactions we want to count
     *   }
     * })
    **/
    count<T extends FinancialTransactionCountArgs>(
      args?: Subset<T, FinancialTransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FinancialTransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FinancialTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialTransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FinancialTransactionAggregateArgs>(args: Subset<T, FinancialTransactionAggregateArgs>): Prisma.PrismaPromise<GetFinancialTransactionAggregateType<T>>

    /**
     * Group by FinancialTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialTransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FinancialTransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FinancialTransactionGroupByArgs['orderBy'] }
        : { orderBy?: FinancialTransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FinancialTransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFinancialTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FinancialTransaction model
   */
  readonly fields: FinancialTransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FinancialTransaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FinancialTransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends FinancialTransaction$projectArgs<ExtArgs> = {}>(args?: Subset<T, FinancialTransaction$projectArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FinancialTransaction model
   */ 
  interface FinancialTransactionFieldRefs {
    readonly id: FieldRef<"FinancialTransaction", 'Int'>
    readonly projectId: FieldRef<"FinancialTransaction", 'Int'>
    readonly date: FieldRef<"FinancialTransaction", 'DateTime'>
    readonly type: FieldRef<"FinancialTransaction", 'String'>
    readonly category: FieldRef<"FinancialTransaction", 'String'>
    readonly description: FieldRef<"FinancialTransaction", 'String'>
    readonly amount: FieldRef<"FinancialTransaction", 'Decimal'>
    readonly reference: FieldRef<"FinancialTransaction", 'String'>
    readonly metadata: FieldRef<"FinancialTransaction", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * FinancialTransaction findUnique
   */
  export type FinancialTransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialTransaction
     */
    select?: FinancialTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialTransactionInclude<ExtArgs> | null
    /**
     * Filter, which FinancialTransaction to fetch.
     */
    where: FinancialTransactionWhereUniqueInput
  }

  /**
   * FinancialTransaction findUniqueOrThrow
   */
  export type FinancialTransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialTransaction
     */
    select?: FinancialTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialTransactionInclude<ExtArgs> | null
    /**
     * Filter, which FinancialTransaction to fetch.
     */
    where: FinancialTransactionWhereUniqueInput
  }

  /**
   * FinancialTransaction findFirst
   */
  export type FinancialTransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialTransaction
     */
    select?: FinancialTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialTransactionInclude<ExtArgs> | null
    /**
     * Filter, which FinancialTransaction to fetch.
     */
    where?: FinancialTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FinancialTransactions to fetch.
     */
    orderBy?: FinancialTransactionOrderByWithRelationInput | FinancialTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FinancialTransactions.
     */
    cursor?: FinancialTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FinancialTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FinancialTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FinancialTransactions.
     */
    distinct?: FinancialTransactionScalarFieldEnum | FinancialTransactionScalarFieldEnum[]
  }

  /**
   * FinancialTransaction findFirstOrThrow
   */
  export type FinancialTransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialTransaction
     */
    select?: FinancialTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialTransactionInclude<ExtArgs> | null
    /**
     * Filter, which FinancialTransaction to fetch.
     */
    where?: FinancialTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FinancialTransactions to fetch.
     */
    orderBy?: FinancialTransactionOrderByWithRelationInput | FinancialTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FinancialTransactions.
     */
    cursor?: FinancialTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FinancialTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FinancialTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FinancialTransactions.
     */
    distinct?: FinancialTransactionScalarFieldEnum | FinancialTransactionScalarFieldEnum[]
  }

  /**
   * FinancialTransaction findMany
   */
  export type FinancialTransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialTransaction
     */
    select?: FinancialTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialTransactionInclude<ExtArgs> | null
    /**
     * Filter, which FinancialTransactions to fetch.
     */
    where?: FinancialTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FinancialTransactions to fetch.
     */
    orderBy?: FinancialTransactionOrderByWithRelationInput | FinancialTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FinancialTransactions.
     */
    cursor?: FinancialTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FinancialTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FinancialTransactions.
     */
    skip?: number
    distinct?: FinancialTransactionScalarFieldEnum | FinancialTransactionScalarFieldEnum[]
  }

  /**
   * FinancialTransaction create
   */
  export type FinancialTransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialTransaction
     */
    select?: FinancialTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialTransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a FinancialTransaction.
     */
    data: XOR<FinancialTransactionCreateInput, FinancialTransactionUncheckedCreateInput>
  }

  /**
   * FinancialTransaction createMany
   */
  export type FinancialTransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FinancialTransactions.
     */
    data: FinancialTransactionCreateManyInput | FinancialTransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FinancialTransaction update
   */
  export type FinancialTransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialTransaction
     */
    select?: FinancialTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialTransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a FinancialTransaction.
     */
    data: XOR<FinancialTransactionUpdateInput, FinancialTransactionUncheckedUpdateInput>
    /**
     * Choose, which FinancialTransaction to update.
     */
    where: FinancialTransactionWhereUniqueInput
  }

  /**
   * FinancialTransaction updateMany
   */
  export type FinancialTransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FinancialTransactions.
     */
    data: XOR<FinancialTransactionUpdateManyMutationInput, FinancialTransactionUncheckedUpdateManyInput>
    /**
     * Filter which FinancialTransactions to update
     */
    where?: FinancialTransactionWhereInput
  }

  /**
   * FinancialTransaction upsert
   */
  export type FinancialTransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialTransaction
     */
    select?: FinancialTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialTransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the FinancialTransaction to update in case it exists.
     */
    where: FinancialTransactionWhereUniqueInput
    /**
     * In case the FinancialTransaction found by the `where` argument doesn't exist, create a new FinancialTransaction with this data.
     */
    create: XOR<FinancialTransactionCreateInput, FinancialTransactionUncheckedCreateInput>
    /**
     * In case the FinancialTransaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FinancialTransactionUpdateInput, FinancialTransactionUncheckedUpdateInput>
  }

  /**
   * FinancialTransaction delete
   */
  export type FinancialTransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialTransaction
     */
    select?: FinancialTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialTransactionInclude<ExtArgs> | null
    /**
     * Filter which FinancialTransaction to delete.
     */
    where: FinancialTransactionWhereUniqueInput
  }

  /**
   * FinancialTransaction deleteMany
   */
  export type FinancialTransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FinancialTransactions to delete
     */
    where?: FinancialTransactionWhereInput
  }

  /**
   * FinancialTransaction.project
   */
  export type FinancialTransaction$projectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
  }

  /**
   * FinancialTransaction without action
   */
  export type FinancialTransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialTransaction
     */
    select?: FinancialTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialTransactionInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    password: 'password',
    role: 'role',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const CompanyScalarFieldEnum: {
    id: 'id',
    name: 'name',
    address: 'address',
    taxId: 'taxId',
    currency: 'currency',
    logoUrl: 'logoUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CompanyScalarFieldEnum = (typeof CompanyScalarFieldEnum)[keyof typeof CompanyScalarFieldEnum]


  export const ClientScalarFieldEnum: {
    id: 'id',
    name: 'name',
    contactPerson: 'contactPerson',
    contractType: 'contractType',
    paymentTerms: 'paymentTerms',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ClientScalarFieldEnum = (typeof ClientScalarFieldEnum)[keyof typeof ClientScalarFieldEnum]


  export const ProjectScalarFieldEnum: {
    id: 'id',
    clientId: 'clientId',
    name: 'name',
    location: 'location',
    duration: 'duration',
    budget: 'budget',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    totalFloorArea: 'totalFloorArea',
    carportArea: 'carportArea'
  };

  export type ProjectScalarFieldEnum = (typeof ProjectScalarFieldEnum)[keyof typeof ProjectScalarFieldEnum]


  export const ProjectMemberScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    userId: 'userId',
    role: 'role',
    assignedAt: 'assignedAt'
  };

  export type ProjectMemberScalarFieldEnum = (typeof ProjectMemberScalarFieldEnum)[keyof typeof ProjectMemberScalarFieldEnum]


  export const BoqItemScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    itemDescription: 'itemDescription',
    unit: 'unit',
    materialUnitPrice: 'materialUnitPrice',
    laborUnitPrice: 'laborUnitPrice',
    quantity: 'quantity',
    isCarport: 'isCarport'
  };

  export type BoqItemScalarFieldEnum = (typeof BoqItemScalarFieldEnum)[keyof typeof BoqItemScalarFieldEnum]


  export const BoqItemComponentScalarFieldEnum: {
    id: 'id',
    boqItemId: 'boqItemId',
    resourceType: 'resourceType',
    name: 'name',
    quantityFactor: 'quantityFactor',
    unitRate: 'unitRate',
    totalComponentCost: 'totalComponentCost',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BoqItemComponentScalarFieldEnum = (typeof BoqItemComponentScalarFieldEnum)[keyof typeof BoqItemComponentScalarFieldEnum]


  export const MaterialRequestScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    requesterId: 'requesterId',
    approverId: 'approverId',
    requestDate: 'requestDate',
    status: 'status',
    remarks: 'remarks',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MaterialRequestScalarFieldEnum = (typeof MaterialRequestScalarFieldEnum)[keyof typeof MaterialRequestScalarFieldEnum]


  export const MaterialRequestItemScalarFieldEnum: {
    id: 'id',
    materialRequestId: 'materialRequestId',
    itemDescription: 'itemDescription',
    description: 'description',
    quantity: 'quantity',
    materialUnitPrice: 'materialUnitPrice',
    laborUnitPrice: 'laborUnitPrice',
    unit: 'unit'
  };

  export type MaterialRequestItemScalarFieldEnum = (typeof MaterialRequestItemScalarFieldEnum)[keyof typeof MaterialRequestItemScalarFieldEnum]


  export const RFQScalarFieldEnum: {
    id: 'id',
    mrId: 'mrId',
    createdById: 'createdById',
    title: 'title',
    status: 'status',
    dueDate: 'dueDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RFQScalarFieldEnum = (typeof RFQScalarFieldEnum)[keyof typeof RFQScalarFieldEnum]


  export const RFQItemScalarFieldEnum: {
    id: 'id',
    rfqId: 'rfqId',
    materialName: 'materialName',
    quantity: 'quantity',
    unit: 'unit'
  };

  export type RFQItemScalarFieldEnum = (typeof RFQItemScalarFieldEnum)[keyof typeof RFQItemScalarFieldEnum]


  export const SupplierScalarFieldEnum: {
    id: 'id',
    name: 'name',
    contactPerson: 'contactPerson',
    email: 'email',
    phone: 'phone',
    address: 'address',
    rating: 'rating'
  };

  export type SupplierScalarFieldEnum = (typeof SupplierScalarFieldEnum)[keyof typeof SupplierScalarFieldEnum]


  export const MaterialScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    description: 'description',
    unit: 'unit',
    category: 'category',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MaterialScalarFieldEnum = (typeof MaterialScalarFieldEnum)[keyof typeof MaterialScalarFieldEnum]


  export const UnitScalarFieldEnum: {
    id: 'id',
    name: 'name',
    abbreviation: 'abbreviation',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UnitScalarFieldEnum = (typeof UnitScalarFieldEnum)[keyof typeof UnitScalarFieldEnum]


  export const CategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


  export const WarehouseScalarFieldEnum: {
    id: 'id',
    name: 'name',
    location: 'location',
    type: 'type'
  };

  export type WarehouseScalarFieldEnum = (typeof WarehouseScalarFieldEnum)[keyof typeof WarehouseScalarFieldEnum]


  export const SupplierQuotationScalarFieldEnum: {
    id: 'id',
    rfqId: 'rfqId',
    supplierId: 'supplierId',
    quoteDate: 'quoteDate',
    totalAmount: 'totalAmount',
    currency: 'currency',
    isSelected: 'isSelected'
  };

  export type SupplierQuotationScalarFieldEnum = (typeof SupplierQuotationScalarFieldEnum)[keyof typeof SupplierQuotationScalarFieldEnum]


  export const QuotationItemScalarFieldEnum: {
    id: 'id',
    supplierQuotationId: 'supplierQuotationId',
    materialName: 'materialName',
    quantity: 'quantity',
    unitPrice: 'unitPrice',
    totalPrice: 'totalPrice',
    remarks: 'remarks'
  };

  export type QuotationItemScalarFieldEnum = (typeof QuotationItemScalarFieldEnum)[keyof typeof QuotationItemScalarFieldEnum]


  export const PurchaseOrderScalarFieldEnum: {
    id: 'id',
    orderDate: 'orderDate',
    projectId: 'projectId',
    supplierId: 'supplierId',
    requesterId: 'requesterId',
    approverId: 'approverId',
    status: 'status',
    remarks: 'remarks',
    totalAmount: 'totalAmount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PurchaseOrderScalarFieldEnum = (typeof PurchaseOrderScalarFieldEnum)[keyof typeof PurchaseOrderScalarFieldEnum]


  export const PurchaseOrderItemScalarFieldEnum: {
    id: 'id',
    purchaseOrderId: 'purchaseOrderId',
    materialName: 'materialName',
    description: 'description',
    quantity: 'quantity',
    unit: 'unit',
    unitPrice: 'unitPrice',
    totalPrice: 'totalPrice'
  };

  export type PurchaseOrderItemScalarFieldEnum = (typeof PurchaseOrderItemScalarFieldEnum)[keyof typeof PurchaseOrderItemScalarFieldEnum]


  export const ReceivingReportScalarFieldEnum: {
    id: 'id',
    purchaseOrderId: 'purchaseOrderId',
    receivedById: 'receivedById',
    receivedDate: 'receivedDate',
    deliveryNoteNo: 'deliveryNoteNo',
    notes: 'notes'
  };

  export type ReceivingReportScalarFieldEnum = (typeof ReceivingReportScalarFieldEnum)[keyof typeof ReceivingReportScalarFieldEnum]


  export const ReceivingItemScalarFieldEnum: {
    id: 'id',
    receivingReportId: 'receivingReportId',
    materialName: 'materialName',
    quantityReceived: 'quantityReceived',
    status: 'status'
  };

  export type ReceivingItemScalarFieldEnum = (typeof ReceivingItemScalarFieldEnum)[keyof typeof ReceivingItemScalarFieldEnum]


  export const InventoryItemScalarFieldEnum: {
    id: 'id',
    materialName: 'materialName',
    projectId: 'projectId',
    warehouseId: 'warehouseId',
    quantity: 'quantity',
    unit: 'unit',
    lastUpdated: 'lastUpdated'
  };

  export type InventoryItemScalarFieldEnum = (typeof InventoryItemScalarFieldEnum)[keyof typeof InventoryItemScalarFieldEnum]


  export const WorkflowRuleScalarFieldEnum: {
    id: 'id',
    processType: 'processType',
    minAmount: 'minAmount',
    maxAmount: 'maxAmount',
    approverRole: 'approverRole',
    stepOrder: 'stepOrder',
    updatedAt: 'updatedAt'
  };

  export type WorkflowRuleScalarFieldEnum = (typeof WorkflowRuleScalarFieldEnum)[keyof typeof WorkflowRuleScalarFieldEnum]


  export const SupplierInvoiceScalarFieldEnum: {
    id: 'id',
    invoiceNumber: 'invoiceNumber',
    invoiceDate: 'invoiceDate',
    supplierId: 'supplierId',
    purchaseOrderId: 'purchaseOrderId',
    receivingReportId: 'receivingReportId',
    totalAmount: 'totalAmount',
    status: 'status',
    createdAt: 'createdAt'
  };

  export type SupplierInvoiceScalarFieldEnum = (typeof SupplierInvoiceScalarFieldEnum)[keyof typeof SupplierInvoiceScalarFieldEnum]


  export const DisbursementScalarFieldEnum: {
    id: 'id',
    purchaseOrderId: 'purchaseOrderId',
    processedById: 'processedById',
    amount: 'amount',
    paymentDate: 'paymentDate',
    method: 'method',
    referenceNumber: 'referenceNumber',
    status: 'status'
  };

  export type DisbursementScalarFieldEnum = (typeof DisbursementScalarFieldEnum)[keyof typeof DisbursementScalarFieldEnum]


  export const FinancialTransactionScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    date: 'date',
    type: 'type',
    category: 'category',
    description: 'description',
    amount: 'amount',
    reference: 'reference',
    metadata: 'metadata'
  };

  export type FinancialTransactionScalarFieldEnum = (typeof FinancialTransactionScalarFieldEnum)[keyof typeof FinancialTransactionScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'ResourceType'
   */
  export type EnumResourceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ResourceType'>
    


  /**
   * Reference to a field of type 'MrStatus'
   */
  export type EnumMrStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MrStatus'>
    


  /**
   * Reference to a field of type 'RfqStatus'
   */
  export type EnumRfqStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RfqStatus'>
    


  /**
   * Reference to a field of type 'PoStatus'
   */
  export type EnumPoStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PoStatus'>
    


  /**
   * Reference to a field of type 'PaymentMethod'
   */
  export type EnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    email?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    purchaseOrders?: PurchaseOrderListRelationFilter
    poApprovals?: PurchaseOrderListRelationFilter
    materialRequests?: MaterialRequestListRelationFilter
    mrApprovals?: MaterialRequestListRelationFilter
    rfqsCreated?: RFQListRelationFilter
    receivedItems?: ReceivingReportListRelationFilter
    disbursements?: DisbursementListRelationFilter
    projectMembers?: ProjectMemberListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    purchaseOrders?: PurchaseOrderOrderByRelationAggregateInput
    poApprovals?: PurchaseOrderOrderByRelationAggregateInput
    materialRequests?: MaterialRequestOrderByRelationAggregateInput
    mrApprovals?: MaterialRequestOrderByRelationAggregateInput
    rfqsCreated?: RFQOrderByRelationAggregateInput
    receivedItems?: ReceivingReportOrderByRelationAggregateInput
    disbursements?: DisbursementOrderByRelationAggregateInput
    projectMembers?: ProjectMemberOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    purchaseOrders?: PurchaseOrderListRelationFilter
    poApprovals?: PurchaseOrderListRelationFilter
    materialRequests?: MaterialRequestListRelationFilter
    mrApprovals?: MaterialRequestListRelationFilter
    rfqsCreated?: RFQListRelationFilter
    receivedItems?: ReceivingReportListRelationFilter
    disbursements?: DisbursementListRelationFilter
    projectMembers?: ProjectMemberListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    email?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type CompanyWhereInput = {
    AND?: CompanyWhereInput | CompanyWhereInput[]
    OR?: CompanyWhereInput[]
    NOT?: CompanyWhereInput | CompanyWhereInput[]
    id?: IntFilter<"Company"> | number
    name?: StringFilter<"Company"> | string
    address?: StringNullableFilter<"Company"> | string | null
    taxId?: StringNullableFilter<"Company"> | string | null
    currency?: StringFilter<"Company"> | string
    logoUrl?: StringNullableFilter<"Company"> | string | null
    createdAt?: DateTimeFilter<"Company"> | Date | string
    updatedAt?: DateTimeFilter<"Company"> | Date | string
  }

  export type CompanyOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrderInput | SortOrder
    taxId?: SortOrderInput | SortOrder
    currency?: SortOrder
    logoUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanyWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CompanyWhereInput | CompanyWhereInput[]
    OR?: CompanyWhereInput[]
    NOT?: CompanyWhereInput | CompanyWhereInput[]
    name?: StringFilter<"Company"> | string
    address?: StringNullableFilter<"Company"> | string | null
    taxId?: StringNullableFilter<"Company"> | string | null
    currency?: StringFilter<"Company"> | string
    logoUrl?: StringNullableFilter<"Company"> | string | null
    createdAt?: DateTimeFilter<"Company"> | Date | string
    updatedAt?: DateTimeFilter<"Company"> | Date | string
  }, "id">

  export type CompanyOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrderInput | SortOrder
    taxId?: SortOrderInput | SortOrder
    currency?: SortOrder
    logoUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CompanyCountOrderByAggregateInput
    _avg?: CompanyAvgOrderByAggregateInput
    _max?: CompanyMaxOrderByAggregateInput
    _min?: CompanyMinOrderByAggregateInput
    _sum?: CompanySumOrderByAggregateInput
  }

  export type CompanyScalarWhereWithAggregatesInput = {
    AND?: CompanyScalarWhereWithAggregatesInput | CompanyScalarWhereWithAggregatesInput[]
    OR?: CompanyScalarWhereWithAggregatesInput[]
    NOT?: CompanyScalarWhereWithAggregatesInput | CompanyScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Company"> | number
    name?: StringWithAggregatesFilter<"Company"> | string
    address?: StringNullableWithAggregatesFilter<"Company"> | string | null
    taxId?: StringNullableWithAggregatesFilter<"Company"> | string | null
    currency?: StringWithAggregatesFilter<"Company"> | string
    logoUrl?: StringNullableWithAggregatesFilter<"Company"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Company"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Company"> | Date | string
  }

  export type ClientWhereInput = {
    AND?: ClientWhereInput | ClientWhereInput[]
    OR?: ClientWhereInput[]
    NOT?: ClientWhereInput | ClientWhereInput[]
    id?: IntFilter<"Client"> | number
    name?: StringFilter<"Client"> | string
    contactPerson?: StringNullableFilter<"Client"> | string | null
    contractType?: StringNullableFilter<"Client"> | string | null
    paymentTerms?: StringNullableFilter<"Client"> | string | null
    createdAt?: DateTimeFilter<"Client"> | Date | string
    updatedAt?: DateTimeFilter<"Client"> | Date | string
    projects?: ProjectListRelationFilter
  }

  export type ClientOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    contactPerson?: SortOrderInput | SortOrder
    contractType?: SortOrderInput | SortOrder
    paymentTerms?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projects?: ProjectOrderByRelationAggregateInput
  }

  export type ClientWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ClientWhereInput | ClientWhereInput[]
    OR?: ClientWhereInput[]
    NOT?: ClientWhereInput | ClientWhereInput[]
    name?: StringFilter<"Client"> | string
    contactPerson?: StringNullableFilter<"Client"> | string | null
    contractType?: StringNullableFilter<"Client"> | string | null
    paymentTerms?: StringNullableFilter<"Client"> | string | null
    createdAt?: DateTimeFilter<"Client"> | Date | string
    updatedAt?: DateTimeFilter<"Client"> | Date | string
    projects?: ProjectListRelationFilter
  }, "id">

  export type ClientOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    contactPerson?: SortOrderInput | SortOrder
    contractType?: SortOrderInput | SortOrder
    paymentTerms?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ClientCountOrderByAggregateInput
    _avg?: ClientAvgOrderByAggregateInput
    _max?: ClientMaxOrderByAggregateInput
    _min?: ClientMinOrderByAggregateInput
    _sum?: ClientSumOrderByAggregateInput
  }

  export type ClientScalarWhereWithAggregatesInput = {
    AND?: ClientScalarWhereWithAggregatesInput | ClientScalarWhereWithAggregatesInput[]
    OR?: ClientScalarWhereWithAggregatesInput[]
    NOT?: ClientScalarWhereWithAggregatesInput | ClientScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Client"> | number
    name?: StringWithAggregatesFilter<"Client"> | string
    contactPerson?: StringNullableWithAggregatesFilter<"Client"> | string | null
    contractType?: StringNullableWithAggregatesFilter<"Client"> | string | null
    paymentTerms?: StringNullableWithAggregatesFilter<"Client"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Client"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Client"> | Date | string
  }

  export type ProjectWhereInput = {
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    id?: IntFilter<"Project"> | number
    clientId?: IntNullableFilter<"Project"> | number | null
    name?: StringFilter<"Project"> | string
    location?: StringNullableFilter<"Project"> | string | null
    duration?: StringNullableFilter<"Project"> | string | null
    budget?: DecimalFilter<"Project"> | Decimal | DecimalJsLike | number | string
    status?: StringFilter<"Project"> | string
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    totalFloorArea?: DecimalNullableFilter<"Project"> | Decimal | DecimalJsLike | number | string | null
    carportArea?: DecimalNullableFilter<"Project"> | Decimal | DecimalJsLike | number | string | null
    client?: XOR<ClientNullableRelationFilter, ClientWhereInput> | null
    transactions?: FinancialTransactionListRelationFilter
    inventory?: InventoryItemListRelationFilter
    teamMembers?: ProjectMemberListRelationFilter
    boqItems?: BoqItemListRelationFilter
    purchaseOrders?: PurchaseOrderListRelationFilter
    materialRequests?: MaterialRequestListRelationFilter
  }

  export type ProjectOrderByWithRelationInput = {
    id?: SortOrder
    clientId?: SortOrderInput | SortOrder
    name?: SortOrder
    location?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    budget?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    totalFloorArea?: SortOrderInput | SortOrder
    carportArea?: SortOrderInput | SortOrder
    client?: ClientOrderByWithRelationInput
    transactions?: FinancialTransactionOrderByRelationAggregateInput
    inventory?: InventoryItemOrderByRelationAggregateInput
    teamMembers?: ProjectMemberOrderByRelationAggregateInput
    boqItems?: BoqItemOrderByRelationAggregateInput
    purchaseOrders?: PurchaseOrderOrderByRelationAggregateInput
    materialRequests?: MaterialRequestOrderByRelationAggregateInput
  }

  export type ProjectWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    clientId?: IntNullableFilter<"Project"> | number | null
    name?: StringFilter<"Project"> | string
    location?: StringNullableFilter<"Project"> | string | null
    duration?: StringNullableFilter<"Project"> | string | null
    budget?: DecimalFilter<"Project"> | Decimal | DecimalJsLike | number | string
    status?: StringFilter<"Project"> | string
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    totalFloorArea?: DecimalNullableFilter<"Project"> | Decimal | DecimalJsLike | number | string | null
    carportArea?: DecimalNullableFilter<"Project"> | Decimal | DecimalJsLike | number | string | null
    client?: XOR<ClientNullableRelationFilter, ClientWhereInput> | null
    transactions?: FinancialTransactionListRelationFilter
    inventory?: InventoryItemListRelationFilter
    teamMembers?: ProjectMemberListRelationFilter
    boqItems?: BoqItemListRelationFilter
    purchaseOrders?: PurchaseOrderListRelationFilter
    materialRequests?: MaterialRequestListRelationFilter
  }, "id">

  export type ProjectOrderByWithAggregationInput = {
    id?: SortOrder
    clientId?: SortOrderInput | SortOrder
    name?: SortOrder
    location?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    budget?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    totalFloorArea?: SortOrderInput | SortOrder
    carportArea?: SortOrderInput | SortOrder
    _count?: ProjectCountOrderByAggregateInput
    _avg?: ProjectAvgOrderByAggregateInput
    _max?: ProjectMaxOrderByAggregateInput
    _min?: ProjectMinOrderByAggregateInput
    _sum?: ProjectSumOrderByAggregateInput
  }

  export type ProjectScalarWhereWithAggregatesInput = {
    AND?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    OR?: ProjectScalarWhereWithAggregatesInput[]
    NOT?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Project"> | number
    clientId?: IntNullableWithAggregatesFilter<"Project"> | number | null
    name?: StringWithAggregatesFilter<"Project"> | string
    location?: StringNullableWithAggregatesFilter<"Project"> | string | null
    duration?: StringNullableWithAggregatesFilter<"Project"> | string | null
    budget?: DecimalWithAggregatesFilter<"Project"> | Decimal | DecimalJsLike | number | string
    status?: StringWithAggregatesFilter<"Project"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Project"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Project"> | Date | string
    totalFloorArea?: DecimalNullableWithAggregatesFilter<"Project"> | Decimal | DecimalJsLike | number | string | null
    carportArea?: DecimalNullableWithAggregatesFilter<"Project"> | Decimal | DecimalJsLike | number | string | null
  }

  export type ProjectMemberWhereInput = {
    AND?: ProjectMemberWhereInput | ProjectMemberWhereInput[]
    OR?: ProjectMemberWhereInput[]
    NOT?: ProjectMemberWhereInput | ProjectMemberWhereInput[]
    id?: IntFilter<"ProjectMember"> | number
    projectId?: IntFilter<"ProjectMember"> | number
    userId?: IntFilter<"ProjectMember"> | number
    role?: StringFilter<"ProjectMember"> | string
    assignedAt?: DateTimeFilter<"ProjectMember"> | Date | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ProjectMemberOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    assignedAt?: SortOrder
    project?: ProjectOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ProjectMemberWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProjectMemberWhereInput | ProjectMemberWhereInput[]
    OR?: ProjectMemberWhereInput[]
    NOT?: ProjectMemberWhereInput | ProjectMemberWhereInput[]
    projectId?: IntFilter<"ProjectMember"> | number
    userId?: IntFilter<"ProjectMember"> | number
    role?: StringFilter<"ProjectMember"> | string
    assignedAt?: DateTimeFilter<"ProjectMember"> | Date | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type ProjectMemberOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    assignedAt?: SortOrder
    _count?: ProjectMemberCountOrderByAggregateInput
    _avg?: ProjectMemberAvgOrderByAggregateInput
    _max?: ProjectMemberMaxOrderByAggregateInput
    _min?: ProjectMemberMinOrderByAggregateInput
    _sum?: ProjectMemberSumOrderByAggregateInput
  }

  export type ProjectMemberScalarWhereWithAggregatesInput = {
    AND?: ProjectMemberScalarWhereWithAggregatesInput | ProjectMemberScalarWhereWithAggregatesInput[]
    OR?: ProjectMemberScalarWhereWithAggregatesInput[]
    NOT?: ProjectMemberScalarWhereWithAggregatesInput | ProjectMemberScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProjectMember"> | number
    projectId?: IntWithAggregatesFilter<"ProjectMember"> | number
    userId?: IntWithAggregatesFilter<"ProjectMember"> | number
    role?: StringWithAggregatesFilter<"ProjectMember"> | string
    assignedAt?: DateTimeWithAggregatesFilter<"ProjectMember"> | Date | string
  }

  export type BoqItemWhereInput = {
    AND?: BoqItemWhereInput | BoqItemWhereInput[]
    OR?: BoqItemWhereInput[]
    NOT?: BoqItemWhereInput | BoqItemWhereInput[]
    id?: IntFilter<"BoqItem"> | number
    projectId?: IntFilter<"BoqItem"> | number
    itemDescription?: StringFilter<"BoqItem"> | string
    unit?: StringFilter<"BoqItem"> | string
    materialUnitPrice?: DecimalFilter<"BoqItem"> | Decimal | DecimalJsLike | number | string
    laborUnitPrice?: DecimalFilter<"BoqItem"> | Decimal | DecimalJsLike | number | string
    quantity?: DecimalFilter<"BoqItem"> | Decimal | DecimalJsLike | number | string
    isCarport?: BoolFilter<"BoqItem"> | boolean
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    boqComponents?: BoqItemComponentListRelationFilter
  }

  export type BoqItemOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    itemDescription?: SortOrder
    unit?: SortOrder
    materialUnitPrice?: SortOrder
    laborUnitPrice?: SortOrder
    quantity?: SortOrder
    isCarport?: SortOrder
    project?: ProjectOrderByWithRelationInput
    boqComponents?: BoqItemComponentOrderByRelationAggregateInput
  }

  export type BoqItemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    projectId_itemDescription?: BoqItemProjectIdItemDescriptionCompoundUniqueInput
    AND?: BoqItemWhereInput | BoqItemWhereInput[]
    OR?: BoqItemWhereInput[]
    NOT?: BoqItemWhereInput | BoqItemWhereInput[]
    projectId?: IntFilter<"BoqItem"> | number
    itemDescription?: StringFilter<"BoqItem"> | string
    unit?: StringFilter<"BoqItem"> | string
    materialUnitPrice?: DecimalFilter<"BoqItem"> | Decimal | DecimalJsLike | number | string
    laborUnitPrice?: DecimalFilter<"BoqItem"> | Decimal | DecimalJsLike | number | string
    quantity?: DecimalFilter<"BoqItem"> | Decimal | DecimalJsLike | number | string
    isCarport?: BoolFilter<"BoqItem"> | boolean
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    boqComponents?: BoqItemComponentListRelationFilter
  }, "id" | "projectId_itemDescription">

  export type BoqItemOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    itemDescription?: SortOrder
    unit?: SortOrder
    materialUnitPrice?: SortOrder
    laborUnitPrice?: SortOrder
    quantity?: SortOrder
    isCarport?: SortOrder
    _count?: BoqItemCountOrderByAggregateInput
    _avg?: BoqItemAvgOrderByAggregateInput
    _max?: BoqItemMaxOrderByAggregateInput
    _min?: BoqItemMinOrderByAggregateInput
    _sum?: BoqItemSumOrderByAggregateInput
  }

  export type BoqItemScalarWhereWithAggregatesInput = {
    AND?: BoqItemScalarWhereWithAggregatesInput | BoqItemScalarWhereWithAggregatesInput[]
    OR?: BoqItemScalarWhereWithAggregatesInput[]
    NOT?: BoqItemScalarWhereWithAggregatesInput | BoqItemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BoqItem"> | number
    projectId?: IntWithAggregatesFilter<"BoqItem"> | number
    itemDescription?: StringWithAggregatesFilter<"BoqItem"> | string
    unit?: StringWithAggregatesFilter<"BoqItem"> | string
    materialUnitPrice?: DecimalWithAggregatesFilter<"BoqItem"> | Decimal | DecimalJsLike | number | string
    laborUnitPrice?: DecimalWithAggregatesFilter<"BoqItem"> | Decimal | DecimalJsLike | number | string
    quantity?: DecimalWithAggregatesFilter<"BoqItem"> | Decimal | DecimalJsLike | number | string
    isCarport?: BoolWithAggregatesFilter<"BoqItem"> | boolean
  }

  export type BoqItemComponentWhereInput = {
    AND?: BoqItemComponentWhereInput | BoqItemComponentWhereInput[]
    OR?: BoqItemComponentWhereInput[]
    NOT?: BoqItemComponentWhereInput | BoqItemComponentWhereInput[]
    id?: IntFilter<"BoqItemComponent"> | number
    boqItemId?: IntFilter<"BoqItemComponent"> | number
    resourceType?: EnumResourceTypeFilter<"BoqItemComponent"> | $Enums.ResourceType
    name?: StringFilter<"BoqItemComponent"> | string
    quantityFactor?: DecimalFilter<"BoqItemComponent"> | Decimal | DecimalJsLike | number | string
    unitRate?: DecimalFilter<"BoqItemComponent"> | Decimal | DecimalJsLike | number | string
    totalComponentCost?: DecimalFilter<"BoqItemComponent"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"BoqItemComponent"> | Date | string
    updatedAt?: DateTimeFilter<"BoqItemComponent"> | Date | string
    boqItem?: XOR<BoqItemRelationFilter, BoqItemWhereInput>
  }

  export type BoqItemComponentOrderByWithRelationInput = {
    id?: SortOrder
    boqItemId?: SortOrder
    resourceType?: SortOrder
    name?: SortOrder
    quantityFactor?: SortOrder
    unitRate?: SortOrder
    totalComponentCost?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    boqItem?: BoqItemOrderByWithRelationInput
  }

  export type BoqItemComponentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BoqItemComponentWhereInput | BoqItemComponentWhereInput[]
    OR?: BoqItemComponentWhereInput[]
    NOT?: BoqItemComponentWhereInput | BoqItemComponentWhereInput[]
    boqItemId?: IntFilter<"BoqItemComponent"> | number
    resourceType?: EnumResourceTypeFilter<"BoqItemComponent"> | $Enums.ResourceType
    name?: StringFilter<"BoqItemComponent"> | string
    quantityFactor?: DecimalFilter<"BoqItemComponent"> | Decimal | DecimalJsLike | number | string
    unitRate?: DecimalFilter<"BoqItemComponent"> | Decimal | DecimalJsLike | number | string
    totalComponentCost?: DecimalFilter<"BoqItemComponent"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"BoqItemComponent"> | Date | string
    updatedAt?: DateTimeFilter<"BoqItemComponent"> | Date | string
    boqItem?: XOR<BoqItemRelationFilter, BoqItemWhereInput>
  }, "id">

  export type BoqItemComponentOrderByWithAggregationInput = {
    id?: SortOrder
    boqItemId?: SortOrder
    resourceType?: SortOrder
    name?: SortOrder
    quantityFactor?: SortOrder
    unitRate?: SortOrder
    totalComponentCost?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BoqItemComponentCountOrderByAggregateInput
    _avg?: BoqItemComponentAvgOrderByAggregateInput
    _max?: BoqItemComponentMaxOrderByAggregateInput
    _min?: BoqItemComponentMinOrderByAggregateInput
    _sum?: BoqItemComponentSumOrderByAggregateInput
  }

  export type BoqItemComponentScalarWhereWithAggregatesInput = {
    AND?: BoqItemComponentScalarWhereWithAggregatesInput | BoqItemComponentScalarWhereWithAggregatesInput[]
    OR?: BoqItemComponentScalarWhereWithAggregatesInput[]
    NOT?: BoqItemComponentScalarWhereWithAggregatesInput | BoqItemComponentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BoqItemComponent"> | number
    boqItemId?: IntWithAggregatesFilter<"BoqItemComponent"> | number
    resourceType?: EnumResourceTypeWithAggregatesFilter<"BoqItemComponent"> | $Enums.ResourceType
    name?: StringWithAggregatesFilter<"BoqItemComponent"> | string
    quantityFactor?: DecimalWithAggregatesFilter<"BoqItemComponent"> | Decimal | DecimalJsLike | number | string
    unitRate?: DecimalWithAggregatesFilter<"BoqItemComponent"> | Decimal | DecimalJsLike | number | string
    totalComponentCost?: DecimalWithAggregatesFilter<"BoqItemComponent"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter<"BoqItemComponent"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BoqItemComponent"> | Date | string
  }

  export type MaterialRequestWhereInput = {
    AND?: MaterialRequestWhereInput | MaterialRequestWhereInput[]
    OR?: MaterialRequestWhereInput[]
    NOT?: MaterialRequestWhereInput | MaterialRequestWhereInput[]
    id?: IntFilter<"MaterialRequest"> | number
    projectId?: IntFilter<"MaterialRequest"> | number
    requesterId?: IntFilter<"MaterialRequest"> | number
    approverId?: IntNullableFilter<"MaterialRequest"> | number | null
    requestDate?: DateTimeFilter<"MaterialRequest"> | Date | string
    status?: EnumMrStatusFilter<"MaterialRequest"> | $Enums.MrStatus
    remarks?: StringNullableFilter<"MaterialRequest"> | string | null
    createdAt?: DateTimeFilter<"MaterialRequest"> | Date | string
    updatedAt?: DateTimeFilter<"MaterialRequest"> | Date | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    requester?: XOR<UserRelationFilter, UserWhereInput>
    approver?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    items?: MaterialRequestItemListRelationFilter
    rfqs?: RFQListRelationFilter
  }

  export type MaterialRequestOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    requesterId?: SortOrder
    approverId?: SortOrderInput | SortOrder
    requestDate?: SortOrder
    status?: SortOrder
    remarks?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    project?: ProjectOrderByWithRelationInput
    requester?: UserOrderByWithRelationInput
    approver?: UserOrderByWithRelationInput
    items?: MaterialRequestItemOrderByRelationAggregateInput
    rfqs?: RFQOrderByRelationAggregateInput
  }

  export type MaterialRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MaterialRequestWhereInput | MaterialRequestWhereInput[]
    OR?: MaterialRequestWhereInput[]
    NOT?: MaterialRequestWhereInput | MaterialRequestWhereInput[]
    projectId?: IntFilter<"MaterialRequest"> | number
    requesterId?: IntFilter<"MaterialRequest"> | number
    approverId?: IntNullableFilter<"MaterialRequest"> | number | null
    requestDate?: DateTimeFilter<"MaterialRequest"> | Date | string
    status?: EnumMrStatusFilter<"MaterialRequest"> | $Enums.MrStatus
    remarks?: StringNullableFilter<"MaterialRequest"> | string | null
    createdAt?: DateTimeFilter<"MaterialRequest"> | Date | string
    updatedAt?: DateTimeFilter<"MaterialRequest"> | Date | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    requester?: XOR<UserRelationFilter, UserWhereInput>
    approver?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    items?: MaterialRequestItemListRelationFilter
    rfqs?: RFQListRelationFilter
  }, "id">

  export type MaterialRequestOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    requesterId?: SortOrder
    approverId?: SortOrderInput | SortOrder
    requestDate?: SortOrder
    status?: SortOrder
    remarks?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MaterialRequestCountOrderByAggregateInput
    _avg?: MaterialRequestAvgOrderByAggregateInput
    _max?: MaterialRequestMaxOrderByAggregateInput
    _min?: MaterialRequestMinOrderByAggregateInput
    _sum?: MaterialRequestSumOrderByAggregateInput
  }

  export type MaterialRequestScalarWhereWithAggregatesInput = {
    AND?: MaterialRequestScalarWhereWithAggregatesInput | MaterialRequestScalarWhereWithAggregatesInput[]
    OR?: MaterialRequestScalarWhereWithAggregatesInput[]
    NOT?: MaterialRequestScalarWhereWithAggregatesInput | MaterialRequestScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"MaterialRequest"> | number
    projectId?: IntWithAggregatesFilter<"MaterialRequest"> | number
    requesterId?: IntWithAggregatesFilter<"MaterialRequest"> | number
    approverId?: IntNullableWithAggregatesFilter<"MaterialRequest"> | number | null
    requestDate?: DateTimeWithAggregatesFilter<"MaterialRequest"> | Date | string
    status?: EnumMrStatusWithAggregatesFilter<"MaterialRequest"> | $Enums.MrStatus
    remarks?: StringNullableWithAggregatesFilter<"MaterialRequest"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"MaterialRequest"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MaterialRequest"> | Date | string
  }

  export type MaterialRequestItemWhereInput = {
    AND?: MaterialRequestItemWhereInput | MaterialRequestItemWhereInput[]
    OR?: MaterialRequestItemWhereInput[]
    NOT?: MaterialRequestItemWhereInput | MaterialRequestItemWhereInput[]
    id?: IntFilter<"MaterialRequestItem"> | number
    materialRequestId?: IntFilter<"MaterialRequestItem"> | number
    itemDescription?: StringFilter<"MaterialRequestItem"> | string
    description?: StringNullableFilter<"MaterialRequestItem"> | string | null
    quantity?: DecimalFilter<"MaterialRequestItem"> | Decimal | DecimalJsLike | number | string
    materialUnitPrice?: DecimalFilter<"MaterialRequestItem"> | Decimal | DecimalJsLike | number | string
    laborUnitPrice?: DecimalFilter<"MaterialRequestItem"> | Decimal | DecimalJsLike | number | string
    unit?: StringFilter<"MaterialRequestItem"> | string
    materialRequest?: XOR<MaterialRequestRelationFilter, MaterialRequestWhereInput>
  }

  export type MaterialRequestItemOrderByWithRelationInput = {
    id?: SortOrder
    materialRequestId?: SortOrder
    itemDescription?: SortOrder
    description?: SortOrderInput | SortOrder
    quantity?: SortOrder
    materialUnitPrice?: SortOrder
    laborUnitPrice?: SortOrder
    unit?: SortOrder
    materialRequest?: MaterialRequestOrderByWithRelationInput
  }

  export type MaterialRequestItemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MaterialRequestItemWhereInput | MaterialRequestItemWhereInput[]
    OR?: MaterialRequestItemWhereInput[]
    NOT?: MaterialRequestItemWhereInput | MaterialRequestItemWhereInput[]
    materialRequestId?: IntFilter<"MaterialRequestItem"> | number
    itemDescription?: StringFilter<"MaterialRequestItem"> | string
    description?: StringNullableFilter<"MaterialRequestItem"> | string | null
    quantity?: DecimalFilter<"MaterialRequestItem"> | Decimal | DecimalJsLike | number | string
    materialUnitPrice?: DecimalFilter<"MaterialRequestItem"> | Decimal | DecimalJsLike | number | string
    laborUnitPrice?: DecimalFilter<"MaterialRequestItem"> | Decimal | DecimalJsLike | number | string
    unit?: StringFilter<"MaterialRequestItem"> | string
    materialRequest?: XOR<MaterialRequestRelationFilter, MaterialRequestWhereInput>
  }, "id">

  export type MaterialRequestItemOrderByWithAggregationInput = {
    id?: SortOrder
    materialRequestId?: SortOrder
    itemDescription?: SortOrder
    description?: SortOrderInput | SortOrder
    quantity?: SortOrder
    materialUnitPrice?: SortOrder
    laborUnitPrice?: SortOrder
    unit?: SortOrder
    _count?: MaterialRequestItemCountOrderByAggregateInput
    _avg?: MaterialRequestItemAvgOrderByAggregateInput
    _max?: MaterialRequestItemMaxOrderByAggregateInput
    _min?: MaterialRequestItemMinOrderByAggregateInput
    _sum?: MaterialRequestItemSumOrderByAggregateInput
  }

  export type MaterialRequestItemScalarWhereWithAggregatesInput = {
    AND?: MaterialRequestItemScalarWhereWithAggregatesInput | MaterialRequestItemScalarWhereWithAggregatesInput[]
    OR?: MaterialRequestItemScalarWhereWithAggregatesInput[]
    NOT?: MaterialRequestItemScalarWhereWithAggregatesInput | MaterialRequestItemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"MaterialRequestItem"> | number
    materialRequestId?: IntWithAggregatesFilter<"MaterialRequestItem"> | number
    itemDescription?: StringWithAggregatesFilter<"MaterialRequestItem"> | string
    description?: StringNullableWithAggregatesFilter<"MaterialRequestItem"> | string | null
    quantity?: DecimalWithAggregatesFilter<"MaterialRequestItem"> | Decimal | DecimalJsLike | number | string
    materialUnitPrice?: DecimalWithAggregatesFilter<"MaterialRequestItem"> | Decimal | DecimalJsLike | number | string
    laborUnitPrice?: DecimalWithAggregatesFilter<"MaterialRequestItem"> | Decimal | DecimalJsLike | number | string
    unit?: StringWithAggregatesFilter<"MaterialRequestItem"> | string
  }

  export type RFQWhereInput = {
    AND?: RFQWhereInput | RFQWhereInput[]
    OR?: RFQWhereInput[]
    NOT?: RFQWhereInput | RFQWhereInput[]
    id?: IntFilter<"RFQ"> | number
    mrId?: IntNullableFilter<"RFQ"> | number | null
    createdById?: IntFilter<"RFQ"> | number
    title?: StringFilter<"RFQ"> | string
    status?: EnumRfqStatusFilter<"RFQ"> | $Enums.RfqStatus
    dueDate?: DateTimeNullableFilter<"RFQ"> | Date | string | null
    createdAt?: DateTimeFilter<"RFQ"> | Date | string
    updatedAt?: DateTimeFilter<"RFQ"> | Date | string
    materialRequest?: XOR<MaterialRequestNullableRelationFilter, MaterialRequestWhereInput> | null
    createdBy?: XOR<UserRelationFilter, UserWhereInput>
    items?: RFQItemListRelationFilter
    quotations?: SupplierQuotationListRelationFilter
  }

  export type RFQOrderByWithRelationInput = {
    id?: SortOrder
    mrId?: SortOrderInput | SortOrder
    createdById?: SortOrder
    title?: SortOrder
    status?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    materialRequest?: MaterialRequestOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
    items?: RFQItemOrderByRelationAggregateInput
    quotations?: SupplierQuotationOrderByRelationAggregateInput
  }

  export type RFQWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RFQWhereInput | RFQWhereInput[]
    OR?: RFQWhereInput[]
    NOT?: RFQWhereInput | RFQWhereInput[]
    mrId?: IntNullableFilter<"RFQ"> | number | null
    createdById?: IntFilter<"RFQ"> | number
    title?: StringFilter<"RFQ"> | string
    status?: EnumRfqStatusFilter<"RFQ"> | $Enums.RfqStatus
    dueDate?: DateTimeNullableFilter<"RFQ"> | Date | string | null
    createdAt?: DateTimeFilter<"RFQ"> | Date | string
    updatedAt?: DateTimeFilter<"RFQ"> | Date | string
    materialRequest?: XOR<MaterialRequestNullableRelationFilter, MaterialRequestWhereInput> | null
    createdBy?: XOR<UserRelationFilter, UserWhereInput>
    items?: RFQItemListRelationFilter
    quotations?: SupplierQuotationListRelationFilter
  }, "id">

  export type RFQOrderByWithAggregationInput = {
    id?: SortOrder
    mrId?: SortOrderInput | SortOrder
    createdById?: SortOrder
    title?: SortOrder
    status?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RFQCountOrderByAggregateInput
    _avg?: RFQAvgOrderByAggregateInput
    _max?: RFQMaxOrderByAggregateInput
    _min?: RFQMinOrderByAggregateInput
    _sum?: RFQSumOrderByAggregateInput
  }

  export type RFQScalarWhereWithAggregatesInput = {
    AND?: RFQScalarWhereWithAggregatesInput | RFQScalarWhereWithAggregatesInput[]
    OR?: RFQScalarWhereWithAggregatesInput[]
    NOT?: RFQScalarWhereWithAggregatesInput | RFQScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RFQ"> | number
    mrId?: IntNullableWithAggregatesFilter<"RFQ"> | number | null
    createdById?: IntWithAggregatesFilter<"RFQ"> | number
    title?: StringWithAggregatesFilter<"RFQ"> | string
    status?: EnumRfqStatusWithAggregatesFilter<"RFQ"> | $Enums.RfqStatus
    dueDate?: DateTimeNullableWithAggregatesFilter<"RFQ"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"RFQ"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RFQ"> | Date | string
  }

  export type RFQItemWhereInput = {
    AND?: RFQItemWhereInput | RFQItemWhereInput[]
    OR?: RFQItemWhereInput[]
    NOT?: RFQItemWhereInput | RFQItemWhereInput[]
    id?: IntFilter<"RFQItem"> | number
    rfqId?: IntFilter<"RFQItem"> | number
    materialName?: StringFilter<"RFQItem"> | string
    quantity?: DecimalFilter<"RFQItem"> | Decimal | DecimalJsLike | number | string
    unit?: StringFilter<"RFQItem"> | string
    rfq?: XOR<RFQRelationFilter, RFQWhereInput>
  }

  export type RFQItemOrderByWithRelationInput = {
    id?: SortOrder
    rfqId?: SortOrder
    materialName?: SortOrder
    quantity?: SortOrder
    unit?: SortOrder
    rfq?: RFQOrderByWithRelationInput
  }

  export type RFQItemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RFQItemWhereInput | RFQItemWhereInput[]
    OR?: RFQItemWhereInput[]
    NOT?: RFQItemWhereInput | RFQItemWhereInput[]
    rfqId?: IntFilter<"RFQItem"> | number
    materialName?: StringFilter<"RFQItem"> | string
    quantity?: DecimalFilter<"RFQItem"> | Decimal | DecimalJsLike | number | string
    unit?: StringFilter<"RFQItem"> | string
    rfq?: XOR<RFQRelationFilter, RFQWhereInput>
  }, "id">

  export type RFQItemOrderByWithAggregationInput = {
    id?: SortOrder
    rfqId?: SortOrder
    materialName?: SortOrder
    quantity?: SortOrder
    unit?: SortOrder
    _count?: RFQItemCountOrderByAggregateInput
    _avg?: RFQItemAvgOrderByAggregateInput
    _max?: RFQItemMaxOrderByAggregateInput
    _min?: RFQItemMinOrderByAggregateInput
    _sum?: RFQItemSumOrderByAggregateInput
  }

  export type RFQItemScalarWhereWithAggregatesInput = {
    AND?: RFQItemScalarWhereWithAggregatesInput | RFQItemScalarWhereWithAggregatesInput[]
    OR?: RFQItemScalarWhereWithAggregatesInput[]
    NOT?: RFQItemScalarWhereWithAggregatesInput | RFQItemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RFQItem"> | number
    rfqId?: IntWithAggregatesFilter<"RFQItem"> | number
    materialName?: StringWithAggregatesFilter<"RFQItem"> | string
    quantity?: DecimalWithAggregatesFilter<"RFQItem"> | Decimal | DecimalJsLike | number | string
    unit?: StringWithAggregatesFilter<"RFQItem"> | string
  }

  export type SupplierWhereInput = {
    AND?: SupplierWhereInput | SupplierWhereInput[]
    OR?: SupplierWhereInput[]
    NOT?: SupplierWhereInput | SupplierWhereInput[]
    id?: IntFilter<"Supplier"> | number
    name?: StringFilter<"Supplier"> | string
    contactPerson?: StringNullableFilter<"Supplier"> | string | null
    email?: StringNullableFilter<"Supplier"> | string | null
    phone?: StringNullableFilter<"Supplier"> | string | null
    address?: StringNullableFilter<"Supplier"> | string | null
    rating?: IntNullableFilter<"Supplier"> | number | null
    quotations?: SupplierQuotationListRelationFilter
    purchaseOrders?: PurchaseOrderListRelationFilter
    invoices?: SupplierInvoiceListRelationFilter
  }

  export type SupplierOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    contactPerson?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    rating?: SortOrderInput | SortOrder
    quotations?: SupplierQuotationOrderByRelationAggregateInput
    purchaseOrders?: PurchaseOrderOrderByRelationAggregateInput
    invoices?: SupplierInvoiceOrderByRelationAggregateInput
  }

  export type SupplierWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SupplierWhereInput | SupplierWhereInput[]
    OR?: SupplierWhereInput[]
    NOT?: SupplierWhereInput | SupplierWhereInput[]
    name?: StringFilter<"Supplier"> | string
    contactPerson?: StringNullableFilter<"Supplier"> | string | null
    email?: StringNullableFilter<"Supplier"> | string | null
    phone?: StringNullableFilter<"Supplier"> | string | null
    address?: StringNullableFilter<"Supplier"> | string | null
    rating?: IntNullableFilter<"Supplier"> | number | null
    quotations?: SupplierQuotationListRelationFilter
    purchaseOrders?: PurchaseOrderListRelationFilter
    invoices?: SupplierInvoiceListRelationFilter
  }, "id">

  export type SupplierOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    contactPerson?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    rating?: SortOrderInput | SortOrder
    _count?: SupplierCountOrderByAggregateInput
    _avg?: SupplierAvgOrderByAggregateInput
    _max?: SupplierMaxOrderByAggregateInput
    _min?: SupplierMinOrderByAggregateInput
    _sum?: SupplierSumOrderByAggregateInput
  }

  export type SupplierScalarWhereWithAggregatesInput = {
    AND?: SupplierScalarWhereWithAggregatesInput | SupplierScalarWhereWithAggregatesInput[]
    OR?: SupplierScalarWhereWithAggregatesInput[]
    NOT?: SupplierScalarWhereWithAggregatesInput | SupplierScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Supplier"> | number
    name?: StringWithAggregatesFilter<"Supplier"> | string
    contactPerson?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    email?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    address?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    rating?: IntNullableWithAggregatesFilter<"Supplier"> | number | null
  }

  export type MaterialWhereInput = {
    AND?: MaterialWhereInput | MaterialWhereInput[]
    OR?: MaterialWhereInput[]
    NOT?: MaterialWhereInput | MaterialWhereInput[]
    id?: IntFilter<"Material"> | number
    code?: StringFilter<"Material"> | string
    name?: StringFilter<"Material"> | string
    description?: StringNullableFilter<"Material"> | string | null
    unit?: StringFilter<"Material"> | string
    category?: StringNullableFilter<"Material"> | string | null
    createdAt?: DateTimeFilter<"Material"> | Date | string
    updatedAt?: DateTimeFilter<"Material"> | Date | string
  }

  export type MaterialOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    unit?: SortOrder
    category?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MaterialWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: string
    AND?: MaterialWhereInput | MaterialWhereInput[]
    OR?: MaterialWhereInput[]
    NOT?: MaterialWhereInput | MaterialWhereInput[]
    name?: StringFilter<"Material"> | string
    description?: StringNullableFilter<"Material"> | string | null
    unit?: StringFilter<"Material"> | string
    category?: StringNullableFilter<"Material"> | string | null
    createdAt?: DateTimeFilter<"Material"> | Date | string
    updatedAt?: DateTimeFilter<"Material"> | Date | string
  }, "id" | "code">

  export type MaterialOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    unit?: SortOrder
    category?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MaterialCountOrderByAggregateInput
    _avg?: MaterialAvgOrderByAggregateInput
    _max?: MaterialMaxOrderByAggregateInput
    _min?: MaterialMinOrderByAggregateInput
    _sum?: MaterialSumOrderByAggregateInput
  }

  export type MaterialScalarWhereWithAggregatesInput = {
    AND?: MaterialScalarWhereWithAggregatesInput | MaterialScalarWhereWithAggregatesInput[]
    OR?: MaterialScalarWhereWithAggregatesInput[]
    NOT?: MaterialScalarWhereWithAggregatesInput | MaterialScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Material"> | number
    code?: StringWithAggregatesFilter<"Material"> | string
    name?: StringWithAggregatesFilter<"Material"> | string
    description?: StringNullableWithAggregatesFilter<"Material"> | string | null
    unit?: StringWithAggregatesFilter<"Material"> | string
    category?: StringNullableWithAggregatesFilter<"Material"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Material"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Material"> | Date | string
  }

  export type UnitWhereInput = {
    AND?: UnitWhereInput | UnitWhereInput[]
    OR?: UnitWhereInput[]
    NOT?: UnitWhereInput | UnitWhereInput[]
    id?: IntFilter<"Unit"> | number
    name?: StringFilter<"Unit"> | string
    abbreviation?: StringFilter<"Unit"> | string
    createdAt?: DateTimeFilter<"Unit"> | Date | string
    updatedAt?: DateTimeFilter<"Unit"> | Date | string
  }

  export type UnitOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    abbreviation?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UnitWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    abbreviation?: string
    AND?: UnitWhereInput | UnitWhereInput[]
    OR?: UnitWhereInput[]
    NOT?: UnitWhereInput | UnitWhereInput[]
    name?: StringFilter<"Unit"> | string
    createdAt?: DateTimeFilter<"Unit"> | Date | string
    updatedAt?: DateTimeFilter<"Unit"> | Date | string
  }, "id" | "abbreviation">

  export type UnitOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    abbreviation?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UnitCountOrderByAggregateInput
    _avg?: UnitAvgOrderByAggregateInput
    _max?: UnitMaxOrderByAggregateInput
    _min?: UnitMinOrderByAggregateInput
    _sum?: UnitSumOrderByAggregateInput
  }

  export type UnitScalarWhereWithAggregatesInput = {
    AND?: UnitScalarWhereWithAggregatesInput | UnitScalarWhereWithAggregatesInput[]
    OR?: UnitScalarWhereWithAggregatesInput[]
    NOT?: UnitScalarWhereWithAggregatesInput | UnitScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Unit"> | number
    name?: StringWithAggregatesFilter<"Unit"> | string
    abbreviation?: StringWithAggregatesFilter<"Unit"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Unit"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Unit"> | Date | string
  }

  export type CategoryWhereInput = {
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    id?: IntFilter<"Category"> | number
    name?: StringFilter<"Category"> | string
    description?: StringNullableFilter<"Category"> | string | null
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
  }

  export type CategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    description?: StringNullableFilter<"Category"> | string | null
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
  }, "id" | "name">

  export type CategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CategoryCountOrderByAggregateInput
    _avg?: CategoryAvgOrderByAggregateInput
    _max?: CategoryMaxOrderByAggregateInput
    _min?: CategoryMinOrderByAggregateInput
    _sum?: CategorySumOrderByAggregateInput
  }

  export type CategoryScalarWhereWithAggregatesInput = {
    AND?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    OR?: CategoryScalarWhereWithAggregatesInput[]
    NOT?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Category"> | number
    name?: StringWithAggregatesFilter<"Category"> | string
    description?: StringNullableWithAggregatesFilter<"Category"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Category"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Category"> | Date | string
  }

  export type WarehouseWhereInput = {
    AND?: WarehouseWhereInput | WarehouseWhereInput[]
    OR?: WarehouseWhereInput[]
    NOT?: WarehouseWhereInput | WarehouseWhereInput[]
    id?: IntFilter<"Warehouse"> | number
    name?: StringFilter<"Warehouse"> | string
    location?: StringNullableFilter<"Warehouse"> | string | null
    type?: StringFilter<"Warehouse"> | string
    inventory?: InventoryItemListRelationFilter
  }

  export type WarehouseOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrderInput | SortOrder
    type?: SortOrder
    inventory?: InventoryItemOrderByRelationAggregateInput
  }

  export type WarehouseWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: WarehouseWhereInput | WarehouseWhereInput[]
    OR?: WarehouseWhereInput[]
    NOT?: WarehouseWhereInput | WarehouseWhereInput[]
    name?: StringFilter<"Warehouse"> | string
    location?: StringNullableFilter<"Warehouse"> | string | null
    type?: StringFilter<"Warehouse"> | string
    inventory?: InventoryItemListRelationFilter
  }, "id">

  export type WarehouseOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrderInput | SortOrder
    type?: SortOrder
    _count?: WarehouseCountOrderByAggregateInput
    _avg?: WarehouseAvgOrderByAggregateInput
    _max?: WarehouseMaxOrderByAggregateInput
    _min?: WarehouseMinOrderByAggregateInput
    _sum?: WarehouseSumOrderByAggregateInput
  }

  export type WarehouseScalarWhereWithAggregatesInput = {
    AND?: WarehouseScalarWhereWithAggregatesInput | WarehouseScalarWhereWithAggregatesInput[]
    OR?: WarehouseScalarWhereWithAggregatesInput[]
    NOT?: WarehouseScalarWhereWithAggregatesInput | WarehouseScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Warehouse"> | number
    name?: StringWithAggregatesFilter<"Warehouse"> | string
    location?: StringNullableWithAggregatesFilter<"Warehouse"> | string | null
    type?: StringWithAggregatesFilter<"Warehouse"> | string
  }

  export type SupplierQuotationWhereInput = {
    AND?: SupplierQuotationWhereInput | SupplierQuotationWhereInput[]
    OR?: SupplierQuotationWhereInput[]
    NOT?: SupplierQuotationWhereInput | SupplierQuotationWhereInput[]
    id?: IntFilter<"SupplierQuotation"> | number
    rfqId?: IntFilter<"SupplierQuotation"> | number
    supplierId?: IntFilter<"SupplierQuotation"> | number
    quoteDate?: DateTimeFilter<"SupplierQuotation"> | Date | string
    totalAmount?: DecimalFilter<"SupplierQuotation"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"SupplierQuotation"> | string
    isSelected?: BoolFilter<"SupplierQuotation"> | boolean
    rfq?: XOR<RFQRelationFilter, RFQWhereInput>
    supplier?: XOR<SupplierRelationFilter, SupplierWhereInput>
    items?: QuotationItemListRelationFilter
  }

  export type SupplierQuotationOrderByWithRelationInput = {
    id?: SortOrder
    rfqId?: SortOrder
    supplierId?: SortOrder
    quoteDate?: SortOrder
    totalAmount?: SortOrder
    currency?: SortOrder
    isSelected?: SortOrder
    rfq?: RFQOrderByWithRelationInput
    supplier?: SupplierOrderByWithRelationInput
    items?: QuotationItemOrderByRelationAggregateInput
  }

  export type SupplierQuotationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SupplierQuotationWhereInput | SupplierQuotationWhereInput[]
    OR?: SupplierQuotationWhereInput[]
    NOT?: SupplierQuotationWhereInput | SupplierQuotationWhereInput[]
    rfqId?: IntFilter<"SupplierQuotation"> | number
    supplierId?: IntFilter<"SupplierQuotation"> | number
    quoteDate?: DateTimeFilter<"SupplierQuotation"> | Date | string
    totalAmount?: DecimalFilter<"SupplierQuotation"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"SupplierQuotation"> | string
    isSelected?: BoolFilter<"SupplierQuotation"> | boolean
    rfq?: XOR<RFQRelationFilter, RFQWhereInput>
    supplier?: XOR<SupplierRelationFilter, SupplierWhereInput>
    items?: QuotationItemListRelationFilter
  }, "id">

  export type SupplierQuotationOrderByWithAggregationInput = {
    id?: SortOrder
    rfqId?: SortOrder
    supplierId?: SortOrder
    quoteDate?: SortOrder
    totalAmount?: SortOrder
    currency?: SortOrder
    isSelected?: SortOrder
    _count?: SupplierQuotationCountOrderByAggregateInput
    _avg?: SupplierQuotationAvgOrderByAggregateInput
    _max?: SupplierQuotationMaxOrderByAggregateInput
    _min?: SupplierQuotationMinOrderByAggregateInput
    _sum?: SupplierQuotationSumOrderByAggregateInput
  }

  export type SupplierQuotationScalarWhereWithAggregatesInput = {
    AND?: SupplierQuotationScalarWhereWithAggregatesInput | SupplierQuotationScalarWhereWithAggregatesInput[]
    OR?: SupplierQuotationScalarWhereWithAggregatesInput[]
    NOT?: SupplierQuotationScalarWhereWithAggregatesInput | SupplierQuotationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SupplierQuotation"> | number
    rfqId?: IntWithAggregatesFilter<"SupplierQuotation"> | number
    supplierId?: IntWithAggregatesFilter<"SupplierQuotation"> | number
    quoteDate?: DateTimeWithAggregatesFilter<"SupplierQuotation"> | Date | string
    totalAmount?: DecimalWithAggregatesFilter<"SupplierQuotation"> | Decimal | DecimalJsLike | number | string
    currency?: StringWithAggregatesFilter<"SupplierQuotation"> | string
    isSelected?: BoolWithAggregatesFilter<"SupplierQuotation"> | boolean
  }

  export type QuotationItemWhereInput = {
    AND?: QuotationItemWhereInput | QuotationItemWhereInput[]
    OR?: QuotationItemWhereInput[]
    NOT?: QuotationItemWhereInput | QuotationItemWhereInput[]
    id?: IntFilter<"QuotationItem"> | number
    supplierQuotationId?: IntFilter<"QuotationItem"> | number
    materialName?: StringFilter<"QuotationItem"> | string
    quantity?: DecimalFilter<"QuotationItem"> | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFilter<"QuotationItem"> | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFilter<"QuotationItem"> | Decimal | DecimalJsLike | number | string
    remarks?: StringNullableFilter<"QuotationItem"> | string | null
    supplierQuotation?: XOR<SupplierQuotationRelationFilter, SupplierQuotationWhereInput>
  }

  export type QuotationItemOrderByWithRelationInput = {
    id?: SortOrder
    supplierQuotationId?: SortOrder
    materialName?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    remarks?: SortOrderInput | SortOrder
    supplierQuotation?: SupplierQuotationOrderByWithRelationInput
  }

  export type QuotationItemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: QuotationItemWhereInput | QuotationItemWhereInput[]
    OR?: QuotationItemWhereInput[]
    NOT?: QuotationItemWhereInput | QuotationItemWhereInput[]
    supplierQuotationId?: IntFilter<"QuotationItem"> | number
    materialName?: StringFilter<"QuotationItem"> | string
    quantity?: DecimalFilter<"QuotationItem"> | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFilter<"QuotationItem"> | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFilter<"QuotationItem"> | Decimal | DecimalJsLike | number | string
    remarks?: StringNullableFilter<"QuotationItem"> | string | null
    supplierQuotation?: XOR<SupplierQuotationRelationFilter, SupplierQuotationWhereInput>
  }, "id">

  export type QuotationItemOrderByWithAggregationInput = {
    id?: SortOrder
    supplierQuotationId?: SortOrder
    materialName?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    remarks?: SortOrderInput | SortOrder
    _count?: QuotationItemCountOrderByAggregateInput
    _avg?: QuotationItemAvgOrderByAggregateInput
    _max?: QuotationItemMaxOrderByAggregateInput
    _min?: QuotationItemMinOrderByAggregateInput
    _sum?: QuotationItemSumOrderByAggregateInput
  }

  export type QuotationItemScalarWhereWithAggregatesInput = {
    AND?: QuotationItemScalarWhereWithAggregatesInput | QuotationItemScalarWhereWithAggregatesInput[]
    OR?: QuotationItemScalarWhereWithAggregatesInput[]
    NOT?: QuotationItemScalarWhereWithAggregatesInput | QuotationItemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"QuotationItem"> | number
    supplierQuotationId?: IntWithAggregatesFilter<"QuotationItem"> | number
    materialName?: StringWithAggregatesFilter<"QuotationItem"> | string
    quantity?: DecimalWithAggregatesFilter<"QuotationItem"> | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalWithAggregatesFilter<"QuotationItem"> | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalWithAggregatesFilter<"QuotationItem"> | Decimal | DecimalJsLike | number | string
    remarks?: StringNullableWithAggregatesFilter<"QuotationItem"> | string | null
  }

  export type PurchaseOrderWhereInput = {
    AND?: PurchaseOrderWhereInput | PurchaseOrderWhereInput[]
    OR?: PurchaseOrderWhereInput[]
    NOT?: PurchaseOrderWhereInput | PurchaseOrderWhereInput[]
    id?: IntFilter<"PurchaseOrder"> | number
    orderDate?: DateTimeFilter<"PurchaseOrder"> | Date | string
    projectId?: IntFilter<"PurchaseOrder"> | number
    supplierId?: IntNullableFilter<"PurchaseOrder"> | number | null
    requesterId?: IntFilter<"PurchaseOrder"> | number
    approverId?: IntNullableFilter<"PurchaseOrder"> | number | null
    status?: EnumPoStatusFilter<"PurchaseOrder"> | $Enums.PoStatus
    remarks?: StringNullableFilter<"PurchaseOrder"> | string | null
    totalAmount?: DecimalFilter<"PurchaseOrder"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"PurchaseOrder"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseOrder"> | Date | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    supplier?: XOR<SupplierNullableRelationFilter, SupplierWhereInput> | null
    requester?: XOR<UserRelationFilter, UserWhereInput>
    approver?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    items?: PurchaseOrderItemListRelationFilter
    receiving?: ReceivingReportListRelationFilter
    invoices?: SupplierInvoiceListRelationFilter
    disbursements?: DisbursementListRelationFilter
  }

  export type PurchaseOrderOrderByWithRelationInput = {
    id?: SortOrder
    orderDate?: SortOrder
    projectId?: SortOrder
    supplierId?: SortOrderInput | SortOrder
    requesterId?: SortOrder
    approverId?: SortOrderInput | SortOrder
    status?: SortOrder
    remarks?: SortOrderInput | SortOrder
    totalAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    project?: ProjectOrderByWithRelationInput
    supplier?: SupplierOrderByWithRelationInput
    requester?: UserOrderByWithRelationInput
    approver?: UserOrderByWithRelationInput
    items?: PurchaseOrderItemOrderByRelationAggregateInput
    receiving?: ReceivingReportOrderByRelationAggregateInput
    invoices?: SupplierInvoiceOrderByRelationAggregateInput
    disbursements?: DisbursementOrderByRelationAggregateInput
  }

  export type PurchaseOrderWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PurchaseOrderWhereInput | PurchaseOrderWhereInput[]
    OR?: PurchaseOrderWhereInput[]
    NOT?: PurchaseOrderWhereInput | PurchaseOrderWhereInput[]
    orderDate?: DateTimeFilter<"PurchaseOrder"> | Date | string
    projectId?: IntFilter<"PurchaseOrder"> | number
    supplierId?: IntNullableFilter<"PurchaseOrder"> | number | null
    requesterId?: IntFilter<"PurchaseOrder"> | number
    approverId?: IntNullableFilter<"PurchaseOrder"> | number | null
    status?: EnumPoStatusFilter<"PurchaseOrder"> | $Enums.PoStatus
    remarks?: StringNullableFilter<"PurchaseOrder"> | string | null
    totalAmount?: DecimalFilter<"PurchaseOrder"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"PurchaseOrder"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseOrder"> | Date | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    supplier?: XOR<SupplierNullableRelationFilter, SupplierWhereInput> | null
    requester?: XOR<UserRelationFilter, UserWhereInput>
    approver?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    items?: PurchaseOrderItemListRelationFilter
    receiving?: ReceivingReportListRelationFilter
    invoices?: SupplierInvoiceListRelationFilter
    disbursements?: DisbursementListRelationFilter
  }, "id">

  export type PurchaseOrderOrderByWithAggregationInput = {
    id?: SortOrder
    orderDate?: SortOrder
    projectId?: SortOrder
    supplierId?: SortOrderInput | SortOrder
    requesterId?: SortOrder
    approverId?: SortOrderInput | SortOrder
    status?: SortOrder
    remarks?: SortOrderInput | SortOrder
    totalAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PurchaseOrderCountOrderByAggregateInput
    _avg?: PurchaseOrderAvgOrderByAggregateInput
    _max?: PurchaseOrderMaxOrderByAggregateInput
    _min?: PurchaseOrderMinOrderByAggregateInput
    _sum?: PurchaseOrderSumOrderByAggregateInput
  }

  export type PurchaseOrderScalarWhereWithAggregatesInput = {
    AND?: PurchaseOrderScalarWhereWithAggregatesInput | PurchaseOrderScalarWhereWithAggregatesInput[]
    OR?: PurchaseOrderScalarWhereWithAggregatesInput[]
    NOT?: PurchaseOrderScalarWhereWithAggregatesInput | PurchaseOrderScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PurchaseOrder"> | number
    orderDate?: DateTimeWithAggregatesFilter<"PurchaseOrder"> | Date | string
    projectId?: IntWithAggregatesFilter<"PurchaseOrder"> | number
    supplierId?: IntNullableWithAggregatesFilter<"PurchaseOrder"> | number | null
    requesterId?: IntWithAggregatesFilter<"PurchaseOrder"> | number
    approverId?: IntNullableWithAggregatesFilter<"PurchaseOrder"> | number | null
    status?: EnumPoStatusWithAggregatesFilter<"PurchaseOrder"> | $Enums.PoStatus
    remarks?: StringNullableWithAggregatesFilter<"PurchaseOrder"> | string | null
    totalAmount?: DecimalWithAggregatesFilter<"PurchaseOrder"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter<"PurchaseOrder"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PurchaseOrder"> | Date | string
  }

  export type PurchaseOrderItemWhereInput = {
    AND?: PurchaseOrderItemWhereInput | PurchaseOrderItemWhereInput[]
    OR?: PurchaseOrderItemWhereInput[]
    NOT?: PurchaseOrderItemWhereInput | PurchaseOrderItemWhereInput[]
    id?: IntFilter<"PurchaseOrderItem"> | number
    purchaseOrderId?: IntFilter<"PurchaseOrderItem"> | number
    materialName?: StringFilter<"PurchaseOrderItem"> | string
    description?: StringNullableFilter<"PurchaseOrderItem"> | string | null
    quantity?: DecimalFilter<"PurchaseOrderItem"> | Decimal | DecimalJsLike | number | string
    unit?: StringFilter<"PurchaseOrderItem"> | string
    unitPrice?: DecimalFilter<"PurchaseOrderItem"> | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFilter<"PurchaseOrderItem"> | Decimal | DecimalJsLike | number | string
    purchaseOrder?: XOR<PurchaseOrderRelationFilter, PurchaseOrderWhereInput>
  }

  export type PurchaseOrderItemOrderByWithRelationInput = {
    id?: SortOrder
    purchaseOrderId?: SortOrder
    materialName?: SortOrder
    description?: SortOrderInput | SortOrder
    quantity?: SortOrder
    unit?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    purchaseOrder?: PurchaseOrderOrderByWithRelationInput
  }

  export type PurchaseOrderItemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PurchaseOrderItemWhereInput | PurchaseOrderItemWhereInput[]
    OR?: PurchaseOrderItemWhereInput[]
    NOT?: PurchaseOrderItemWhereInput | PurchaseOrderItemWhereInput[]
    purchaseOrderId?: IntFilter<"PurchaseOrderItem"> | number
    materialName?: StringFilter<"PurchaseOrderItem"> | string
    description?: StringNullableFilter<"PurchaseOrderItem"> | string | null
    quantity?: DecimalFilter<"PurchaseOrderItem"> | Decimal | DecimalJsLike | number | string
    unit?: StringFilter<"PurchaseOrderItem"> | string
    unitPrice?: DecimalFilter<"PurchaseOrderItem"> | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFilter<"PurchaseOrderItem"> | Decimal | DecimalJsLike | number | string
    purchaseOrder?: XOR<PurchaseOrderRelationFilter, PurchaseOrderWhereInput>
  }, "id">

  export type PurchaseOrderItemOrderByWithAggregationInput = {
    id?: SortOrder
    purchaseOrderId?: SortOrder
    materialName?: SortOrder
    description?: SortOrderInput | SortOrder
    quantity?: SortOrder
    unit?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    _count?: PurchaseOrderItemCountOrderByAggregateInput
    _avg?: PurchaseOrderItemAvgOrderByAggregateInput
    _max?: PurchaseOrderItemMaxOrderByAggregateInput
    _min?: PurchaseOrderItemMinOrderByAggregateInput
    _sum?: PurchaseOrderItemSumOrderByAggregateInput
  }

  export type PurchaseOrderItemScalarWhereWithAggregatesInput = {
    AND?: PurchaseOrderItemScalarWhereWithAggregatesInput | PurchaseOrderItemScalarWhereWithAggregatesInput[]
    OR?: PurchaseOrderItemScalarWhereWithAggregatesInput[]
    NOT?: PurchaseOrderItemScalarWhereWithAggregatesInput | PurchaseOrderItemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PurchaseOrderItem"> | number
    purchaseOrderId?: IntWithAggregatesFilter<"PurchaseOrderItem"> | number
    materialName?: StringWithAggregatesFilter<"PurchaseOrderItem"> | string
    description?: StringNullableWithAggregatesFilter<"PurchaseOrderItem"> | string | null
    quantity?: DecimalWithAggregatesFilter<"PurchaseOrderItem"> | Decimal | DecimalJsLike | number | string
    unit?: StringWithAggregatesFilter<"PurchaseOrderItem"> | string
    unitPrice?: DecimalWithAggregatesFilter<"PurchaseOrderItem"> | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalWithAggregatesFilter<"PurchaseOrderItem"> | Decimal | DecimalJsLike | number | string
  }

  export type ReceivingReportWhereInput = {
    AND?: ReceivingReportWhereInput | ReceivingReportWhereInput[]
    OR?: ReceivingReportWhereInput[]
    NOT?: ReceivingReportWhereInput | ReceivingReportWhereInput[]
    id?: IntFilter<"ReceivingReport"> | number
    purchaseOrderId?: IntFilter<"ReceivingReport"> | number
    receivedById?: IntFilter<"ReceivingReport"> | number
    receivedDate?: DateTimeFilter<"ReceivingReport"> | Date | string
    deliveryNoteNo?: StringNullableFilter<"ReceivingReport"> | string | null
    notes?: StringNullableFilter<"ReceivingReport"> | string | null
    purchaseOrder?: XOR<PurchaseOrderRelationFilter, PurchaseOrderWhereInput>
    receivedBy?: XOR<UserRelationFilter, UserWhereInput>
    items?: ReceivingItemListRelationFilter
    invoices?: SupplierInvoiceListRelationFilter
  }

  export type ReceivingReportOrderByWithRelationInput = {
    id?: SortOrder
    purchaseOrderId?: SortOrder
    receivedById?: SortOrder
    receivedDate?: SortOrder
    deliveryNoteNo?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    purchaseOrder?: PurchaseOrderOrderByWithRelationInput
    receivedBy?: UserOrderByWithRelationInput
    items?: ReceivingItemOrderByRelationAggregateInput
    invoices?: SupplierInvoiceOrderByRelationAggregateInput
  }

  export type ReceivingReportWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ReceivingReportWhereInput | ReceivingReportWhereInput[]
    OR?: ReceivingReportWhereInput[]
    NOT?: ReceivingReportWhereInput | ReceivingReportWhereInput[]
    purchaseOrderId?: IntFilter<"ReceivingReport"> | number
    receivedById?: IntFilter<"ReceivingReport"> | number
    receivedDate?: DateTimeFilter<"ReceivingReport"> | Date | string
    deliveryNoteNo?: StringNullableFilter<"ReceivingReport"> | string | null
    notes?: StringNullableFilter<"ReceivingReport"> | string | null
    purchaseOrder?: XOR<PurchaseOrderRelationFilter, PurchaseOrderWhereInput>
    receivedBy?: XOR<UserRelationFilter, UserWhereInput>
    items?: ReceivingItemListRelationFilter
    invoices?: SupplierInvoiceListRelationFilter
  }, "id">

  export type ReceivingReportOrderByWithAggregationInput = {
    id?: SortOrder
    purchaseOrderId?: SortOrder
    receivedById?: SortOrder
    receivedDate?: SortOrder
    deliveryNoteNo?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    _count?: ReceivingReportCountOrderByAggregateInput
    _avg?: ReceivingReportAvgOrderByAggregateInput
    _max?: ReceivingReportMaxOrderByAggregateInput
    _min?: ReceivingReportMinOrderByAggregateInput
    _sum?: ReceivingReportSumOrderByAggregateInput
  }

  export type ReceivingReportScalarWhereWithAggregatesInput = {
    AND?: ReceivingReportScalarWhereWithAggregatesInput | ReceivingReportScalarWhereWithAggregatesInput[]
    OR?: ReceivingReportScalarWhereWithAggregatesInput[]
    NOT?: ReceivingReportScalarWhereWithAggregatesInput | ReceivingReportScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ReceivingReport"> | number
    purchaseOrderId?: IntWithAggregatesFilter<"ReceivingReport"> | number
    receivedById?: IntWithAggregatesFilter<"ReceivingReport"> | number
    receivedDate?: DateTimeWithAggregatesFilter<"ReceivingReport"> | Date | string
    deliveryNoteNo?: StringNullableWithAggregatesFilter<"ReceivingReport"> | string | null
    notes?: StringNullableWithAggregatesFilter<"ReceivingReport"> | string | null
  }

  export type ReceivingItemWhereInput = {
    AND?: ReceivingItemWhereInput | ReceivingItemWhereInput[]
    OR?: ReceivingItemWhereInput[]
    NOT?: ReceivingItemWhereInput | ReceivingItemWhereInput[]
    id?: IntFilter<"ReceivingItem"> | number
    receivingReportId?: IntFilter<"ReceivingItem"> | number
    materialName?: StringFilter<"ReceivingItem"> | string
    quantityReceived?: DecimalFilter<"ReceivingItem"> | Decimal | DecimalJsLike | number | string
    status?: StringFilter<"ReceivingItem"> | string
    receivingReport?: XOR<ReceivingReportRelationFilter, ReceivingReportWhereInput>
  }

  export type ReceivingItemOrderByWithRelationInput = {
    id?: SortOrder
    receivingReportId?: SortOrder
    materialName?: SortOrder
    quantityReceived?: SortOrder
    status?: SortOrder
    receivingReport?: ReceivingReportOrderByWithRelationInput
  }

  export type ReceivingItemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ReceivingItemWhereInput | ReceivingItemWhereInput[]
    OR?: ReceivingItemWhereInput[]
    NOT?: ReceivingItemWhereInput | ReceivingItemWhereInput[]
    receivingReportId?: IntFilter<"ReceivingItem"> | number
    materialName?: StringFilter<"ReceivingItem"> | string
    quantityReceived?: DecimalFilter<"ReceivingItem"> | Decimal | DecimalJsLike | number | string
    status?: StringFilter<"ReceivingItem"> | string
    receivingReport?: XOR<ReceivingReportRelationFilter, ReceivingReportWhereInput>
  }, "id">

  export type ReceivingItemOrderByWithAggregationInput = {
    id?: SortOrder
    receivingReportId?: SortOrder
    materialName?: SortOrder
    quantityReceived?: SortOrder
    status?: SortOrder
    _count?: ReceivingItemCountOrderByAggregateInput
    _avg?: ReceivingItemAvgOrderByAggregateInput
    _max?: ReceivingItemMaxOrderByAggregateInput
    _min?: ReceivingItemMinOrderByAggregateInput
    _sum?: ReceivingItemSumOrderByAggregateInput
  }

  export type ReceivingItemScalarWhereWithAggregatesInput = {
    AND?: ReceivingItemScalarWhereWithAggregatesInput | ReceivingItemScalarWhereWithAggregatesInput[]
    OR?: ReceivingItemScalarWhereWithAggregatesInput[]
    NOT?: ReceivingItemScalarWhereWithAggregatesInput | ReceivingItemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ReceivingItem"> | number
    receivingReportId?: IntWithAggregatesFilter<"ReceivingItem"> | number
    materialName?: StringWithAggregatesFilter<"ReceivingItem"> | string
    quantityReceived?: DecimalWithAggregatesFilter<"ReceivingItem"> | Decimal | DecimalJsLike | number | string
    status?: StringWithAggregatesFilter<"ReceivingItem"> | string
  }

  export type InventoryItemWhereInput = {
    AND?: InventoryItemWhereInput | InventoryItemWhereInput[]
    OR?: InventoryItemWhereInput[]
    NOT?: InventoryItemWhereInput | InventoryItemWhereInput[]
    id?: IntFilter<"InventoryItem"> | number
    materialName?: StringFilter<"InventoryItem"> | string
    projectId?: IntNullableFilter<"InventoryItem"> | number | null
    warehouseId?: IntNullableFilter<"InventoryItem"> | number | null
    quantity?: DecimalFilter<"InventoryItem"> | Decimal | DecimalJsLike | number | string
    unit?: StringFilter<"InventoryItem"> | string
    lastUpdated?: DateTimeFilter<"InventoryItem"> | Date | string
    project?: XOR<ProjectNullableRelationFilter, ProjectWhereInput> | null
    warehouse?: XOR<WarehouseNullableRelationFilter, WarehouseWhereInput> | null
  }

  export type InventoryItemOrderByWithRelationInput = {
    id?: SortOrder
    materialName?: SortOrder
    projectId?: SortOrderInput | SortOrder
    warehouseId?: SortOrderInput | SortOrder
    quantity?: SortOrder
    unit?: SortOrder
    lastUpdated?: SortOrder
    project?: ProjectOrderByWithRelationInput
    warehouse?: WarehouseOrderByWithRelationInput
  }

  export type InventoryItemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: InventoryItemWhereInput | InventoryItemWhereInput[]
    OR?: InventoryItemWhereInput[]
    NOT?: InventoryItemWhereInput | InventoryItemWhereInput[]
    materialName?: StringFilter<"InventoryItem"> | string
    projectId?: IntNullableFilter<"InventoryItem"> | number | null
    warehouseId?: IntNullableFilter<"InventoryItem"> | number | null
    quantity?: DecimalFilter<"InventoryItem"> | Decimal | DecimalJsLike | number | string
    unit?: StringFilter<"InventoryItem"> | string
    lastUpdated?: DateTimeFilter<"InventoryItem"> | Date | string
    project?: XOR<ProjectNullableRelationFilter, ProjectWhereInput> | null
    warehouse?: XOR<WarehouseNullableRelationFilter, WarehouseWhereInput> | null
  }, "id">

  export type InventoryItemOrderByWithAggregationInput = {
    id?: SortOrder
    materialName?: SortOrder
    projectId?: SortOrderInput | SortOrder
    warehouseId?: SortOrderInput | SortOrder
    quantity?: SortOrder
    unit?: SortOrder
    lastUpdated?: SortOrder
    _count?: InventoryItemCountOrderByAggregateInput
    _avg?: InventoryItemAvgOrderByAggregateInput
    _max?: InventoryItemMaxOrderByAggregateInput
    _min?: InventoryItemMinOrderByAggregateInput
    _sum?: InventoryItemSumOrderByAggregateInput
  }

  export type InventoryItemScalarWhereWithAggregatesInput = {
    AND?: InventoryItemScalarWhereWithAggregatesInput | InventoryItemScalarWhereWithAggregatesInput[]
    OR?: InventoryItemScalarWhereWithAggregatesInput[]
    NOT?: InventoryItemScalarWhereWithAggregatesInput | InventoryItemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"InventoryItem"> | number
    materialName?: StringWithAggregatesFilter<"InventoryItem"> | string
    projectId?: IntNullableWithAggregatesFilter<"InventoryItem"> | number | null
    warehouseId?: IntNullableWithAggregatesFilter<"InventoryItem"> | number | null
    quantity?: DecimalWithAggregatesFilter<"InventoryItem"> | Decimal | DecimalJsLike | number | string
    unit?: StringWithAggregatesFilter<"InventoryItem"> | string
    lastUpdated?: DateTimeWithAggregatesFilter<"InventoryItem"> | Date | string
  }

  export type WorkflowRuleWhereInput = {
    AND?: WorkflowRuleWhereInput | WorkflowRuleWhereInput[]
    OR?: WorkflowRuleWhereInput[]
    NOT?: WorkflowRuleWhereInput | WorkflowRuleWhereInput[]
    id?: IntFilter<"WorkflowRule"> | number
    processType?: StringFilter<"WorkflowRule"> | string
    minAmount?: DecimalFilter<"WorkflowRule"> | Decimal | DecimalJsLike | number | string
    maxAmount?: DecimalNullableFilter<"WorkflowRule"> | Decimal | DecimalJsLike | number | string | null
    approverRole?: EnumUserRoleFilter<"WorkflowRule"> | $Enums.UserRole
    stepOrder?: IntFilter<"WorkflowRule"> | number
    updatedAt?: DateTimeFilter<"WorkflowRule"> | Date | string
  }

  export type WorkflowRuleOrderByWithRelationInput = {
    id?: SortOrder
    processType?: SortOrder
    minAmount?: SortOrder
    maxAmount?: SortOrderInput | SortOrder
    approverRole?: SortOrder
    stepOrder?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkflowRuleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: WorkflowRuleWhereInput | WorkflowRuleWhereInput[]
    OR?: WorkflowRuleWhereInput[]
    NOT?: WorkflowRuleWhereInput | WorkflowRuleWhereInput[]
    processType?: StringFilter<"WorkflowRule"> | string
    minAmount?: DecimalFilter<"WorkflowRule"> | Decimal | DecimalJsLike | number | string
    maxAmount?: DecimalNullableFilter<"WorkflowRule"> | Decimal | DecimalJsLike | number | string | null
    approverRole?: EnumUserRoleFilter<"WorkflowRule"> | $Enums.UserRole
    stepOrder?: IntFilter<"WorkflowRule"> | number
    updatedAt?: DateTimeFilter<"WorkflowRule"> | Date | string
  }, "id">

  export type WorkflowRuleOrderByWithAggregationInput = {
    id?: SortOrder
    processType?: SortOrder
    minAmount?: SortOrder
    maxAmount?: SortOrderInput | SortOrder
    approverRole?: SortOrder
    stepOrder?: SortOrder
    updatedAt?: SortOrder
    _count?: WorkflowRuleCountOrderByAggregateInput
    _avg?: WorkflowRuleAvgOrderByAggregateInput
    _max?: WorkflowRuleMaxOrderByAggregateInput
    _min?: WorkflowRuleMinOrderByAggregateInput
    _sum?: WorkflowRuleSumOrderByAggregateInput
  }

  export type WorkflowRuleScalarWhereWithAggregatesInput = {
    AND?: WorkflowRuleScalarWhereWithAggregatesInput | WorkflowRuleScalarWhereWithAggregatesInput[]
    OR?: WorkflowRuleScalarWhereWithAggregatesInput[]
    NOT?: WorkflowRuleScalarWhereWithAggregatesInput | WorkflowRuleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"WorkflowRule"> | number
    processType?: StringWithAggregatesFilter<"WorkflowRule"> | string
    minAmount?: DecimalWithAggregatesFilter<"WorkflowRule"> | Decimal | DecimalJsLike | number | string
    maxAmount?: DecimalNullableWithAggregatesFilter<"WorkflowRule"> | Decimal | DecimalJsLike | number | string | null
    approverRole?: EnumUserRoleWithAggregatesFilter<"WorkflowRule"> | $Enums.UserRole
    stepOrder?: IntWithAggregatesFilter<"WorkflowRule"> | number
    updatedAt?: DateTimeWithAggregatesFilter<"WorkflowRule"> | Date | string
  }

  export type SupplierInvoiceWhereInput = {
    AND?: SupplierInvoiceWhereInput | SupplierInvoiceWhereInput[]
    OR?: SupplierInvoiceWhereInput[]
    NOT?: SupplierInvoiceWhereInput | SupplierInvoiceWhereInput[]
    id?: IntFilter<"SupplierInvoice"> | number
    invoiceNumber?: StringFilter<"SupplierInvoice"> | string
    invoiceDate?: DateTimeFilter<"SupplierInvoice"> | Date | string
    supplierId?: IntFilter<"SupplierInvoice"> | number
    purchaseOrderId?: IntNullableFilter<"SupplierInvoice"> | number | null
    receivingReportId?: IntNullableFilter<"SupplierInvoice"> | number | null
    totalAmount?: DecimalFilter<"SupplierInvoice"> | Decimal | DecimalJsLike | number | string
    status?: StringFilter<"SupplierInvoice"> | string
    createdAt?: DateTimeFilter<"SupplierInvoice"> | Date | string
    supplier?: XOR<SupplierRelationFilter, SupplierWhereInput>
    purchaseOrder?: XOR<PurchaseOrderNullableRelationFilter, PurchaseOrderWhereInput> | null
    receivingReport?: XOR<ReceivingReportNullableRelationFilter, ReceivingReportWhereInput> | null
  }

  export type SupplierInvoiceOrderByWithRelationInput = {
    id?: SortOrder
    invoiceNumber?: SortOrder
    invoiceDate?: SortOrder
    supplierId?: SortOrder
    purchaseOrderId?: SortOrderInput | SortOrder
    receivingReportId?: SortOrderInput | SortOrder
    totalAmount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    supplier?: SupplierOrderByWithRelationInput
    purchaseOrder?: PurchaseOrderOrderByWithRelationInput
    receivingReport?: ReceivingReportOrderByWithRelationInput
  }

  export type SupplierInvoiceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SupplierInvoiceWhereInput | SupplierInvoiceWhereInput[]
    OR?: SupplierInvoiceWhereInput[]
    NOT?: SupplierInvoiceWhereInput | SupplierInvoiceWhereInput[]
    invoiceNumber?: StringFilter<"SupplierInvoice"> | string
    invoiceDate?: DateTimeFilter<"SupplierInvoice"> | Date | string
    supplierId?: IntFilter<"SupplierInvoice"> | number
    purchaseOrderId?: IntNullableFilter<"SupplierInvoice"> | number | null
    receivingReportId?: IntNullableFilter<"SupplierInvoice"> | number | null
    totalAmount?: DecimalFilter<"SupplierInvoice"> | Decimal | DecimalJsLike | number | string
    status?: StringFilter<"SupplierInvoice"> | string
    createdAt?: DateTimeFilter<"SupplierInvoice"> | Date | string
    supplier?: XOR<SupplierRelationFilter, SupplierWhereInput>
    purchaseOrder?: XOR<PurchaseOrderNullableRelationFilter, PurchaseOrderWhereInput> | null
    receivingReport?: XOR<ReceivingReportNullableRelationFilter, ReceivingReportWhereInput> | null
  }, "id">

  export type SupplierInvoiceOrderByWithAggregationInput = {
    id?: SortOrder
    invoiceNumber?: SortOrder
    invoiceDate?: SortOrder
    supplierId?: SortOrder
    purchaseOrderId?: SortOrderInput | SortOrder
    receivingReportId?: SortOrderInput | SortOrder
    totalAmount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    _count?: SupplierInvoiceCountOrderByAggregateInput
    _avg?: SupplierInvoiceAvgOrderByAggregateInput
    _max?: SupplierInvoiceMaxOrderByAggregateInput
    _min?: SupplierInvoiceMinOrderByAggregateInput
    _sum?: SupplierInvoiceSumOrderByAggregateInput
  }

  export type SupplierInvoiceScalarWhereWithAggregatesInput = {
    AND?: SupplierInvoiceScalarWhereWithAggregatesInput | SupplierInvoiceScalarWhereWithAggregatesInput[]
    OR?: SupplierInvoiceScalarWhereWithAggregatesInput[]
    NOT?: SupplierInvoiceScalarWhereWithAggregatesInput | SupplierInvoiceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SupplierInvoice"> | number
    invoiceNumber?: StringWithAggregatesFilter<"SupplierInvoice"> | string
    invoiceDate?: DateTimeWithAggregatesFilter<"SupplierInvoice"> | Date | string
    supplierId?: IntWithAggregatesFilter<"SupplierInvoice"> | number
    purchaseOrderId?: IntNullableWithAggregatesFilter<"SupplierInvoice"> | number | null
    receivingReportId?: IntNullableWithAggregatesFilter<"SupplierInvoice"> | number | null
    totalAmount?: DecimalWithAggregatesFilter<"SupplierInvoice"> | Decimal | DecimalJsLike | number | string
    status?: StringWithAggregatesFilter<"SupplierInvoice"> | string
    createdAt?: DateTimeWithAggregatesFilter<"SupplierInvoice"> | Date | string
  }

  export type DisbursementWhereInput = {
    AND?: DisbursementWhereInput | DisbursementWhereInput[]
    OR?: DisbursementWhereInput[]
    NOT?: DisbursementWhereInput | DisbursementWhereInput[]
    id?: IntFilter<"Disbursement"> | number
    purchaseOrderId?: IntNullableFilter<"Disbursement"> | number | null
    processedById?: IntFilter<"Disbursement"> | number
    amount?: DecimalFilter<"Disbursement"> | Decimal | DecimalJsLike | number | string
    paymentDate?: DateTimeFilter<"Disbursement"> | Date | string
    method?: EnumPaymentMethodFilter<"Disbursement"> | $Enums.PaymentMethod
    referenceNumber?: StringNullableFilter<"Disbursement"> | string | null
    status?: StringFilter<"Disbursement"> | string
    purchaseOrder?: XOR<PurchaseOrderNullableRelationFilter, PurchaseOrderWhereInput> | null
    processedBy?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type DisbursementOrderByWithRelationInput = {
    id?: SortOrder
    purchaseOrderId?: SortOrderInput | SortOrder
    processedById?: SortOrder
    amount?: SortOrder
    paymentDate?: SortOrder
    method?: SortOrder
    referenceNumber?: SortOrderInput | SortOrder
    status?: SortOrder
    purchaseOrder?: PurchaseOrderOrderByWithRelationInput
    processedBy?: UserOrderByWithRelationInput
  }

  export type DisbursementWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DisbursementWhereInput | DisbursementWhereInput[]
    OR?: DisbursementWhereInput[]
    NOT?: DisbursementWhereInput | DisbursementWhereInput[]
    purchaseOrderId?: IntNullableFilter<"Disbursement"> | number | null
    processedById?: IntFilter<"Disbursement"> | number
    amount?: DecimalFilter<"Disbursement"> | Decimal | DecimalJsLike | number | string
    paymentDate?: DateTimeFilter<"Disbursement"> | Date | string
    method?: EnumPaymentMethodFilter<"Disbursement"> | $Enums.PaymentMethod
    referenceNumber?: StringNullableFilter<"Disbursement"> | string | null
    status?: StringFilter<"Disbursement"> | string
    purchaseOrder?: XOR<PurchaseOrderNullableRelationFilter, PurchaseOrderWhereInput> | null
    processedBy?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type DisbursementOrderByWithAggregationInput = {
    id?: SortOrder
    purchaseOrderId?: SortOrderInput | SortOrder
    processedById?: SortOrder
    amount?: SortOrder
    paymentDate?: SortOrder
    method?: SortOrder
    referenceNumber?: SortOrderInput | SortOrder
    status?: SortOrder
    _count?: DisbursementCountOrderByAggregateInput
    _avg?: DisbursementAvgOrderByAggregateInput
    _max?: DisbursementMaxOrderByAggregateInput
    _min?: DisbursementMinOrderByAggregateInput
    _sum?: DisbursementSumOrderByAggregateInput
  }

  export type DisbursementScalarWhereWithAggregatesInput = {
    AND?: DisbursementScalarWhereWithAggregatesInput | DisbursementScalarWhereWithAggregatesInput[]
    OR?: DisbursementScalarWhereWithAggregatesInput[]
    NOT?: DisbursementScalarWhereWithAggregatesInput | DisbursementScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Disbursement"> | number
    purchaseOrderId?: IntNullableWithAggregatesFilter<"Disbursement"> | number | null
    processedById?: IntWithAggregatesFilter<"Disbursement"> | number
    amount?: DecimalWithAggregatesFilter<"Disbursement"> | Decimal | DecimalJsLike | number | string
    paymentDate?: DateTimeWithAggregatesFilter<"Disbursement"> | Date | string
    method?: EnumPaymentMethodWithAggregatesFilter<"Disbursement"> | $Enums.PaymentMethod
    referenceNumber?: StringNullableWithAggregatesFilter<"Disbursement"> | string | null
    status?: StringWithAggregatesFilter<"Disbursement"> | string
  }

  export type FinancialTransactionWhereInput = {
    AND?: FinancialTransactionWhereInput | FinancialTransactionWhereInput[]
    OR?: FinancialTransactionWhereInput[]
    NOT?: FinancialTransactionWhereInput | FinancialTransactionWhereInput[]
    id?: IntFilter<"FinancialTransaction"> | number
    projectId?: IntNullableFilter<"FinancialTransaction"> | number | null
    date?: DateTimeFilter<"FinancialTransaction"> | Date | string
    type?: StringFilter<"FinancialTransaction"> | string
    category?: StringFilter<"FinancialTransaction"> | string
    description?: StringNullableFilter<"FinancialTransaction"> | string | null
    amount?: DecimalFilter<"FinancialTransaction"> | Decimal | DecimalJsLike | number | string
    reference?: StringNullableFilter<"FinancialTransaction"> | string | null
    metadata?: JsonNullableFilter<"FinancialTransaction">
    project?: XOR<ProjectNullableRelationFilter, ProjectWhereInput> | null
  }

  export type FinancialTransactionOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrderInput | SortOrder
    date?: SortOrder
    type?: SortOrder
    category?: SortOrder
    description?: SortOrderInput | SortOrder
    amount?: SortOrder
    reference?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    project?: ProjectOrderByWithRelationInput
  }

  export type FinancialTransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: FinancialTransactionWhereInput | FinancialTransactionWhereInput[]
    OR?: FinancialTransactionWhereInput[]
    NOT?: FinancialTransactionWhereInput | FinancialTransactionWhereInput[]
    projectId?: IntNullableFilter<"FinancialTransaction"> | number | null
    date?: DateTimeFilter<"FinancialTransaction"> | Date | string
    type?: StringFilter<"FinancialTransaction"> | string
    category?: StringFilter<"FinancialTransaction"> | string
    description?: StringNullableFilter<"FinancialTransaction"> | string | null
    amount?: DecimalFilter<"FinancialTransaction"> | Decimal | DecimalJsLike | number | string
    reference?: StringNullableFilter<"FinancialTransaction"> | string | null
    metadata?: JsonNullableFilter<"FinancialTransaction">
    project?: XOR<ProjectNullableRelationFilter, ProjectWhereInput> | null
  }, "id">

  export type FinancialTransactionOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrderInput | SortOrder
    date?: SortOrder
    type?: SortOrder
    category?: SortOrder
    description?: SortOrderInput | SortOrder
    amount?: SortOrder
    reference?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: FinancialTransactionCountOrderByAggregateInput
    _avg?: FinancialTransactionAvgOrderByAggregateInput
    _max?: FinancialTransactionMaxOrderByAggregateInput
    _min?: FinancialTransactionMinOrderByAggregateInput
    _sum?: FinancialTransactionSumOrderByAggregateInput
  }

  export type FinancialTransactionScalarWhereWithAggregatesInput = {
    AND?: FinancialTransactionScalarWhereWithAggregatesInput | FinancialTransactionScalarWhereWithAggregatesInput[]
    OR?: FinancialTransactionScalarWhereWithAggregatesInput[]
    NOT?: FinancialTransactionScalarWhereWithAggregatesInput | FinancialTransactionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"FinancialTransaction"> | number
    projectId?: IntNullableWithAggregatesFilter<"FinancialTransaction"> | number | null
    date?: DateTimeWithAggregatesFilter<"FinancialTransaction"> | Date | string
    type?: StringWithAggregatesFilter<"FinancialTransaction"> | string
    category?: StringWithAggregatesFilter<"FinancialTransaction"> | string
    description?: StringNullableWithAggregatesFilter<"FinancialTransaction"> | string | null
    amount?: DecimalWithAggregatesFilter<"FinancialTransaction"> | Decimal | DecimalJsLike | number | string
    reference?: StringNullableWithAggregatesFilter<"FinancialTransaction"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"FinancialTransaction">
  }

  export type UserCreateInput = {
    email: string
    name: string
    password: string
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutRequesterInput
    poApprovals?: PurchaseOrderCreateNestedManyWithoutApproverInput
    materialRequests?: MaterialRequestCreateNestedManyWithoutRequesterInput
    mrApprovals?: MaterialRequestCreateNestedManyWithoutApproverInput
    rfqsCreated?: RFQCreateNestedManyWithoutCreatedByInput
    receivedItems?: ReceivingReportCreateNestedManyWithoutReceivedByInput
    disbursements?: DisbursementCreateNestedManyWithoutProcessedByInput
    projectMembers?: ProjectMemberCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    email: string
    name: string
    password: string
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutRequesterInput
    poApprovals?: PurchaseOrderUncheckedCreateNestedManyWithoutApproverInput
    materialRequests?: MaterialRequestUncheckedCreateNestedManyWithoutRequesterInput
    mrApprovals?: MaterialRequestUncheckedCreateNestedManyWithoutApproverInput
    rfqsCreated?: RFQUncheckedCreateNestedManyWithoutCreatedByInput
    receivedItems?: ReceivingReportUncheckedCreateNestedManyWithoutReceivedByInput
    disbursements?: DisbursementUncheckedCreateNestedManyWithoutProcessedByInput
    projectMembers?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrders?: PurchaseOrderUpdateManyWithoutRequesterNestedInput
    poApprovals?: PurchaseOrderUpdateManyWithoutApproverNestedInput
    materialRequests?: MaterialRequestUpdateManyWithoutRequesterNestedInput
    mrApprovals?: MaterialRequestUpdateManyWithoutApproverNestedInput
    rfqsCreated?: RFQUpdateManyWithoutCreatedByNestedInput
    receivedItems?: ReceivingReportUpdateManyWithoutReceivedByNestedInput
    disbursements?: DisbursementUpdateManyWithoutProcessedByNestedInput
    projectMembers?: ProjectMemberUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutRequesterNestedInput
    poApprovals?: PurchaseOrderUncheckedUpdateManyWithoutApproverNestedInput
    materialRequests?: MaterialRequestUncheckedUpdateManyWithoutRequesterNestedInput
    mrApprovals?: MaterialRequestUncheckedUpdateManyWithoutApproverNestedInput
    rfqsCreated?: RFQUncheckedUpdateManyWithoutCreatedByNestedInput
    receivedItems?: ReceivingReportUncheckedUpdateManyWithoutReceivedByNestedInput
    disbursements?: DisbursementUncheckedUpdateManyWithoutProcessedByNestedInput
    projectMembers?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    email: string
    name: string
    password: string
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyCreateInput = {
    name: string
    address?: string | null
    taxId?: string | null
    currency?: string
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyUncheckedCreateInput = {
    id?: number
    name: string
    address?: string | null
    taxId?: string | null
    currency?: string
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyCreateManyInput = {
    id?: number
    name: string
    address?: string | null
    taxId?: string | null
    currency?: string
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientCreateInput = {
    name: string
    contactPerson?: string | null
    contractType?: string | null
    paymentTerms?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projects?: ProjectCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateInput = {
    id?: number
    name: string
    contactPerson?: string | null
    contractType?: string | null
    paymentTerms?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projects?: ProjectUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    contractType?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    contractType?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ClientCreateManyInput = {
    id?: number
    name: string
    contactPerson?: string | null
    contractType?: string | null
    paymentTerms?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    contractType?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    contractType?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectCreateInput = {
    name: string
    location?: string | null
    duration?: string | null
    budget: Decimal | DecimalJsLike | number | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    totalFloorArea?: Decimal | DecimalJsLike | number | string | null
    carportArea?: Decimal | DecimalJsLike | number | string | null
    client?: ClientCreateNestedOneWithoutProjectsInput
    transactions?: FinancialTransactionCreateNestedManyWithoutProjectInput
    inventory?: InventoryItemCreateNestedManyWithoutProjectInput
    teamMembers?: ProjectMemberCreateNestedManyWithoutProjectInput
    boqItems?: BoqItemCreateNestedManyWithoutProjectInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutProjectInput
    materialRequests?: MaterialRequestCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateInput = {
    id?: number
    clientId?: number | null
    name: string
    location?: string | null
    duration?: string | null
    budget: Decimal | DecimalJsLike | number | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    totalFloorArea?: Decimal | DecimalJsLike | number | string | null
    carportArea?: Decimal | DecimalJsLike | number | string | null
    transactions?: FinancialTransactionUncheckedCreateNestedManyWithoutProjectInput
    inventory?: InventoryItemUncheckedCreateNestedManyWithoutProjectInput
    teamMembers?: ProjectMemberUncheckedCreateNestedManyWithoutProjectInput
    boqItems?: BoqItemUncheckedCreateNestedManyWithoutProjectInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutProjectInput
    materialRequests?: MaterialRequestUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalFloorArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    carportArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    client?: ClientUpdateOneWithoutProjectsNestedInput
    transactions?: FinancialTransactionUpdateManyWithoutProjectNestedInput
    inventory?: InventoryItemUpdateManyWithoutProjectNestedInput
    teamMembers?: ProjectMemberUpdateManyWithoutProjectNestedInput
    boqItems?: BoqItemUpdateManyWithoutProjectNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutProjectNestedInput
    materialRequests?: MaterialRequestUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalFloorArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    carportArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    transactions?: FinancialTransactionUncheckedUpdateManyWithoutProjectNestedInput
    inventory?: InventoryItemUncheckedUpdateManyWithoutProjectNestedInput
    teamMembers?: ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
    boqItems?: BoqItemUncheckedUpdateManyWithoutProjectNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutProjectNestedInput
    materialRequests?: MaterialRequestUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateManyInput = {
    id?: number
    clientId?: number | null
    name: string
    location?: string | null
    duration?: string | null
    budget: Decimal | DecimalJsLike | number | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    totalFloorArea?: Decimal | DecimalJsLike | number | string | null
    carportArea?: Decimal | DecimalJsLike | number | string | null
  }

  export type ProjectUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalFloorArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    carportArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type ProjectUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalFloorArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    carportArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type ProjectMemberCreateInput = {
    role: string
    assignedAt?: Date | string
    project: ProjectCreateNestedOneWithoutTeamMembersInput
    user: UserCreateNestedOneWithoutProjectMembersInput
  }

  export type ProjectMemberUncheckedCreateInput = {
    id?: number
    projectId: number
    userId: number
    role: string
    assignedAt?: Date | string
  }

  export type ProjectMemberUpdateInput = {
    role?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutTeamMembersNestedInput
    user?: UserUpdateOneRequiredWithoutProjectMembersNestedInput
  }

  export type ProjectMemberUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectMemberCreateManyInput = {
    id?: number
    projectId: number
    userId: number
    role: string
    assignedAt?: Date | string
  }

  export type ProjectMemberUpdateManyMutationInput = {
    role?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectMemberUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BoqItemCreateInput = {
    itemDescription: string
    unit: string
    materialUnitPrice: Decimal | DecimalJsLike | number | string
    laborUnitPrice?: Decimal | DecimalJsLike | number | string
    quantity: Decimal | DecimalJsLike | number | string
    isCarport?: boolean
    project: ProjectCreateNestedOneWithoutBoqItemsInput
    boqComponents?: BoqItemComponentCreateNestedManyWithoutBoqItemInput
  }

  export type BoqItemUncheckedCreateInput = {
    id?: number
    projectId: number
    itemDescription: string
    unit: string
    materialUnitPrice: Decimal | DecimalJsLike | number | string
    laborUnitPrice?: Decimal | DecimalJsLike | number | string
    quantity: Decimal | DecimalJsLike | number | string
    isCarport?: boolean
    boqComponents?: BoqItemComponentUncheckedCreateNestedManyWithoutBoqItemInput
  }

  export type BoqItemUpdateInput = {
    itemDescription?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    materialUnitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    laborUnitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isCarport?: BoolFieldUpdateOperationsInput | boolean
    project?: ProjectUpdateOneRequiredWithoutBoqItemsNestedInput
    boqComponents?: BoqItemComponentUpdateManyWithoutBoqItemNestedInput
  }

  export type BoqItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    itemDescription?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    materialUnitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    laborUnitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isCarport?: BoolFieldUpdateOperationsInput | boolean
    boqComponents?: BoqItemComponentUncheckedUpdateManyWithoutBoqItemNestedInput
  }

  export type BoqItemCreateManyInput = {
    id?: number
    projectId: number
    itemDescription: string
    unit: string
    materialUnitPrice: Decimal | DecimalJsLike | number | string
    laborUnitPrice?: Decimal | DecimalJsLike | number | string
    quantity: Decimal | DecimalJsLike | number | string
    isCarport?: boolean
  }

  export type BoqItemUpdateManyMutationInput = {
    itemDescription?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    materialUnitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    laborUnitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isCarport?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BoqItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    itemDescription?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    materialUnitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    laborUnitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isCarport?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BoqItemComponentCreateInput = {
    resourceType: $Enums.ResourceType
    name: string
    quantityFactor: Decimal | DecimalJsLike | number | string
    unitRate: Decimal | DecimalJsLike | number | string
    totalComponentCost: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    boqItem: BoqItemCreateNestedOneWithoutBoqComponentsInput
  }

  export type BoqItemComponentUncheckedCreateInput = {
    id?: number
    boqItemId: number
    resourceType: $Enums.ResourceType
    name: string
    quantityFactor: Decimal | DecimalJsLike | number | string
    unitRate: Decimal | DecimalJsLike | number | string
    totalComponentCost: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BoqItemComponentUpdateInput = {
    resourceType?: EnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType
    name?: StringFieldUpdateOperationsInput | string
    quantityFactor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalComponentCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    boqItem?: BoqItemUpdateOneRequiredWithoutBoqComponentsNestedInput
  }

  export type BoqItemComponentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    boqItemId?: IntFieldUpdateOperationsInput | number
    resourceType?: EnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType
    name?: StringFieldUpdateOperationsInput | string
    quantityFactor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalComponentCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BoqItemComponentCreateManyInput = {
    id?: number
    boqItemId: number
    resourceType: $Enums.ResourceType
    name: string
    quantityFactor: Decimal | DecimalJsLike | number | string
    unitRate: Decimal | DecimalJsLike | number | string
    totalComponentCost: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BoqItemComponentUpdateManyMutationInput = {
    resourceType?: EnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType
    name?: StringFieldUpdateOperationsInput | string
    quantityFactor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalComponentCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BoqItemComponentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    boqItemId?: IntFieldUpdateOperationsInput | number
    resourceType?: EnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType
    name?: StringFieldUpdateOperationsInput | string
    quantityFactor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalComponentCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialRequestCreateInput = {
    requestDate?: Date | string
    status?: $Enums.MrStatus
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutMaterialRequestsInput
    requester: UserCreateNestedOneWithoutMaterialRequestsInput
    approver?: UserCreateNestedOneWithoutMrApprovalsInput
    items?: MaterialRequestItemCreateNestedManyWithoutMaterialRequestInput
    rfqs?: RFQCreateNestedManyWithoutMaterialRequestInput
  }

  export type MaterialRequestUncheckedCreateInput = {
    id?: number
    projectId: number
    requesterId: number
    approverId?: number | null
    requestDate?: Date | string
    status?: $Enums.MrStatus
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: MaterialRequestItemUncheckedCreateNestedManyWithoutMaterialRequestInput
    rfqs?: RFQUncheckedCreateNestedManyWithoutMaterialRequestInput
  }

  export type MaterialRequestUpdateInput = {
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumMrStatusFieldUpdateOperationsInput | $Enums.MrStatus
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutMaterialRequestsNestedInput
    requester?: UserUpdateOneRequiredWithoutMaterialRequestsNestedInput
    approver?: UserUpdateOneWithoutMrApprovalsNestedInput
    items?: MaterialRequestItemUpdateManyWithoutMaterialRequestNestedInput
    rfqs?: RFQUpdateManyWithoutMaterialRequestNestedInput
  }

  export type MaterialRequestUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    requesterId?: IntFieldUpdateOperationsInput | number
    approverId?: NullableIntFieldUpdateOperationsInput | number | null
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumMrStatusFieldUpdateOperationsInput | $Enums.MrStatus
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: MaterialRequestItemUncheckedUpdateManyWithoutMaterialRequestNestedInput
    rfqs?: RFQUncheckedUpdateManyWithoutMaterialRequestNestedInput
  }

  export type MaterialRequestCreateManyInput = {
    id?: number
    projectId: number
    requesterId: number
    approverId?: number | null
    requestDate?: Date | string
    status?: $Enums.MrStatus
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MaterialRequestUpdateManyMutationInput = {
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumMrStatusFieldUpdateOperationsInput | $Enums.MrStatus
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialRequestUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    requesterId?: IntFieldUpdateOperationsInput | number
    approverId?: NullableIntFieldUpdateOperationsInput | number | null
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumMrStatusFieldUpdateOperationsInput | $Enums.MrStatus
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialRequestItemCreateInput = {
    itemDescription: string
    description?: string | null
    quantity: Decimal | DecimalJsLike | number | string
    materialUnitPrice?: Decimal | DecimalJsLike | number | string
    laborUnitPrice?: Decimal | DecimalJsLike | number | string
    unit: string
    materialRequest: MaterialRequestCreateNestedOneWithoutItemsInput
  }

  export type MaterialRequestItemUncheckedCreateInput = {
    id?: number
    materialRequestId: number
    itemDescription: string
    description?: string | null
    quantity: Decimal | DecimalJsLike | number | string
    materialUnitPrice?: Decimal | DecimalJsLike | number | string
    laborUnitPrice?: Decimal | DecimalJsLike | number | string
    unit: string
  }

  export type MaterialRequestItemUpdateInput = {
    itemDescription?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    materialUnitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    laborUnitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    materialRequest?: MaterialRequestUpdateOneRequiredWithoutItemsNestedInput
  }

  export type MaterialRequestItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    materialRequestId?: IntFieldUpdateOperationsInput | number
    itemDescription?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    materialUnitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    laborUnitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
  }

  export type MaterialRequestItemCreateManyInput = {
    id?: number
    materialRequestId: number
    itemDescription: string
    description?: string | null
    quantity: Decimal | DecimalJsLike | number | string
    materialUnitPrice?: Decimal | DecimalJsLike | number | string
    laborUnitPrice?: Decimal | DecimalJsLike | number | string
    unit: string
  }

  export type MaterialRequestItemUpdateManyMutationInput = {
    itemDescription?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    materialUnitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    laborUnitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
  }

  export type MaterialRequestItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    materialRequestId?: IntFieldUpdateOperationsInput | number
    itemDescription?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    materialUnitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    laborUnitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
  }

  export type RFQCreateInput = {
    title: string
    status?: $Enums.RfqStatus
    dueDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    materialRequest?: MaterialRequestCreateNestedOneWithoutRfqsInput
    createdBy: UserCreateNestedOneWithoutRfqsCreatedInput
    items?: RFQItemCreateNestedManyWithoutRfqInput
    quotations?: SupplierQuotationCreateNestedManyWithoutRfqInput
  }

  export type RFQUncheckedCreateInput = {
    id?: number
    mrId?: number | null
    createdById: number
    title: string
    status?: $Enums.RfqStatus
    dueDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: RFQItemUncheckedCreateNestedManyWithoutRfqInput
    quotations?: SupplierQuotationUncheckedCreateNestedManyWithoutRfqInput
  }

  export type RFQUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    status?: EnumRfqStatusFieldUpdateOperationsInput | $Enums.RfqStatus
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    materialRequest?: MaterialRequestUpdateOneWithoutRfqsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutRfqsCreatedNestedInput
    items?: RFQItemUpdateManyWithoutRfqNestedInput
    quotations?: SupplierQuotationUpdateManyWithoutRfqNestedInput
  }

  export type RFQUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    mrId?: NullableIntFieldUpdateOperationsInput | number | null
    createdById?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    status?: EnumRfqStatusFieldUpdateOperationsInput | $Enums.RfqStatus
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: RFQItemUncheckedUpdateManyWithoutRfqNestedInput
    quotations?: SupplierQuotationUncheckedUpdateManyWithoutRfqNestedInput
  }

  export type RFQCreateManyInput = {
    id?: number
    mrId?: number | null
    createdById: number
    title: string
    status?: $Enums.RfqStatus
    dueDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RFQUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    status?: EnumRfqStatusFieldUpdateOperationsInput | $Enums.RfqStatus
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RFQUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    mrId?: NullableIntFieldUpdateOperationsInput | number | null
    createdById?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    status?: EnumRfqStatusFieldUpdateOperationsInput | $Enums.RfqStatus
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RFQItemCreateInput = {
    materialName: string
    quantity: Decimal | DecimalJsLike | number | string
    unit: string
    rfq: RFQCreateNestedOneWithoutItemsInput
  }

  export type RFQItemUncheckedCreateInput = {
    id?: number
    rfqId: number
    materialName: string
    quantity: Decimal | DecimalJsLike | number | string
    unit: string
  }

  export type RFQItemUpdateInput = {
    materialName?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    rfq?: RFQUpdateOneRequiredWithoutItemsNestedInput
  }

  export type RFQItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    rfqId?: IntFieldUpdateOperationsInput | number
    materialName?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
  }

  export type RFQItemCreateManyInput = {
    id?: number
    rfqId: number
    materialName: string
    quantity: Decimal | DecimalJsLike | number | string
    unit: string
  }

  export type RFQItemUpdateManyMutationInput = {
    materialName?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
  }

  export type RFQItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    rfqId?: IntFieldUpdateOperationsInput | number
    materialName?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
  }

  export type SupplierCreateInput = {
    name: string
    contactPerson?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    rating?: number | null
    quotations?: SupplierQuotationCreateNestedManyWithoutSupplierInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutSupplierInput
    invoices?: SupplierInvoiceCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUncheckedCreateInput = {
    id?: number
    name: string
    contactPerson?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    rating?: number | null
    quotations?: SupplierQuotationUncheckedCreateNestedManyWithoutSupplierInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutSupplierInput
    invoices?: SupplierInvoiceUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    quotations?: SupplierQuotationUpdateManyWithoutSupplierNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutSupplierNestedInput
    invoices?: SupplierInvoiceUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    quotations?: SupplierQuotationUncheckedUpdateManyWithoutSupplierNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutSupplierNestedInput
    invoices?: SupplierInvoiceUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierCreateManyInput = {
    id?: number
    name: string
    contactPerson?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    rating?: number | null
  }

  export type SupplierUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SupplierUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type MaterialCreateInput = {
    code: string
    name: string
    description?: string | null
    unit: string
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MaterialUncheckedCreateInput = {
    id?: number
    code: string
    name: string
    description?: string | null
    unit: string
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MaterialUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialCreateManyInput = {
    id?: number
    code: string
    name: string
    description?: string | null
    unit: string
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MaterialUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitCreateInput = {
    name: string
    abbreviation: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UnitUncheckedCreateInput = {
    id?: number
    name: string
    abbreviation: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UnitUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    abbreviation?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    abbreviation?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitCreateManyInput = {
    id?: number
    name: string
    abbreviation: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UnitUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    abbreviation?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    abbreviation?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryCreateInput = {
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WarehouseCreateInput = {
    name: string
    location?: string | null
    type?: string
    inventory?: InventoryItemCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseUncheckedCreateInput = {
    id?: number
    name: string
    location?: string | null
    type?: string
    inventory?: InventoryItemUncheckedCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    inventory?: InventoryItemUpdateManyWithoutWarehouseNestedInput
  }

  export type WarehouseUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    inventory?: InventoryItemUncheckedUpdateManyWithoutWarehouseNestedInput
  }

  export type WarehouseCreateManyInput = {
    id?: number
    name: string
    location?: string | null
    type?: string
  }

  export type WarehouseUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
  }

  export type WarehouseUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
  }

  export type SupplierQuotationCreateInput = {
    quoteDate?: Date | string
    totalAmount?: Decimal | DecimalJsLike | number | string
    currency?: string
    isSelected?: boolean
    rfq: RFQCreateNestedOneWithoutQuotationsInput
    supplier: SupplierCreateNestedOneWithoutQuotationsInput
    items?: QuotationItemCreateNestedManyWithoutSupplierQuotationInput
  }

  export type SupplierQuotationUncheckedCreateInput = {
    id?: number
    rfqId: number
    supplierId: number
    quoteDate?: Date | string
    totalAmount?: Decimal | DecimalJsLike | number | string
    currency?: string
    isSelected?: boolean
    items?: QuotationItemUncheckedCreateNestedManyWithoutSupplierQuotationInput
  }

  export type SupplierQuotationUpdateInput = {
    quoteDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    isSelected?: BoolFieldUpdateOperationsInput | boolean
    rfq?: RFQUpdateOneRequiredWithoutQuotationsNestedInput
    supplier?: SupplierUpdateOneRequiredWithoutQuotationsNestedInput
    items?: QuotationItemUpdateManyWithoutSupplierQuotationNestedInput
  }

  export type SupplierQuotationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    rfqId?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
    quoteDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    isSelected?: BoolFieldUpdateOperationsInput | boolean
    items?: QuotationItemUncheckedUpdateManyWithoutSupplierQuotationNestedInput
  }

  export type SupplierQuotationCreateManyInput = {
    id?: number
    rfqId: number
    supplierId: number
    quoteDate?: Date | string
    totalAmount?: Decimal | DecimalJsLike | number | string
    currency?: string
    isSelected?: boolean
  }

  export type SupplierQuotationUpdateManyMutationInput = {
    quoteDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    isSelected?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SupplierQuotationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    rfqId?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
    quoteDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    isSelected?: BoolFieldUpdateOperationsInput | boolean
  }

  export type QuotationItemCreateInput = {
    materialName: string
    quantity: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    remarks?: string | null
    supplierQuotation: SupplierQuotationCreateNestedOneWithoutItemsInput
  }

  export type QuotationItemUncheckedCreateInput = {
    id?: number
    supplierQuotationId: number
    materialName: string
    quantity: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    remarks?: string | null
  }

  export type QuotationItemUpdateInput = {
    materialName?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    supplierQuotation?: SupplierQuotationUpdateOneRequiredWithoutItemsNestedInput
  }

  export type QuotationItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    supplierQuotationId?: IntFieldUpdateOperationsInput | number
    materialName?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QuotationItemCreateManyInput = {
    id?: number
    supplierQuotationId: number
    materialName: string
    quantity: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    remarks?: string | null
  }

  export type QuotationItemUpdateManyMutationInput = {
    materialName?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QuotationItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    supplierQuotationId?: IntFieldUpdateOperationsInput | number
    materialName?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PurchaseOrderCreateInput = {
    orderDate?: Date | string
    status?: $Enums.PoStatus
    remarks?: string | null
    totalAmount?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutPurchaseOrdersInput
    supplier?: SupplierCreateNestedOneWithoutPurchaseOrdersInput
    requester: UserCreateNestedOneWithoutPurchaseOrdersInput
    approver?: UserCreateNestedOneWithoutPoApprovalsInput
    items?: PurchaseOrderItemCreateNestedManyWithoutPurchaseOrderInput
    receiving?: ReceivingReportCreateNestedManyWithoutPurchaseOrderInput
    invoices?: SupplierInvoiceCreateNestedManyWithoutPurchaseOrderInput
    disbursements?: DisbursementCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseOrderUncheckedCreateInput = {
    id?: number
    orderDate?: Date | string
    projectId: number
    supplierId?: number | null
    requesterId: number
    approverId?: number | null
    status?: $Enums.PoStatus
    remarks?: string | null
    totalAmount?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: PurchaseOrderItemUncheckedCreateNestedManyWithoutPurchaseOrderInput
    receiving?: ReceivingReportUncheckedCreateNestedManyWithoutPurchaseOrderInput
    invoices?: SupplierInvoiceUncheckedCreateNestedManyWithoutPurchaseOrderInput
    disbursements?: DisbursementUncheckedCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseOrderUpdateInput = {
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumPoStatusFieldUpdateOperationsInput | $Enums.PoStatus
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutPurchaseOrdersNestedInput
    supplier?: SupplierUpdateOneWithoutPurchaseOrdersNestedInput
    requester?: UserUpdateOneRequiredWithoutPurchaseOrdersNestedInput
    approver?: UserUpdateOneWithoutPoApprovalsNestedInput
    items?: PurchaseOrderItemUpdateManyWithoutPurchaseOrderNestedInput
    receiving?: ReceivingReportUpdateManyWithoutPurchaseOrderNestedInput
    invoices?: SupplierInvoiceUpdateManyWithoutPurchaseOrderNestedInput
    disbursements?: DisbursementUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type PurchaseOrderUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: IntFieldUpdateOperationsInput | number
    supplierId?: NullableIntFieldUpdateOperationsInput | number | null
    requesterId?: IntFieldUpdateOperationsInput | number
    approverId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumPoStatusFieldUpdateOperationsInput | $Enums.PoStatus
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: PurchaseOrderItemUncheckedUpdateManyWithoutPurchaseOrderNestedInput
    receiving?: ReceivingReportUncheckedUpdateManyWithoutPurchaseOrderNestedInput
    invoices?: SupplierInvoiceUncheckedUpdateManyWithoutPurchaseOrderNestedInput
    disbursements?: DisbursementUncheckedUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type PurchaseOrderCreateManyInput = {
    id?: number
    orderDate?: Date | string
    projectId: number
    supplierId?: number | null
    requesterId: number
    approverId?: number | null
    status?: $Enums.PoStatus
    remarks?: string | null
    totalAmount?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseOrderUpdateManyMutationInput = {
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumPoStatusFieldUpdateOperationsInput | $Enums.PoStatus
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: IntFieldUpdateOperationsInput | number
    supplierId?: NullableIntFieldUpdateOperationsInput | number | null
    requesterId?: IntFieldUpdateOperationsInput | number
    approverId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumPoStatusFieldUpdateOperationsInput | $Enums.PoStatus
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderItemCreateInput = {
    materialName: string
    description?: string | null
    quantity: Decimal | DecimalJsLike | number | string
    unit: string
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    purchaseOrder: PurchaseOrderCreateNestedOneWithoutItemsInput
  }

  export type PurchaseOrderItemUncheckedCreateInput = {
    id?: number
    purchaseOrderId: number
    materialName: string
    description?: string | null
    quantity: Decimal | DecimalJsLike | number | string
    unit: string
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
  }

  export type PurchaseOrderItemUpdateInput = {
    materialName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    purchaseOrder?: PurchaseOrderUpdateOneRequiredWithoutItemsNestedInput
  }

  export type PurchaseOrderItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    purchaseOrderId?: IntFieldUpdateOperationsInput | number
    materialName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type PurchaseOrderItemCreateManyInput = {
    id?: number
    purchaseOrderId: number
    materialName: string
    description?: string | null
    quantity: Decimal | DecimalJsLike | number | string
    unit: string
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
  }

  export type PurchaseOrderItemUpdateManyMutationInput = {
    materialName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type PurchaseOrderItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    purchaseOrderId?: IntFieldUpdateOperationsInput | number
    materialName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type ReceivingReportCreateInput = {
    receivedDate?: Date | string
    deliveryNoteNo?: string | null
    notes?: string | null
    purchaseOrder: PurchaseOrderCreateNestedOneWithoutReceivingInput
    receivedBy: UserCreateNestedOneWithoutReceivedItemsInput
    items?: ReceivingItemCreateNestedManyWithoutReceivingReportInput
    invoices?: SupplierInvoiceCreateNestedManyWithoutReceivingReportInput
  }

  export type ReceivingReportUncheckedCreateInput = {
    id?: number
    purchaseOrderId: number
    receivedById: number
    receivedDate?: Date | string
    deliveryNoteNo?: string | null
    notes?: string | null
    items?: ReceivingItemUncheckedCreateNestedManyWithoutReceivingReportInput
    invoices?: SupplierInvoiceUncheckedCreateNestedManyWithoutReceivingReportInput
  }

  export type ReceivingReportUpdateInput = {
    receivedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryNoteNo?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseOrder?: PurchaseOrderUpdateOneRequiredWithoutReceivingNestedInput
    receivedBy?: UserUpdateOneRequiredWithoutReceivedItemsNestedInput
    items?: ReceivingItemUpdateManyWithoutReceivingReportNestedInput
    invoices?: SupplierInvoiceUpdateManyWithoutReceivingReportNestedInput
  }

  export type ReceivingReportUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    purchaseOrderId?: IntFieldUpdateOperationsInput | number
    receivedById?: IntFieldUpdateOperationsInput | number
    receivedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryNoteNo?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    items?: ReceivingItemUncheckedUpdateManyWithoutReceivingReportNestedInput
    invoices?: SupplierInvoiceUncheckedUpdateManyWithoutReceivingReportNestedInput
  }

  export type ReceivingReportCreateManyInput = {
    id?: number
    purchaseOrderId: number
    receivedById: number
    receivedDate?: Date | string
    deliveryNoteNo?: string | null
    notes?: string | null
  }

  export type ReceivingReportUpdateManyMutationInput = {
    receivedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryNoteNo?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReceivingReportUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    purchaseOrderId?: IntFieldUpdateOperationsInput | number
    receivedById?: IntFieldUpdateOperationsInput | number
    receivedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryNoteNo?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReceivingItemCreateInput = {
    materialName: string
    quantityReceived: Decimal | DecimalJsLike | number | string
    status?: string
    receivingReport: ReceivingReportCreateNestedOneWithoutItemsInput
  }

  export type ReceivingItemUncheckedCreateInput = {
    id?: number
    receivingReportId: number
    materialName: string
    quantityReceived: Decimal | DecimalJsLike | number | string
    status?: string
  }

  export type ReceivingItemUpdateInput = {
    materialName?: StringFieldUpdateOperationsInput | string
    quantityReceived?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    receivingReport?: ReceivingReportUpdateOneRequiredWithoutItemsNestedInput
  }

  export type ReceivingItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    receivingReportId?: IntFieldUpdateOperationsInput | number
    materialName?: StringFieldUpdateOperationsInput | string
    quantityReceived?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type ReceivingItemCreateManyInput = {
    id?: number
    receivingReportId: number
    materialName: string
    quantityReceived: Decimal | DecimalJsLike | number | string
    status?: string
  }

  export type ReceivingItemUpdateManyMutationInput = {
    materialName?: StringFieldUpdateOperationsInput | string
    quantityReceived?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type ReceivingItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    receivingReportId?: IntFieldUpdateOperationsInput | number
    materialName?: StringFieldUpdateOperationsInput | string
    quantityReceived?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type InventoryItemCreateInput = {
    materialName: string
    quantity: Decimal | DecimalJsLike | number | string
    unit: string
    lastUpdated?: Date | string
    project?: ProjectCreateNestedOneWithoutInventoryInput
    warehouse?: WarehouseCreateNestedOneWithoutInventoryInput
  }

  export type InventoryItemUncheckedCreateInput = {
    id?: number
    materialName: string
    projectId?: number | null
    warehouseId?: number | null
    quantity: Decimal | DecimalJsLike | number | string
    unit: string
    lastUpdated?: Date | string
  }

  export type InventoryItemUpdateInput = {
    materialName?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneWithoutInventoryNestedInput
    warehouse?: WarehouseUpdateOneWithoutInventoryNestedInput
  }

  export type InventoryItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    materialName?: StringFieldUpdateOperationsInput | string
    projectId?: NullableIntFieldUpdateOperationsInput | number | null
    warehouseId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryItemCreateManyInput = {
    id?: number
    materialName: string
    projectId?: number | null
    warehouseId?: number | null
    quantity: Decimal | DecimalJsLike | number | string
    unit: string
    lastUpdated?: Date | string
  }

  export type InventoryItemUpdateManyMutationInput = {
    materialName?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    materialName?: StringFieldUpdateOperationsInput | string
    projectId?: NullableIntFieldUpdateOperationsInput | number | null
    warehouseId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkflowRuleCreateInput = {
    processType: string
    minAmount?: Decimal | DecimalJsLike | number | string
    maxAmount?: Decimal | DecimalJsLike | number | string | null
    approverRole: $Enums.UserRole
    stepOrder?: number
    updatedAt?: Date | string
  }

  export type WorkflowRuleUncheckedCreateInput = {
    id?: number
    processType: string
    minAmount?: Decimal | DecimalJsLike | number | string
    maxAmount?: Decimal | DecimalJsLike | number | string | null
    approverRole: $Enums.UserRole
    stepOrder?: number
    updatedAt?: Date | string
  }

  export type WorkflowRuleUpdateInput = {
    processType?: StringFieldUpdateOperationsInput | string
    minAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    approverRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    stepOrder?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkflowRuleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    processType?: StringFieldUpdateOperationsInput | string
    minAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    approverRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    stepOrder?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkflowRuleCreateManyInput = {
    id?: number
    processType: string
    minAmount?: Decimal | DecimalJsLike | number | string
    maxAmount?: Decimal | DecimalJsLike | number | string | null
    approverRole: $Enums.UserRole
    stepOrder?: number
    updatedAt?: Date | string
  }

  export type WorkflowRuleUpdateManyMutationInput = {
    processType?: StringFieldUpdateOperationsInput | string
    minAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    approverRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    stepOrder?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkflowRuleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    processType?: StringFieldUpdateOperationsInput | string
    minAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    approverRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    stepOrder?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierInvoiceCreateInput = {
    invoiceNumber: string
    invoiceDate: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    status?: string
    createdAt?: Date | string
    supplier: SupplierCreateNestedOneWithoutInvoicesInput
    purchaseOrder?: PurchaseOrderCreateNestedOneWithoutInvoicesInput
    receivingReport?: ReceivingReportCreateNestedOneWithoutInvoicesInput
  }

  export type SupplierInvoiceUncheckedCreateInput = {
    id?: number
    invoiceNumber: string
    invoiceDate: Date | string
    supplierId: number
    purchaseOrderId?: number | null
    receivingReportId?: number | null
    totalAmount: Decimal | DecimalJsLike | number | string
    status?: string
    createdAt?: Date | string
  }

  export type SupplierInvoiceUpdateInput = {
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplier?: SupplierUpdateOneRequiredWithoutInvoicesNestedInput
    purchaseOrder?: PurchaseOrderUpdateOneWithoutInvoicesNestedInput
    receivingReport?: ReceivingReportUpdateOneWithoutInvoicesNestedInput
  }

  export type SupplierInvoiceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    supplierId?: IntFieldUpdateOperationsInput | number
    purchaseOrderId?: NullableIntFieldUpdateOperationsInput | number | null
    receivingReportId?: NullableIntFieldUpdateOperationsInput | number | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierInvoiceCreateManyInput = {
    id?: number
    invoiceNumber: string
    invoiceDate: Date | string
    supplierId: number
    purchaseOrderId?: number | null
    receivingReportId?: number | null
    totalAmount: Decimal | DecimalJsLike | number | string
    status?: string
    createdAt?: Date | string
  }

  export type SupplierInvoiceUpdateManyMutationInput = {
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierInvoiceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    supplierId?: IntFieldUpdateOperationsInput | number
    purchaseOrderId?: NullableIntFieldUpdateOperationsInput | number | null
    receivingReportId?: NullableIntFieldUpdateOperationsInput | number | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DisbursementCreateInput = {
    amount: Decimal | DecimalJsLike | number | string
    paymentDate?: Date | string
    method: $Enums.PaymentMethod
    referenceNumber?: string | null
    status?: string
    purchaseOrder?: PurchaseOrderCreateNestedOneWithoutDisbursementsInput
    processedBy: UserCreateNestedOneWithoutDisbursementsInput
  }

  export type DisbursementUncheckedCreateInput = {
    id?: number
    purchaseOrderId?: number | null
    processedById: number
    amount: Decimal | DecimalJsLike | number | string
    paymentDate?: Date | string
    method: $Enums.PaymentMethod
    referenceNumber?: string | null
    status?: string
  }

  export type DisbursementUpdateInput = {
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    purchaseOrder?: PurchaseOrderUpdateOneWithoutDisbursementsNestedInput
    processedBy?: UserUpdateOneRequiredWithoutDisbursementsNestedInput
  }

  export type DisbursementUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    purchaseOrderId?: NullableIntFieldUpdateOperationsInput | number | null
    processedById?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type DisbursementCreateManyInput = {
    id?: number
    purchaseOrderId?: number | null
    processedById: number
    amount: Decimal | DecimalJsLike | number | string
    paymentDate?: Date | string
    method: $Enums.PaymentMethod
    referenceNumber?: string | null
    status?: string
  }

  export type DisbursementUpdateManyMutationInput = {
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type DisbursementUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    purchaseOrderId?: NullableIntFieldUpdateOperationsInput | number | null
    processedById?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type FinancialTransactionCreateInput = {
    date?: Date | string
    type: string
    category: string
    description?: string | null
    amount: Decimal | DecimalJsLike | number | string
    reference?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    project?: ProjectCreateNestedOneWithoutTransactionsInput
  }

  export type FinancialTransactionUncheckedCreateInput = {
    id?: number
    projectId?: number | null
    date?: Date | string
    type: string
    category: string
    description?: string | null
    amount: Decimal | DecimalJsLike | number | string
    reference?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type FinancialTransactionUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    project?: ProjectUpdateOneWithoutTransactionsNestedInput
  }

  export type FinancialTransactionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: NullableIntFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type FinancialTransactionCreateManyInput = {
    id?: number
    projectId?: number | null
    date?: Date | string
    type: string
    category: string
    description?: string | null
    amount: Decimal | DecimalJsLike | number | string
    reference?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type FinancialTransactionUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type FinancialTransactionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: NullableIntFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[]
    notIn?: $Enums.UserRole[]
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type PurchaseOrderListRelationFilter = {
    every?: PurchaseOrderWhereInput
    some?: PurchaseOrderWhereInput
    none?: PurchaseOrderWhereInput
  }

  export type MaterialRequestListRelationFilter = {
    every?: MaterialRequestWhereInput
    some?: MaterialRequestWhereInput
    none?: MaterialRequestWhereInput
  }

  export type RFQListRelationFilter = {
    every?: RFQWhereInput
    some?: RFQWhereInput
    none?: RFQWhereInput
  }

  export type ReceivingReportListRelationFilter = {
    every?: ReceivingReportWhereInput
    some?: ReceivingReportWhereInput
    none?: ReceivingReportWhereInput
  }

  export type DisbursementListRelationFilter = {
    every?: DisbursementWhereInput
    some?: DisbursementWhereInput
    none?: DisbursementWhereInput
  }

  export type ProjectMemberListRelationFilter = {
    every?: ProjectMemberWhereInput
    some?: ProjectMemberWhereInput
    none?: ProjectMemberWhereInput
  }

  export type PurchaseOrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MaterialRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RFQOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReceivingReportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DisbursementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectMemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[]
    notIn?: $Enums.UserRole[]
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type CompanyCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    taxId?: SortOrder
    currency?: SortOrder
    logoUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanyAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CompanyMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    taxId?: SortOrder
    currency?: SortOrder
    logoUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanyMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    taxId?: SortOrder
    currency?: SortOrder
    logoUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type ProjectListRelationFilter = {
    every?: ProjectWhereInput
    some?: ProjectWhereInput
    none?: ProjectWhereInput
  }

  export type ProjectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClientCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    contactPerson?: SortOrder
    contractType?: SortOrder
    paymentTerms?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ClientMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    contactPerson?: SortOrder
    contractType?: SortOrder
    paymentTerms?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    contactPerson?: SortOrder
    contractType?: SortOrder
    paymentTerms?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type ClientNullableRelationFilter = {
    is?: ClientWhereInput | null
    isNot?: ClientWhereInput | null
  }

  export type FinancialTransactionListRelationFilter = {
    every?: FinancialTransactionWhereInput
    some?: FinancialTransactionWhereInput
    none?: FinancialTransactionWhereInput
  }

  export type InventoryItemListRelationFilter = {
    every?: InventoryItemWhereInput
    some?: InventoryItemWhereInput
    none?: InventoryItemWhereInput
  }

  export type BoqItemListRelationFilter = {
    every?: BoqItemWhereInput
    some?: BoqItemWhereInput
    none?: BoqItemWhereInput
  }

  export type FinancialTransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InventoryItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BoqItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectCountOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    name?: SortOrder
    location?: SortOrder
    duration?: SortOrder
    budget?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    totalFloorArea?: SortOrder
    carportArea?: SortOrder
  }

  export type ProjectAvgOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    budget?: SortOrder
    totalFloorArea?: SortOrder
    carportArea?: SortOrder
  }

  export type ProjectMaxOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    name?: SortOrder
    location?: SortOrder
    duration?: SortOrder
    budget?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    totalFloorArea?: SortOrder
    carportArea?: SortOrder
  }

  export type ProjectMinOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    name?: SortOrder
    location?: SortOrder
    duration?: SortOrder
    budget?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    totalFloorArea?: SortOrder
    carportArea?: SortOrder
  }

  export type ProjectSumOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    budget?: SortOrder
    totalFloorArea?: SortOrder
    carportArea?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type ProjectRelationFilter = {
    is?: ProjectWhereInput
    isNot?: ProjectWhereInput
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type ProjectMemberCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    assignedAt?: SortOrder
  }

  export type ProjectMemberAvgOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
  }

  export type ProjectMemberMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    assignedAt?: SortOrder
  }

  export type ProjectMemberMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    assignedAt?: SortOrder
  }

  export type ProjectMemberSumOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type BoqItemComponentListRelationFilter = {
    every?: BoqItemComponentWhereInput
    some?: BoqItemComponentWhereInput
    none?: BoqItemComponentWhereInput
  }

  export type BoqItemComponentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BoqItemProjectIdItemDescriptionCompoundUniqueInput = {
    projectId: number
    itemDescription: string
  }

  export type BoqItemCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    itemDescription?: SortOrder
    unit?: SortOrder
    materialUnitPrice?: SortOrder
    laborUnitPrice?: SortOrder
    quantity?: SortOrder
    isCarport?: SortOrder
  }

  export type BoqItemAvgOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    materialUnitPrice?: SortOrder
    laborUnitPrice?: SortOrder
    quantity?: SortOrder
  }

  export type BoqItemMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    itemDescription?: SortOrder
    unit?: SortOrder
    materialUnitPrice?: SortOrder
    laborUnitPrice?: SortOrder
    quantity?: SortOrder
    isCarport?: SortOrder
  }

  export type BoqItemMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    itemDescription?: SortOrder
    unit?: SortOrder
    materialUnitPrice?: SortOrder
    laborUnitPrice?: SortOrder
    quantity?: SortOrder
    isCarport?: SortOrder
  }

  export type BoqItemSumOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    materialUnitPrice?: SortOrder
    laborUnitPrice?: SortOrder
    quantity?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumResourceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ResourceType | EnumResourceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ResourceType[]
    notIn?: $Enums.ResourceType[]
    not?: NestedEnumResourceTypeFilter<$PrismaModel> | $Enums.ResourceType
  }

  export type BoqItemRelationFilter = {
    is?: BoqItemWhereInput
    isNot?: BoqItemWhereInput
  }

  export type BoqItemComponentCountOrderByAggregateInput = {
    id?: SortOrder
    boqItemId?: SortOrder
    resourceType?: SortOrder
    name?: SortOrder
    quantityFactor?: SortOrder
    unitRate?: SortOrder
    totalComponentCost?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BoqItemComponentAvgOrderByAggregateInput = {
    id?: SortOrder
    boqItemId?: SortOrder
    quantityFactor?: SortOrder
    unitRate?: SortOrder
    totalComponentCost?: SortOrder
  }

  export type BoqItemComponentMaxOrderByAggregateInput = {
    id?: SortOrder
    boqItemId?: SortOrder
    resourceType?: SortOrder
    name?: SortOrder
    quantityFactor?: SortOrder
    unitRate?: SortOrder
    totalComponentCost?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BoqItemComponentMinOrderByAggregateInput = {
    id?: SortOrder
    boqItemId?: SortOrder
    resourceType?: SortOrder
    name?: SortOrder
    quantityFactor?: SortOrder
    unitRate?: SortOrder
    totalComponentCost?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BoqItemComponentSumOrderByAggregateInput = {
    id?: SortOrder
    boqItemId?: SortOrder
    quantityFactor?: SortOrder
    unitRate?: SortOrder
    totalComponentCost?: SortOrder
  }

  export type EnumResourceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ResourceType | EnumResourceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ResourceType[]
    notIn?: $Enums.ResourceType[]
    not?: NestedEnumResourceTypeWithAggregatesFilter<$PrismaModel> | $Enums.ResourceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumResourceTypeFilter<$PrismaModel>
    _max?: NestedEnumResourceTypeFilter<$PrismaModel>
  }

  export type EnumMrStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MrStatus | EnumMrStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MrStatus[]
    notIn?: $Enums.MrStatus[]
    not?: NestedEnumMrStatusFilter<$PrismaModel> | $Enums.MrStatus
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type MaterialRequestItemListRelationFilter = {
    every?: MaterialRequestItemWhereInput
    some?: MaterialRequestItemWhereInput
    none?: MaterialRequestItemWhereInput
  }

  export type MaterialRequestItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MaterialRequestCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    requesterId?: SortOrder
    approverId?: SortOrder
    requestDate?: SortOrder
    status?: SortOrder
    remarks?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MaterialRequestAvgOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    requesterId?: SortOrder
    approverId?: SortOrder
  }

  export type MaterialRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    requesterId?: SortOrder
    approverId?: SortOrder
    requestDate?: SortOrder
    status?: SortOrder
    remarks?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MaterialRequestMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    requesterId?: SortOrder
    approverId?: SortOrder
    requestDate?: SortOrder
    status?: SortOrder
    remarks?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MaterialRequestSumOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    requesterId?: SortOrder
    approverId?: SortOrder
  }

  export type EnumMrStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MrStatus | EnumMrStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MrStatus[]
    notIn?: $Enums.MrStatus[]
    not?: NestedEnumMrStatusWithAggregatesFilter<$PrismaModel> | $Enums.MrStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMrStatusFilter<$PrismaModel>
    _max?: NestedEnumMrStatusFilter<$PrismaModel>
  }

  export type MaterialRequestRelationFilter = {
    is?: MaterialRequestWhereInput
    isNot?: MaterialRequestWhereInput
  }

  export type MaterialRequestItemCountOrderByAggregateInput = {
    id?: SortOrder
    materialRequestId?: SortOrder
    itemDescription?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    materialUnitPrice?: SortOrder
    laborUnitPrice?: SortOrder
    unit?: SortOrder
  }

  export type MaterialRequestItemAvgOrderByAggregateInput = {
    id?: SortOrder
    materialRequestId?: SortOrder
    quantity?: SortOrder
    materialUnitPrice?: SortOrder
    laborUnitPrice?: SortOrder
  }

  export type MaterialRequestItemMaxOrderByAggregateInput = {
    id?: SortOrder
    materialRequestId?: SortOrder
    itemDescription?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    materialUnitPrice?: SortOrder
    laborUnitPrice?: SortOrder
    unit?: SortOrder
  }

  export type MaterialRequestItemMinOrderByAggregateInput = {
    id?: SortOrder
    materialRequestId?: SortOrder
    itemDescription?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    materialUnitPrice?: SortOrder
    laborUnitPrice?: SortOrder
    unit?: SortOrder
  }

  export type MaterialRequestItemSumOrderByAggregateInput = {
    id?: SortOrder
    materialRequestId?: SortOrder
    quantity?: SortOrder
    materialUnitPrice?: SortOrder
    laborUnitPrice?: SortOrder
  }

  export type EnumRfqStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RfqStatus | EnumRfqStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RfqStatus[]
    notIn?: $Enums.RfqStatus[]
    not?: NestedEnumRfqStatusFilter<$PrismaModel> | $Enums.RfqStatus
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type MaterialRequestNullableRelationFilter = {
    is?: MaterialRequestWhereInput | null
    isNot?: MaterialRequestWhereInput | null
  }

  export type RFQItemListRelationFilter = {
    every?: RFQItemWhereInput
    some?: RFQItemWhereInput
    none?: RFQItemWhereInput
  }

  export type SupplierQuotationListRelationFilter = {
    every?: SupplierQuotationWhereInput
    some?: SupplierQuotationWhereInput
    none?: SupplierQuotationWhereInput
  }

  export type RFQItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SupplierQuotationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RFQCountOrderByAggregateInput = {
    id?: SortOrder
    mrId?: SortOrder
    createdById?: SortOrder
    title?: SortOrder
    status?: SortOrder
    dueDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RFQAvgOrderByAggregateInput = {
    id?: SortOrder
    mrId?: SortOrder
    createdById?: SortOrder
  }

  export type RFQMaxOrderByAggregateInput = {
    id?: SortOrder
    mrId?: SortOrder
    createdById?: SortOrder
    title?: SortOrder
    status?: SortOrder
    dueDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RFQMinOrderByAggregateInput = {
    id?: SortOrder
    mrId?: SortOrder
    createdById?: SortOrder
    title?: SortOrder
    status?: SortOrder
    dueDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RFQSumOrderByAggregateInput = {
    id?: SortOrder
    mrId?: SortOrder
    createdById?: SortOrder
  }

  export type EnumRfqStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RfqStatus | EnumRfqStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RfqStatus[]
    notIn?: $Enums.RfqStatus[]
    not?: NestedEnumRfqStatusWithAggregatesFilter<$PrismaModel> | $Enums.RfqStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRfqStatusFilter<$PrismaModel>
    _max?: NestedEnumRfqStatusFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type RFQRelationFilter = {
    is?: RFQWhereInput
    isNot?: RFQWhereInput
  }

  export type RFQItemCountOrderByAggregateInput = {
    id?: SortOrder
    rfqId?: SortOrder
    materialName?: SortOrder
    quantity?: SortOrder
    unit?: SortOrder
  }

  export type RFQItemAvgOrderByAggregateInput = {
    id?: SortOrder
    rfqId?: SortOrder
    quantity?: SortOrder
  }

  export type RFQItemMaxOrderByAggregateInput = {
    id?: SortOrder
    rfqId?: SortOrder
    materialName?: SortOrder
    quantity?: SortOrder
    unit?: SortOrder
  }

  export type RFQItemMinOrderByAggregateInput = {
    id?: SortOrder
    rfqId?: SortOrder
    materialName?: SortOrder
    quantity?: SortOrder
    unit?: SortOrder
  }

  export type RFQItemSumOrderByAggregateInput = {
    id?: SortOrder
    rfqId?: SortOrder
    quantity?: SortOrder
  }

  export type SupplierInvoiceListRelationFilter = {
    every?: SupplierInvoiceWhereInput
    some?: SupplierInvoiceWhereInput
    none?: SupplierInvoiceWhereInput
  }

  export type SupplierInvoiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SupplierCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    contactPerson?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    rating?: SortOrder
  }

  export type SupplierAvgOrderByAggregateInput = {
    id?: SortOrder
    rating?: SortOrder
  }

  export type SupplierMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    contactPerson?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    rating?: SortOrder
  }

  export type SupplierMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    contactPerson?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    rating?: SortOrder
  }

  export type SupplierSumOrderByAggregateInput = {
    id?: SortOrder
    rating?: SortOrder
  }

  export type MaterialCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    unit?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MaterialAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type MaterialMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    unit?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MaterialMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    unit?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MaterialSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UnitCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    abbreviation?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UnitAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UnitMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    abbreviation?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UnitMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    abbreviation?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UnitSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategorySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type WarehouseCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    type?: SortOrder
  }

  export type WarehouseAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type WarehouseMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    type?: SortOrder
  }

  export type WarehouseMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    type?: SortOrder
  }

  export type WarehouseSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SupplierRelationFilter = {
    is?: SupplierWhereInput
    isNot?: SupplierWhereInput
  }

  export type QuotationItemListRelationFilter = {
    every?: QuotationItemWhereInput
    some?: QuotationItemWhereInput
    none?: QuotationItemWhereInput
  }

  export type QuotationItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SupplierQuotationCountOrderByAggregateInput = {
    id?: SortOrder
    rfqId?: SortOrder
    supplierId?: SortOrder
    quoteDate?: SortOrder
    totalAmount?: SortOrder
    currency?: SortOrder
    isSelected?: SortOrder
  }

  export type SupplierQuotationAvgOrderByAggregateInput = {
    id?: SortOrder
    rfqId?: SortOrder
    supplierId?: SortOrder
    totalAmount?: SortOrder
  }

  export type SupplierQuotationMaxOrderByAggregateInput = {
    id?: SortOrder
    rfqId?: SortOrder
    supplierId?: SortOrder
    quoteDate?: SortOrder
    totalAmount?: SortOrder
    currency?: SortOrder
    isSelected?: SortOrder
  }

  export type SupplierQuotationMinOrderByAggregateInput = {
    id?: SortOrder
    rfqId?: SortOrder
    supplierId?: SortOrder
    quoteDate?: SortOrder
    totalAmount?: SortOrder
    currency?: SortOrder
    isSelected?: SortOrder
  }

  export type SupplierQuotationSumOrderByAggregateInput = {
    id?: SortOrder
    rfqId?: SortOrder
    supplierId?: SortOrder
    totalAmount?: SortOrder
  }

  export type SupplierQuotationRelationFilter = {
    is?: SupplierQuotationWhereInput
    isNot?: SupplierQuotationWhereInput
  }

  export type QuotationItemCountOrderByAggregateInput = {
    id?: SortOrder
    supplierQuotationId?: SortOrder
    materialName?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    remarks?: SortOrder
  }

  export type QuotationItemAvgOrderByAggregateInput = {
    id?: SortOrder
    supplierQuotationId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
  }

  export type QuotationItemMaxOrderByAggregateInput = {
    id?: SortOrder
    supplierQuotationId?: SortOrder
    materialName?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    remarks?: SortOrder
  }

  export type QuotationItemMinOrderByAggregateInput = {
    id?: SortOrder
    supplierQuotationId?: SortOrder
    materialName?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    remarks?: SortOrder
  }

  export type QuotationItemSumOrderByAggregateInput = {
    id?: SortOrder
    supplierQuotationId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
  }

  export type EnumPoStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PoStatus | EnumPoStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PoStatus[]
    notIn?: $Enums.PoStatus[]
    not?: NestedEnumPoStatusFilter<$PrismaModel> | $Enums.PoStatus
  }

  export type SupplierNullableRelationFilter = {
    is?: SupplierWhereInput | null
    isNot?: SupplierWhereInput | null
  }

  export type PurchaseOrderItemListRelationFilter = {
    every?: PurchaseOrderItemWhereInput
    some?: PurchaseOrderItemWhereInput
    none?: PurchaseOrderItemWhereInput
  }

  export type PurchaseOrderItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PurchaseOrderCountOrderByAggregateInput = {
    id?: SortOrder
    orderDate?: SortOrder
    projectId?: SortOrder
    supplierId?: SortOrder
    requesterId?: SortOrder
    approverId?: SortOrder
    status?: SortOrder
    remarks?: SortOrder
    totalAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseOrderAvgOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    supplierId?: SortOrder
    requesterId?: SortOrder
    approverId?: SortOrder
    totalAmount?: SortOrder
  }

  export type PurchaseOrderMaxOrderByAggregateInput = {
    id?: SortOrder
    orderDate?: SortOrder
    projectId?: SortOrder
    supplierId?: SortOrder
    requesterId?: SortOrder
    approverId?: SortOrder
    status?: SortOrder
    remarks?: SortOrder
    totalAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseOrderMinOrderByAggregateInput = {
    id?: SortOrder
    orderDate?: SortOrder
    projectId?: SortOrder
    supplierId?: SortOrder
    requesterId?: SortOrder
    approverId?: SortOrder
    status?: SortOrder
    remarks?: SortOrder
    totalAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseOrderSumOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    supplierId?: SortOrder
    requesterId?: SortOrder
    approverId?: SortOrder
    totalAmount?: SortOrder
  }

  export type EnumPoStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PoStatus | EnumPoStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PoStatus[]
    notIn?: $Enums.PoStatus[]
    not?: NestedEnumPoStatusWithAggregatesFilter<$PrismaModel> | $Enums.PoStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPoStatusFilter<$PrismaModel>
    _max?: NestedEnumPoStatusFilter<$PrismaModel>
  }

  export type PurchaseOrderRelationFilter = {
    is?: PurchaseOrderWhereInput
    isNot?: PurchaseOrderWhereInput
  }

  export type PurchaseOrderItemCountOrderByAggregateInput = {
    id?: SortOrder
    purchaseOrderId?: SortOrder
    materialName?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unit?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
  }

  export type PurchaseOrderItemAvgOrderByAggregateInput = {
    id?: SortOrder
    purchaseOrderId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
  }

  export type PurchaseOrderItemMaxOrderByAggregateInput = {
    id?: SortOrder
    purchaseOrderId?: SortOrder
    materialName?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unit?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
  }

  export type PurchaseOrderItemMinOrderByAggregateInput = {
    id?: SortOrder
    purchaseOrderId?: SortOrder
    materialName?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unit?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
  }

  export type PurchaseOrderItemSumOrderByAggregateInput = {
    id?: SortOrder
    purchaseOrderId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
  }

  export type ReceivingItemListRelationFilter = {
    every?: ReceivingItemWhereInput
    some?: ReceivingItemWhereInput
    none?: ReceivingItemWhereInput
  }

  export type ReceivingItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReceivingReportCountOrderByAggregateInput = {
    id?: SortOrder
    purchaseOrderId?: SortOrder
    receivedById?: SortOrder
    receivedDate?: SortOrder
    deliveryNoteNo?: SortOrder
    notes?: SortOrder
  }

  export type ReceivingReportAvgOrderByAggregateInput = {
    id?: SortOrder
    purchaseOrderId?: SortOrder
    receivedById?: SortOrder
  }

  export type ReceivingReportMaxOrderByAggregateInput = {
    id?: SortOrder
    purchaseOrderId?: SortOrder
    receivedById?: SortOrder
    receivedDate?: SortOrder
    deliveryNoteNo?: SortOrder
    notes?: SortOrder
  }

  export type ReceivingReportMinOrderByAggregateInput = {
    id?: SortOrder
    purchaseOrderId?: SortOrder
    receivedById?: SortOrder
    receivedDate?: SortOrder
    deliveryNoteNo?: SortOrder
    notes?: SortOrder
  }

  export type ReceivingReportSumOrderByAggregateInput = {
    id?: SortOrder
    purchaseOrderId?: SortOrder
    receivedById?: SortOrder
  }

  export type ReceivingReportRelationFilter = {
    is?: ReceivingReportWhereInput
    isNot?: ReceivingReportWhereInput
  }

  export type ReceivingItemCountOrderByAggregateInput = {
    id?: SortOrder
    receivingReportId?: SortOrder
    materialName?: SortOrder
    quantityReceived?: SortOrder
    status?: SortOrder
  }

  export type ReceivingItemAvgOrderByAggregateInput = {
    id?: SortOrder
    receivingReportId?: SortOrder
    quantityReceived?: SortOrder
  }

  export type ReceivingItemMaxOrderByAggregateInput = {
    id?: SortOrder
    receivingReportId?: SortOrder
    materialName?: SortOrder
    quantityReceived?: SortOrder
    status?: SortOrder
  }

  export type ReceivingItemMinOrderByAggregateInput = {
    id?: SortOrder
    receivingReportId?: SortOrder
    materialName?: SortOrder
    quantityReceived?: SortOrder
    status?: SortOrder
  }

  export type ReceivingItemSumOrderByAggregateInput = {
    id?: SortOrder
    receivingReportId?: SortOrder
    quantityReceived?: SortOrder
  }

  export type ProjectNullableRelationFilter = {
    is?: ProjectWhereInput | null
    isNot?: ProjectWhereInput | null
  }

  export type WarehouseNullableRelationFilter = {
    is?: WarehouseWhereInput | null
    isNot?: WarehouseWhereInput | null
  }

  export type InventoryItemCountOrderByAggregateInput = {
    id?: SortOrder
    materialName?: SortOrder
    projectId?: SortOrder
    warehouseId?: SortOrder
    quantity?: SortOrder
    unit?: SortOrder
    lastUpdated?: SortOrder
  }

  export type InventoryItemAvgOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    warehouseId?: SortOrder
    quantity?: SortOrder
  }

  export type InventoryItemMaxOrderByAggregateInput = {
    id?: SortOrder
    materialName?: SortOrder
    projectId?: SortOrder
    warehouseId?: SortOrder
    quantity?: SortOrder
    unit?: SortOrder
    lastUpdated?: SortOrder
  }

  export type InventoryItemMinOrderByAggregateInput = {
    id?: SortOrder
    materialName?: SortOrder
    projectId?: SortOrder
    warehouseId?: SortOrder
    quantity?: SortOrder
    unit?: SortOrder
    lastUpdated?: SortOrder
  }

  export type InventoryItemSumOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    warehouseId?: SortOrder
    quantity?: SortOrder
  }

  export type WorkflowRuleCountOrderByAggregateInput = {
    id?: SortOrder
    processType?: SortOrder
    minAmount?: SortOrder
    maxAmount?: SortOrder
    approverRole?: SortOrder
    stepOrder?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkflowRuleAvgOrderByAggregateInput = {
    id?: SortOrder
    minAmount?: SortOrder
    maxAmount?: SortOrder
    stepOrder?: SortOrder
  }

  export type WorkflowRuleMaxOrderByAggregateInput = {
    id?: SortOrder
    processType?: SortOrder
    minAmount?: SortOrder
    maxAmount?: SortOrder
    approverRole?: SortOrder
    stepOrder?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkflowRuleMinOrderByAggregateInput = {
    id?: SortOrder
    processType?: SortOrder
    minAmount?: SortOrder
    maxAmount?: SortOrder
    approverRole?: SortOrder
    stepOrder?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkflowRuleSumOrderByAggregateInput = {
    id?: SortOrder
    minAmount?: SortOrder
    maxAmount?: SortOrder
    stepOrder?: SortOrder
  }

  export type PurchaseOrderNullableRelationFilter = {
    is?: PurchaseOrderWhereInput | null
    isNot?: PurchaseOrderWhereInput | null
  }

  export type ReceivingReportNullableRelationFilter = {
    is?: ReceivingReportWhereInput | null
    isNot?: ReceivingReportWhereInput | null
  }

  export type SupplierInvoiceCountOrderByAggregateInput = {
    id?: SortOrder
    invoiceNumber?: SortOrder
    invoiceDate?: SortOrder
    supplierId?: SortOrder
    purchaseOrderId?: SortOrder
    receivingReportId?: SortOrder
    totalAmount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type SupplierInvoiceAvgOrderByAggregateInput = {
    id?: SortOrder
    supplierId?: SortOrder
    purchaseOrderId?: SortOrder
    receivingReportId?: SortOrder
    totalAmount?: SortOrder
  }

  export type SupplierInvoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    invoiceNumber?: SortOrder
    invoiceDate?: SortOrder
    supplierId?: SortOrder
    purchaseOrderId?: SortOrder
    receivingReportId?: SortOrder
    totalAmount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type SupplierInvoiceMinOrderByAggregateInput = {
    id?: SortOrder
    invoiceNumber?: SortOrder
    invoiceDate?: SortOrder
    supplierId?: SortOrder
    purchaseOrderId?: SortOrder
    receivingReportId?: SortOrder
    totalAmount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type SupplierInvoiceSumOrderByAggregateInput = {
    id?: SortOrder
    supplierId?: SortOrder
    purchaseOrderId?: SortOrder
    receivingReportId?: SortOrder
    totalAmount?: SortOrder
  }

  export type EnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[]
    notIn?: $Enums.PaymentMethod[]
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type DisbursementCountOrderByAggregateInput = {
    id?: SortOrder
    purchaseOrderId?: SortOrder
    processedById?: SortOrder
    amount?: SortOrder
    paymentDate?: SortOrder
    method?: SortOrder
    referenceNumber?: SortOrder
    status?: SortOrder
  }

  export type DisbursementAvgOrderByAggregateInput = {
    id?: SortOrder
    purchaseOrderId?: SortOrder
    processedById?: SortOrder
    amount?: SortOrder
  }

  export type DisbursementMaxOrderByAggregateInput = {
    id?: SortOrder
    purchaseOrderId?: SortOrder
    processedById?: SortOrder
    amount?: SortOrder
    paymentDate?: SortOrder
    method?: SortOrder
    referenceNumber?: SortOrder
    status?: SortOrder
  }

  export type DisbursementMinOrderByAggregateInput = {
    id?: SortOrder
    purchaseOrderId?: SortOrder
    processedById?: SortOrder
    amount?: SortOrder
    paymentDate?: SortOrder
    method?: SortOrder
    referenceNumber?: SortOrder
    status?: SortOrder
  }

  export type DisbursementSumOrderByAggregateInput = {
    id?: SortOrder
    purchaseOrderId?: SortOrder
    processedById?: SortOrder
    amount?: SortOrder
  }

  export type EnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[]
    notIn?: $Enums.PaymentMethod[]
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type FinancialTransactionCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    date?: SortOrder
    type?: SortOrder
    category?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    reference?: SortOrder
    metadata?: SortOrder
  }

  export type FinancialTransactionAvgOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    amount?: SortOrder
  }

  export type FinancialTransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    date?: SortOrder
    type?: SortOrder
    category?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    reference?: SortOrder
  }

  export type FinancialTransactionMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    date?: SortOrder
    type?: SortOrder
    category?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    reference?: SortOrder
  }

  export type FinancialTransactionSumOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    amount?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type PurchaseOrderCreateNestedManyWithoutRequesterInput = {
    create?: XOR<PurchaseOrderCreateWithoutRequesterInput, PurchaseOrderUncheckedCreateWithoutRequesterInput> | PurchaseOrderCreateWithoutRequesterInput[] | PurchaseOrderUncheckedCreateWithoutRequesterInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutRequesterInput | PurchaseOrderCreateOrConnectWithoutRequesterInput[]
    createMany?: PurchaseOrderCreateManyRequesterInputEnvelope
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
  }

  export type PurchaseOrderCreateNestedManyWithoutApproverInput = {
    create?: XOR<PurchaseOrderCreateWithoutApproverInput, PurchaseOrderUncheckedCreateWithoutApproverInput> | PurchaseOrderCreateWithoutApproverInput[] | PurchaseOrderUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutApproverInput | PurchaseOrderCreateOrConnectWithoutApproverInput[]
    createMany?: PurchaseOrderCreateManyApproverInputEnvelope
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
  }

  export type MaterialRequestCreateNestedManyWithoutRequesterInput = {
    create?: XOR<MaterialRequestCreateWithoutRequesterInput, MaterialRequestUncheckedCreateWithoutRequesterInput> | MaterialRequestCreateWithoutRequesterInput[] | MaterialRequestUncheckedCreateWithoutRequesterInput[]
    connectOrCreate?: MaterialRequestCreateOrConnectWithoutRequesterInput | MaterialRequestCreateOrConnectWithoutRequesterInput[]
    createMany?: MaterialRequestCreateManyRequesterInputEnvelope
    connect?: MaterialRequestWhereUniqueInput | MaterialRequestWhereUniqueInput[]
  }

  export type MaterialRequestCreateNestedManyWithoutApproverInput = {
    create?: XOR<MaterialRequestCreateWithoutApproverInput, MaterialRequestUncheckedCreateWithoutApproverInput> | MaterialRequestCreateWithoutApproverInput[] | MaterialRequestUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: MaterialRequestCreateOrConnectWithoutApproverInput | MaterialRequestCreateOrConnectWithoutApproverInput[]
    createMany?: MaterialRequestCreateManyApproverInputEnvelope
    connect?: MaterialRequestWhereUniqueInput | MaterialRequestWhereUniqueInput[]
  }

  export type RFQCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<RFQCreateWithoutCreatedByInput, RFQUncheckedCreateWithoutCreatedByInput> | RFQCreateWithoutCreatedByInput[] | RFQUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: RFQCreateOrConnectWithoutCreatedByInput | RFQCreateOrConnectWithoutCreatedByInput[]
    createMany?: RFQCreateManyCreatedByInputEnvelope
    connect?: RFQWhereUniqueInput | RFQWhereUniqueInput[]
  }

  export type ReceivingReportCreateNestedManyWithoutReceivedByInput = {
    create?: XOR<ReceivingReportCreateWithoutReceivedByInput, ReceivingReportUncheckedCreateWithoutReceivedByInput> | ReceivingReportCreateWithoutReceivedByInput[] | ReceivingReportUncheckedCreateWithoutReceivedByInput[]
    connectOrCreate?: ReceivingReportCreateOrConnectWithoutReceivedByInput | ReceivingReportCreateOrConnectWithoutReceivedByInput[]
    createMany?: ReceivingReportCreateManyReceivedByInputEnvelope
    connect?: ReceivingReportWhereUniqueInput | ReceivingReportWhereUniqueInput[]
  }

  export type DisbursementCreateNestedManyWithoutProcessedByInput = {
    create?: XOR<DisbursementCreateWithoutProcessedByInput, DisbursementUncheckedCreateWithoutProcessedByInput> | DisbursementCreateWithoutProcessedByInput[] | DisbursementUncheckedCreateWithoutProcessedByInput[]
    connectOrCreate?: DisbursementCreateOrConnectWithoutProcessedByInput | DisbursementCreateOrConnectWithoutProcessedByInput[]
    createMany?: DisbursementCreateManyProcessedByInputEnvelope
    connect?: DisbursementWhereUniqueInput | DisbursementWhereUniqueInput[]
  }

  export type ProjectMemberCreateNestedManyWithoutUserInput = {
    create?: XOR<ProjectMemberCreateWithoutUserInput, ProjectMemberUncheckedCreateWithoutUserInput> | ProjectMemberCreateWithoutUserInput[] | ProjectMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectMemberCreateOrConnectWithoutUserInput | ProjectMemberCreateOrConnectWithoutUserInput[]
    createMany?: ProjectMemberCreateManyUserInputEnvelope
    connect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
  }

  export type PurchaseOrderUncheckedCreateNestedManyWithoutRequesterInput = {
    create?: XOR<PurchaseOrderCreateWithoutRequesterInput, PurchaseOrderUncheckedCreateWithoutRequesterInput> | PurchaseOrderCreateWithoutRequesterInput[] | PurchaseOrderUncheckedCreateWithoutRequesterInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutRequesterInput | PurchaseOrderCreateOrConnectWithoutRequesterInput[]
    createMany?: PurchaseOrderCreateManyRequesterInputEnvelope
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
  }

  export type PurchaseOrderUncheckedCreateNestedManyWithoutApproverInput = {
    create?: XOR<PurchaseOrderCreateWithoutApproverInput, PurchaseOrderUncheckedCreateWithoutApproverInput> | PurchaseOrderCreateWithoutApproverInput[] | PurchaseOrderUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutApproverInput | PurchaseOrderCreateOrConnectWithoutApproverInput[]
    createMany?: PurchaseOrderCreateManyApproverInputEnvelope
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
  }

  export type MaterialRequestUncheckedCreateNestedManyWithoutRequesterInput = {
    create?: XOR<MaterialRequestCreateWithoutRequesterInput, MaterialRequestUncheckedCreateWithoutRequesterInput> | MaterialRequestCreateWithoutRequesterInput[] | MaterialRequestUncheckedCreateWithoutRequesterInput[]
    connectOrCreate?: MaterialRequestCreateOrConnectWithoutRequesterInput | MaterialRequestCreateOrConnectWithoutRequesterInput[]
    createMany?: MaterialRequestCreateManyRequesterInputEnvelope
    connect?: MaterialRequestWhereUniqueInput | MaterialRequestWhereUniqueInput[]
  }

  export type MaterialRequestUncheckedCreateNestedManyWithoutApproverInput = {
    create?: XOR<MaterialRequestCreateWithoutApproverInput, MaterialRequestUncheckedCreateWithoutApproverInput> | MaterialRequestCreateWithoutApproverInput[] | MaterialRequestUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: MaterialRequestCreateOrConnectWithoutApproverInput | MaterialRequestCreateOrConnectWithoutApproverInput[]
    createMany?: MaterialRequestCreateManyApproverInputEnvelope
    connect?: MaterialRequestWhereUniqueInput | MaterialRequestWhereUniqueInput[]
  }

  export type RFQUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<RFQCreateWithoutCreatedByInput, RFQUncheckedCreateWithoutCreatedByInput> | RFQCreateWithoutCreatedByInput[] | RFQUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: RFQCreateOrConnectWithoutCreatedByInput | RFQCreateOrConnectWithoutCreatedByInput[]
    createMany?: RFQCreateManyCreatedByInputEnvelope
    connect?: RFQWhereUniqueInput | RFQWhereUniqueInput[]
  }

  export type ReceivingReportUncheckedCreateNestedManyWithoutReceivedByInput = {
    create?: XOR<ReceivingReportCreateWithoutReceivedByInput, ReceivingReportUncheckedCreateWithoutReceivedByInput> | ReceivingReportCreateWithoutReceivedByInput[] | ReceivingReportUncheckedCreateWithoutReceivedByInput[]
    connectOrCreate?: ReceivingReportCreateOrConnectWithoutReceivedByInput | ReceivingReportCreateOrConnectWithoutReceivedByInput[]
    createMany?: ReceivingReportCreateManyReceivedByInputEnvelope
    connect?: ReceivingReportWhereUniqueInput | ReceivingReportWhereUniqueInput[]
  }

  export type DisbursementUncheckedCreateNestedManyWithoutProcessedByInput = {
    create?: XOR<DisbursementCreateWithoutProcessedByInput, DisbursementUncheckedCreateWithoutProcessedByInput> | DisbursementCreateWithoutProcessedByInput[] | DisbursementUncheckedCreateWithoutProcessedByInput[]
    connectOrCreate?: DisbursementCreateOrConnectWithoutProcessedByInput | DisbursementCreateOrConnectWithoutProcessedByInput[]
    createMany?: DisbursementCreateManyProcessedByInputEnvelope
    connect?: DisbursementWhereUniqueInput | DisbursementWhereUniqueInput[]
  }

  export type ProjectMemberUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ProjectMemberCreateWithoutUserInput, ProjectMemberUncheckedCreateWithoutUserInput> | ProjectMemberCreateWithoutUserInput[] | ProjectMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectMemberCreateOrConnectWithoutUserInput | ProjectMemberCreateOrConnectWithoutUserInput[]
    createMany?: ProjectMemberCreateManyUserInputEnvelope
    connect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type PurchaseOrderUpdateManyWithoutRequesterNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutRequesterInput, PurchaseOrderUncheckedCreateWithoutRequesterInput> | PurchaseOrderCreateWithoutRequesterInput[] | PurchaseOrderUncheckedCreateWithoutRequesterInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutRequesterInput | PurchaseOrderCreateOrConnectWithoutRequesterInput[]
    upsert?: PurchaseOrderUpsertWithWhereUniqueWithoutRequesterInput | PurchaseOrderUpsertWithWhereUniqueWithoutRequesterInput[]
    createMany?: PurchaseOrderCreateManyRequesterInputEnvelope
    set?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    disconnect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    delete?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    update?: PurchaseOrderUpdateWithWhereUniqueWithoutRequesterInput | PurchaseOrderUpdateWithWhereUniqueWithoutRequesterInput[]
    updateMany?: PurchaseOrderUpdateManyWithWhereWithoutRequesterInput | PurchaseOrderUpdateManyWithWhereWithoutRequesterInput[]
    deleteMany?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
  }

  export type PurchaseOrderUpdateManyWithoutApproverNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutApproverInput, PurchaseOrderUncheckedCreateWithoutApproverInput> | PurchaseOrderCreateWithoutApproverInput[] | PurchaseOrderUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutApproverInput | PurchaseOrderCreateOrConnectWithoutApproverInput[]
    upsert?: PurchaseOrderUpsertWithWhereUniqueWithoutApproverInput | PurchaseOrderUpsertWithWhereUniqueWithoutApproverInput[]
    createMany?: PurchaseOrderCreateManyApproverInputEnvelope
    set?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    disconnect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    delete?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    update?: PurchaseOrderUpdateWithWhereUniqueWithoutApproverInput | PurchaseOrderUpdateWithWhereUniqueWithoutApproverInput[]
    updateMany?: PurchaseOrderUpdateManyWithWhereWithoutApproverInput | PurchaseOrderUpdateManyWithWhereWithoutApproverInput[]
    deleteMany?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
  }

  export type MaterialRequestUpdateManyWithoutRequesterNestedInput = {
    create?: XOR<MaterialRequestCreateWithoutRequesterInput, MaterialRequestUncheckedCreateWithoutRequesterInput> | MaterialRequestCreateWithoutRequesterInput[] | MaterialRequestUncheckedCreateWithoutRequesterInput[]
    connectOrCreate?: MaterialRequestCreateOrConnectWithoutRequesterInput | MaterialRequestCreateOrConnectWithoutRequesterInput[]
    upsert?: MaterialRequestUpsertWithWhereUniqueWithoutRequesterInput | MaterialRequestUpsertWithWhereUniqueWithoutRequesterInput[]
    createMany?: MaterialRequestCreateManyRequesterInputEnvelope
    set?: MaterialRequestWhereUniqueInput | MaterialRequestWhereUniqueInput[]
    disconnect?: MaterialRequestWhereUniqueInput | MaterialRequestWhereUniqueInput[]
    delete?: MaterialRequestWhereUniqueInput | MaterialRequestWhereUniqueInput[]
    connect?: MaterialRequestWhereUniqueInput | MaterialRequestWhereUniqueInput[]
    update?: MaterialRequestUpdateWithWhereUniqueWithoutRequesterInput | MaterialRequestUpdateWithWhereUniqueWithoutRequesterInput[]
    updateMany?: MaterialRequestUpdateManyWithWhereWithoutRequesterInput | MaterialRequestUpdateManyWithWhereWithoutRequesterInput[]
    deleteMany?: MaterialRequestScalarWhereInput | MaterialRequestScalarWhereInput[]
  }

  export type MaterialRequestUpdateManyWithoutApproverNestedInput = {
    create?: XOR<MaterialRequestCreateWithoutApproverInput, MaterialRequestUncheckedCreateWithoutApproverInput> | MaterialRequestCreateWithoutApproverInput[] | MaterialRequestUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: MaterialRequestCreateOrConnectWithoutApproverInput | MaterialRequestCreateOrConnectWithoutApproverInput[]
    upsert?: MaterialRequestUpsertWithWhereUniqueWithoutApproverInput | MaterialRequestUpsertWithWhereUniqueWithoutApproverInput[]
    createMany?: MaterialRequestCreateManyApproverInputEnvelope
    set?: MaterialRequestWhereUniqueInput | MaterialRequestWhereUniqueInput[]
    disconnect?: MaterialRequestWhereUniqueInput | MaterialRequestWhereUniqueInput[]
    delete?: MaterialRequestWhereUniqueInput | MaterialRequestWhereUniqueInput[]
    connect?: MaterialRequestWhereUniqueInput | MaterialRequestWhereUniqueInput[]
    update?: MaterialRequestUpdateWithWhereUniqueWithoutApproverInput | MaterialRequestUpdateWithWhereUniqueWithoutApproverInput[]
    updateMany?: MaterialRequestUpdateManyWithWhereWithoutApproverInput | MaterialRequestUpdateManyWithWhereWithoutApproverInput[]
    deleteMany?: MaterialRequestScalarWhereInput | MaterialRequestScalarWhereInput[]
  }

  export type RFQUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<RFQCreateWithoutCreatedByInput, RFQUncheckedCreateWithoutCreatedByInput> | RFQCreateWithoutCreatedByInput[] | RFQUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: RFQCreateOrConnectWithoutCreatedByInput | RFQCreateOrConnectWithoutCreatedByInput[]
    upsert?: RFQUpsertWithWhereUniqueWithoutCreatedByInput | RFQUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: RFQCreateManyCreatedByInputEnvelope
    set?: RFQWhereUniqueInput | RFQWhereUniqueInput[]
    disconnect?: RFQWhereUniqueInput | RFQWhereUniqueInput[]
    delete?: RFQWhereUniqueInput | RFQWhereUniqueInput[]
    connect?: RFQWhereUniqueInput | RFQWhereUniqueInput[]
    update?: RFQUpdateWithWhereUniqueWithoutCreatedByInput | RFQUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: RFQUpdateManyWithWhereWithoutCreatedByInput | RFQUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: RFQScalarWhereInput | RFQScalarWhereInput[]
  }

  export type ReceivingReportUpdateManyWithoutReceivedByNestedInput = {
    create?: XOR<ReceivingReportCreateWithoutReceivedByInput, ReceivingReportUncheckedCreateWithoutReceivedByInput> | ReceivingReportCreateWithoutReceivedByInput[] | ReceivingReportUncheckedCreateWithoutReceivedByInput[]
    connectOrCreate?: ReceivingReportCreateOrConnectWithoutReceivedByInput | ReceivingReportCreateOrConnectWithoutReceivedByInput[]
    upsert?: ReceivingReportUpsertWithWhereUniqueWithoutReceivedByInput | ReceivingReportUpsertWithWhereUniqueWithoutReceivedByInput[]
    createMany?: ReceivingReportCreateManyReceivedByInputEnvelope
    set?: ReceivingReportWhereUniqueInput | ReceivingReportWhereUniqueInput[]
    disconnect?: ReceivingReportWhereUniqueInput | ReceivingReportWhereUniqueInput[]
    delete?: ReceivingReportWhereUniqueInput | ReceivingReportWhereUniqueInput[]
    connect?: ReceivingReportWhereUniqueInput | ReceivingReportWhereUniqueInput[]
    update?: ReceivingReportUpdateWithWhereUniqueWithoutReceivedByInput | ReceivingReportUpdateWithWhereUniqueWithoutReceivedByInput[]
    updateMany?: ReceivingReportUpdateManyWithWhereWithoutReceivedByInput | ReceivingReportUpdateManyWithWhereWithoutReceivedByInput[]
    deleteMany?: ReceivingReportScalarWhereInput | ReceivingReportScalarWhereInput[]
  }

  export type DisbursementUpdateManyWithoutProcessedByNestedInput = {
    create?: XOR<DisbursementCreateWithoutProcessedByInput, DisbursementUncheckedCreateWithoutProcessedByInput> | DisbursementCreateWithoutProcessedByInput[] | DisbursementUncheckedCreateWithoutProcessedByInput[]
    connectOrCreate?: DisbursementCreateOrConnectWithoutProcessedByInput | DisbursementCreateOrConnectWithoutProcessedByInput[]
    upsert?: DisbursementUpsertWithWhereUniqueWithoutProcessedByInput | DisbursementUpsertWithWhereUniqueWithoutProcessedByInput[]
    createMany?: DisbursementCreateManyProcessedByInputEnvelope
    set?: DisbursementWhereUniqueInput | DisbursementWhereUniqueInput[]
    disconnect?: DisbursementWhereUniqueInput | DisbursementWhereUniqueInput[]
    delete?: DisbursementWhereUniqueInput | DisbursementWhereUniqueInput[]
    connect?: DisbursementWhereUniqueInput | DisbursementWhereUniqueInput[]
    update?: DisbursementUpdateWithWhereUniqueWithoutProcessedByInput | DisbursementUpdateWithWhereUniqueWithoutProcessedByInput[]
    updateMany?: DisbursementUpdateManyWithWhereWithoutProcessedByInput | DisbursementUpdateManyWithWhereWithoutProcessedByInput[]
    deleteMany?: DisbursementScalarWhereInput | DisbursementScalarWhereInput[]
  }

  export type ProjectMemberUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProjectMemberCreateWithoutUserInput, ProjectMemberUncheckedCreateWithoutUserInput> | ProjectMemberCreateWithoutUserInput[] | ProjectMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectMemberCreateOrConnectWithoutUserInput | ProjectMemberCreateOrConnectWithoutUserInput[]
    upsert?: ProjectMemberUpsertWithWhereUniqueWithoutUserInput | ProjectMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProjectMemberCreateManyUserInputEnvelope
    set?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    disconnect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    delete?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    connect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    update?: ProjectMemberUpdateWithWhereUniqueWithoutUserInput | ProjectMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProjectMemberUpdateManyWithWhereWithoutUserInput | ProjectMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProjectMemberScalarWhereInput | ProjectMemberScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type PurchaseOrderUncheckedUpdateManyWithoutRequesterNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutRequesterInput, PurchaseOrderUncheckedCreateWithoutRequesterInput> | PurchaseOrderCreateWithoutRequesterInput[] | PurchaseOrderUncheckedCreateWithoutRequesterInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutRequesterInput | PurchaseOrderCreateOrConnectWithoutRequesterInput[]
    upsert?: PurchaseOrderUpsertWithWhereUniqueWithoutRequesterInput | PurchaseOrderUpsertWithWhereUniqueWithoutRequesterInput[]
    createMany?: PurchaseOrderCreateManyRequesterInputEnvelope
    set?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    disconnect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    delete?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    update?: PurchaseOrderUpdateWithWhereUniqueWithoutRequesterInput | PurchaseOrderUpdateWithWhereUniqueWithoutRequesterInput[]
    updateMany?: PurchaseOrderUpdateManyWithWhereWithoutRequesterInput | PurchaseOrderUpdateManyWithWhereWithoutRequesterInput[]
    deleteMany?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
  }

  export type PurchaseOrderUncheckedUpdateManyWithoutApproverNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutApproverInput, PurchaseOrderUncheckedCreateWithoutApproverInput> | PurchaseOrderCreateWithoutApproverInput[] | PurchaseOrderUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutApproverInput | PurchaseOrderCreateOrConnectWithoutApproverInput[]
    upsert?: PurchaseOrderUpsertWithWhereUniqueWithoutApproverInput | PurchaseOrderUpsertWithWhereUniqueWithoutApproverInput[]
    createMany?: PurchaseOrderCreateManyApproverInputEnvelope
    set?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    disconnect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    delete?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    update?: PurchaseOrderUpdateWithWhereUniqueWithoutApproverInput | PurchaseOrderUpdateWithWhereUniqueWithoutApproverInput[]
    updateMany?: PurchaseOrderUpdateManyWithWhereWithoutApproverInput | PurchaseOrderUpdateManyWithWhereWithoutApproverInput[]
    deleteMany?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
  }

  export type MaterialRequestUncheckedUpdateManyWithoutRequesterNestedInput = {
    create?: XOR<MaterialRequestCreateWithoutRequesterInput, MaterialRequestUncheckedCreateWithoutRequesterInput> | MaterialRequestCreateWithoutRequesterInput[] | MaterialRequestUncheckedCreateWithoutRequesterInput[]
    connectOrCreate?: MaterialRequestCreateOrConnectWithoutRequesterInput | MaterialRequestCreateOrConnectWithoutRequesterInput[]
    upsert?: MaterialRequestUpsertWithWhereUniqueWithoutRequesterInput | MaterialRequestUpsertWithWhereUniqueWithoutRequesterInput[]
    createMany?: MaterialRequestCreateManyRequesterInputEnvelope
    set?: MaterialRequestWhereUniqueInput | MaterialRequestWhereUniqueInput[]
    disconnect?: MaterialRequestWhereUniqueInput | MaterialRequestWhereUniqueInput[]
    delete?: MaterialRequestWhereUniqueInput | MaterialRequestWhereUniqueInput[]
    connect?: MaterialRequestWhereUniqueInput | MaterialRequestWhereUniqueInput[]
    update?: MaterialRequestUpdateWithWhereUniqueWithoutRequesterInput | MaterialRequestUpdateWithWhereUniqueWithoutRequesterInput[]
    updateMany?: MaterialRequestUpdateManyWithWhereWithoutRequesterInput | MaterialRequestUpdateManyWithWhereWithoutRequesterInput[]
    deleteMany?: MaterialRequestScalarWhereInput | MaterialRequestScalarWhereInput[]
  }

  export type MaterialRequestUncheckedUpdateManyWithoutApproverNestedInput = {
    create?: XOR<MaterialRequestCreateWithoutApproverInput, MaterialRequestUncheckedCreateWithoutApproverInput> | MaterialRequestCreateWithoutApproverInput[] | MaterialRequestUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: MaterialRequestCreateOrConnectWithoutApproverInput | MaterialRequestCreateOrConnectWithoutApproverInput[]
    upsert?: MaterialRequestUpsertWithWhereUniqueWithoutApproverInput | MaterialRequestUpsertWithWhereUniqueWithoutApproverInput[]
    createMany?: MaterialRequestCreateManyApproverInputEnvelope
    set?: MaterialRequestWhereUniqueInput | MaterialRequestWhereUniqueInput[]
    disconnect?: MaterialRequestWhereUniqueInput | MaterialRequestWhereUniqueInput[]
    delete?: MaterialRequestWhereUniqueInput | MaterialRequestWhereUniqueInput[]
    connect?: MaterialRequestWhereUniqueInput | MaterialRequestWhereUniqueInput[]
    update?: MaterialRequestUpdateWithWhereUniqueWithoutApproverInput | MaterialRequestUpdateWithWhereUniqueWithoutApproverInput[]
    updateMany?: MaterialRequestUpdateManyWithWhereWithoutApproverInput | MaterialRequestUpdateManyWithWhereWithoutApproverInput[]
    deleteMany?: MaterialRequestScalarWhereInput | MaterialRequestScalarWhereInput[]
  }

  export type RFQUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<RFQCreateWithoutCreatedByInput, RFQUncheckedCreateWithoutCreatedByInput> | RFQCreateWithoutCreatedByInput[] | RFQUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: RFQCreateOrConnectWithoutCreatedByInput | RFQCreateOrConnectWithoutCreatedByInput[]
    upsert?: RFQUpsertWithWhereUniqueWithoutCreatedByInput | RFQUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: RFQCreateManyCreatedByInputEnvelope
    set?: RFQWhereUniqueInput | RFQWhereUniqueInput[]
    disconnect?: RFQWhereUniqueInput | RFQWhereUniqueInput[]
    delete?: RFQWhereUniqueInput | RFQWhereUniqueInput[]
    connect?: RFQWhereUniqueInput | RFQWhereUniqueInput[]
    update?: RFQUpdateWithWhereUniqueWithoutCreatedByInput | RFQUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: RFQUpdateManyWithWhereWithoutCreatedByInput | RFQUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: RFQScalarWhereInput | RFQScalarWhereInput[]
  }

  export type ReceivingReportUncheckedUpdateManyWithoutReceivedByNestedInput = {
    create?: XOR<ReceivingReportCreateWithoutReceivedByInput, ReceivingReportUncheckedCreateWithoutReceivedByInput> | ReceivingReportCreateWithoutReceivedByInput[] | ReceivingReportUncheckedCreateWithoutReceivedByInput[]
    connectOrCreate?: ReceivingReportCreateOrConnectWithoutReceivedByInput | ReceivingReportCreateOrConnectWithoutReceivedByInput[]
    upsert?: ReceivingReportUpsertWithWhereUniqueWithoutReceivedByInput | ReceivingReportUpsertWithWhereUniqueWithoutReceivedByInput[]
    createMany?: ReceivingReportCreateManyReceivedByInputEnvelope
    set?: ReceivingReportWhereUniqueInput | ReceivingReportWhereUniqueInput[]
    disconnect?: ReceivingReportWhereUniqueInput | ReceivingReportWhereUniqueInput[]
    delete?: ReceivingReportWhereUniqueInput | ReceivingReportWhereUniqueInput[]
    connect?: ReceivingReportWhereUniqueInput | ReceivingReportWhereUniqueInput[]
    update?: ReceivingReportUpdateWithWhereUniqueWithoutReceivedByInput | ReceivingReportUpdateWithWhereUniqueWithoutReceivedByInput[]
    updateMany?: ReceivingReportUpdateManyWithWhereWithoutReceivedByInput | ReceivingReportUpdateManyWithWhereWithoutReceivedByInput[]
    deleteMany?: ReceivingReportScalarWhereInput | ReceivingReportScalarWhereInput[]
  }

  export type DisbursementUncheckedUpdateManyWithoutProcessedByNestedInput = {
    create?: XOR<DisbursementCreateWithoutProcessedByInput, DisbursementUncheckedCreateWithoutProcessedByInput> | DisbursementCreateWithoutProcessedByInput[] | DisbursementUncheckedCreateWithoutProcessedByInput[]
    connectOrCreate?: DisbursementCreateOrConnectWithoutProcessedByInput | DisbursementCreateOrConnectWithoutProcessedByInput[]
    upsert?: DisbursementUpsertWithWhereUniqueWithoutProcessedByInput | DisbursementUpsertWithWhereUniqueWithoutProcessedByInput[]
    createMany?: DisbursementCreateManyProcessedByInputEnvelope
    set?: DisbursementWhereUniqueInput | DisbursementWhereUniqueInput[]
    disconnect?: DisbursementWhereUniqueInput | DisbursementWhereUniqueInput[]
    delete?: DisbursementWhereUniqueInput | DisbursementWhereUniqueInput[]
    connect?: DisbursementWhereUniqueInput | DisbursementWhereUniqueInput[]
    update?: DisbursementUpdateWithWhereUniqueWithoutProcessedByInput | DisbursementUpdateWithWhereUniqueWithoutProcessedByInput[]
    updateMany?: DisbursementUpdateManyWithWhereWithoutProcessedByInput | DisbursementUpdateManyWithWhereWithoutProcessedByInput[]
    deleteMany?: DisbursementScalarWhereInput | DisbursementScalarWhereInput[]
  }

  export type ProjectMemberUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProjectMemberCreateWithoutUserInput, ProjectMemberUncheckedCreateWithoutUserInput> | ProjectMemberCreateWithoutUserInput[] | ProjectMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectMemberCreateOrConnectWithoutUserInput | ProjectMemberCreateOrConnectWithoutUserInput[]
    upsert?: ProjectMemberUpsertWithWhereUniqueWithoutUserInput | ProjectMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProjectMemberCreateManyUserInputEnvelope
    set?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    disconnect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    delete?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    connect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    update?: ProjectMemberUpdateWithWhereUniqueWithoutUserInput | ProjectMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProjectMemberUpdateManyWithWhereWithoutUserInput | ProjectMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProjectMemberScalarWhereInput | ProjectMemberScalarWhereInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type ProjectCreateNestedManyWithoutClientInput = {
    create?: XOR<ProjectCreateWithoutClientInput, ProjectUncheckedCreateWithoutClientInput> | ProjectCreateWithoutClientInput[] | ProjectUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutClientInput | ProjectCreateOrConnectWithoutClientInput[]
    createMany?: ProjectCreateManyClientInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type ProjectUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<ProjectCreateWithoutClientInput, ProjectUncheckedCreateWithoutClientInput> | ProjectCreateWithoutClientInput[] | ProjectUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutClientInput | ProjectCreateOrConnectWithoutClientInput[]
    createMany?: ProjectCreateManyClientInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type ProjectUpdateManyWithoutClientNestedInput = {
    create?: XOR<ProjectCreateWithoutClientInput, ProjectUncheckedCreateWithoutClientInput> | ProjectCreateWithoutClientInput[] | ProjectUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutClientInput | ProjectCreateOrConnectWithoutClientInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutClientInput | ProjectUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ProjectCreateManyClientInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutClientInput | ProjectUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutClientInput | ProjectUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type ProjectUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<ProjectCreateWithoutClientInput, ProjectUncheckedCreateWithoutClientInput> | ProjectCreateWithoutClientInput[] | ProjectUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutClientInput | ProjectCreateOrConnectWithoutClientInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutClientInput | ProjectUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ProjectCreateManyClientInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutClientInput | ProjectUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutClientInput | ProjectUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type ClientCreateNestedOneWithoutProjectsInput = {
    create?: XOR<ClientCreateWithoutProjectsInput, ClientUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutProjectsInput
    connect?: ClientWhereUniqueInput
  }

  export type FinancialTransactionCreateNestedManyWithoutProjectInput = {
    create?: XOR<FinancialTransactionCreateWithoutProjectInput, FinancialTransactionUncheckedCreateWithoutProjectInput> | FinancialTransactionCreateWithoutProjectInput[] | FinancialTransactionUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: FinancialTransactionCreateOrConnectWithoutProjectInput | FinancialTransactionCreateOrConnectWithoutProjectInput[]
    createMany?: FinancialTransactionCreateManyProjectInputEnvelope
    connect?: FinancialTransactionWhereUniqueInput | FinancialTransactionWhereUniqueInput[]
  }

  export type InventoryItemCreateNestedManyWithoutProjectInput = {
    create?: XOR<InventoryItemCreateWithoutProjectInput, InventoryItemUncheckedCreateWithoutProjectInput> | InventoryItemCreateWithoutProjectInput[] | InventoryItemUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutProjectInput | InventoryItemCreateOrConnectWithoutProjectInput[]
    createMany?: InventoryItemCreateManyProjectInputEnvelope
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
  }

  export type ProjectMemberCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectMemberCreateWithoutProjectInput, ProjectMemberUncheckedCreateWithoutProjectInput> | ProjectMemberCreateWithoutProjectInput[] | ProjectMemberUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectMemberCreateOrConnectWithoutProjectInput | ProjectMemberCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectMemberCreateManyProjectInputEnvelope
    connect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
  }

  export type BoqItemCreateNestedManyWithoutProjectInput = {
    create?: XOR<BoqItemCreateWithoutProjectInput, BoqItemUncheckedCreateWithoutProjectInput> | BoqItemCreateWithoutProjectInput[] | BoqItemUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: BoqItemCreateOrConnectWithoutProjectInput | BoqItemCreateOrConnectWithoutProjectInput[]
    createMany?: BoqItemCreateManyProjectInputEnvelope
    connect?: BoqItemWhereUniqueInput | BoqItemWhereUniqueInput[]
  }

  export type PurchaseOrderCreateNestedManyWithoutProjectInput = {
    create?: XOR<PurchaseOrderCreateWithoutProjectInput, PurchaseOrderUncheckedCreateWithoutProjectInput> | PurchaseOrderCreateWithoutProjectInput[] | PurchaseOrderUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutProjectInput | PurchaseOrderCreateOrConnectWithoutProjectInput[]
    createMany?: PurchaseOrderCreateManyProjectInputEnvelope
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
  }

  export type MaterialRequestCreateNestedManyWithoutProjectInput = {
    create?: XOR<MaterialRequestCreateWithoutProjectInput, MaterialRequestUncheckedCreateWithoutProjectInput> | MaterialRequestCreateWithoutProjectInput[] | MaterialRequestUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: MaterialRequestCreateOrConnectWithoutProjectInput | MaterialRequestCreateOrConnectWithoutProjectInput[]
    createMany?: MaterialRequestCreateManyProjectInputEnvelope
    connect?: MaterialRequestWhereUniqueInput | MaterialRequestWhereUniqueInput[]
  }

  export type FinancialTransactionUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<FinancialTransactionCreateWithoutProjectInput, FinancialTransactionUncheckedCreateWithoutProjectInput> | FinancialTransactionCreateWithoutProjectInput[] | FinancialTransactionUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: FinancialTransactionCreateOrConnectWithoutProjectInput | FinancialTransactionCreateOrConnectWithoutProjectInput[]
    createMany?: FinancialTransactionCreateManyProjectInputEnvelope
    connect?: FinancialTransactionWhereUniqueInput | FinancialTransactionWhereUniqueInput[]
  }

  export type InventoryItemUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<InventoryItemCreateWithoutProjectInput, InventoryItemUncheckedCreateWithoutProjectInput> | InventoryItemCreateWithoutProjectInput[] | InventoryItemUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutProjectInput | InventoryItemCreateOrConnectWithoutProjectInput[]
    createMany?: InventoryItemCreateManyProjectInputEnvelope
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
  }

  export type ProjectMemberUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectMemberCreateWithoutProjectInput, ProjectMemberUncheckedCreateWithoutProjectInput> | ProjectMemberCreateWithoutProjectInput[] | ProjectMemberUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectMemberCreateOrConnectWithoutProjectInput | ProjectMemberCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectMemberCreateManyProjectInputEnvelope
    connect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
  }

  export type BoqItemUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<BoqItemCreateWithoutProjectInput, BoqItemUncheckedCreateWithoutProjectInput> | BoqItemCreateWithoutProjectInput[] | BoqItemUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: BoqItemCreateOrConnectWithoutProjectInput | BoqItemCreateOrConnectWithoutProjectInput[]
    createMany?: BoqItemCreateManyProjectInputEnvelope
    connect?: BoqItemWhereUniqueInput | BoqItemWhereUniqueInput[]
  }

  export type PurchaseOrderUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<PurchaseOrderCreateWithoutProjectInput, PurchaseOrderUncheckedCreateWithoutProjectInput> | PurchaseOrderCreateWithoutProjectInput[] | PurchaseOrderUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutProjectInput | PurchaseOrderCreateOrConnectWithoutProjectInput[]
    createMany?: PurchaseOrderCreateManyProjectInputEnvelope
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
  }

  export type MaterialRequestUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<MaterialRequestCreateWithoutProjectInput, MaterialRequestUncheckedCreateWithoutProjectInput> | MaterialRequestCreateWithoutProjectInput[] | MaterialRequestUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: MaterialRequestCreateOrConnectWithoutProjectInput | MaterialRequestCreateOrConnectWithoutProjectInput[]
    createMany?: MaterialRequestCreateManyProjectInputEnvelope
    connect?: MaterialRequestWhereUniqueInput | MaterialRequestWhereUniqueInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type ClientUpdateOneWithoutProjectsNestedInput = {
    create?: XOR<ClientCreateWithoutProjectsInput, ClientUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutProjectsInput
    upsert?: ClientUpsertWithoutProjectsInput
    disconnect?: ClientWhereInput | boolean
    delete?: ClientWhereInput | boolean
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutProjectsInput, ClientUpdateWithoutProjectsInput>, ClientUncheckedUpdateWithoutProjectsInput>
  }

  export type FinancialTransactionUpdateManyWithoutProjectNestedInput = {
    create?: XOR<FinancialTransactionCreateWithoutProjectInput, FinancialTransactionUncheckedCreateWithoutProjectInput> | FinancialTransactionCreateWithoutProjectInput[] | FinancialTransactionUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: FinancialTransactionCreateOrConnectWithoutProjectInput | FinancialTransactionCreateOrConnectWithoutProjectInput[]
    upsert?: FinancialTransactionUpsertWithWhereUniqueWithoutProjectInput | FinancialTransactionUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: FinancialTransactionCreateManyProjectInputEnvelope
    set?: FinancialTransactionWhereUniqueInput | FinancialTransactionWhereUniqueInput[]
    disconnect?: FinancialTransactionWhereUniqueInput | FinancialTransactionWhereUniqueInput[]
    delete?: FinancialTransactionWhereUniqueInput | FinancialTransactionWhereUniqueInput[]
    connect?: FinancialTransactionWhereUniqueInput | FinancialTransactionWhereUniqueInput[]
    update?: FinancialTransactionUpdateWithWhereUniqueWithoutProjectInput | FinancialTransactionUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: FinancialTransactionUpdateManyWithWhereWithoutProjectInput | FinancialTransactionUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: FinancialTransactionScalarWhereInput | FinancialTransactionScalarWhereInput[]
  }

  export type InventoryItemUpdateManyWithoutProjectNestedInput = {
    create?: XOR<InventoryItemCreateWithoutProjectInput, InventoryItemUncheckedCreateWithoutProjectInput> | InventoryItemCreateWithoutProjectInput[] | InventoryItemUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutProjectInput | InventoryItemCreateOrConnectWithoutProjectInput[]
    upsert?: InventoryItemUpsertWithWhereUniqueWithoutProjectInput | InventoryItemUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: InventoryItemCreateManyProjectInputEnvelope
    set?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    disconnect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    delete?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    update?: InventoryItemUpdateWithWhereUniqueWithoutProjectInput | InventoryItemUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: InventoryItemUpdateManyWithWhereWithoutProjectInput | InventoryItemUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: InventoryItemScalarWhereInput | InventoryItemScalarWhereInput[]
  }

  export type ProjectMemberUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectMemberCreateWithoutProjectInput, ProjectMemberUncheckedCreateWithoutProjectInput> | ProjectMemberCreateWithoutProjectInput[] | ProjectMemberUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectMemberCreateOrConnectWithoutProjectInput | ProjectMemberCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectMemberUpsertWithWhereUniqueWithoutProjectInput | ProjectMemberUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectMemberCreateManyProjectInputEnvelope
    set?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    disconnect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    delete?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    connect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    update?: ProjectMemberUpdateWithWhereUniqueWithoutProjectInput | ProjectMemberUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectMemberUpdateManyWithWhereWithoutProjectInput | ProjectMemberUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectMemberScalarWhereInput | ProjectMemberScalarWhereInput[]
  }

  export type BoqItemUpdateManyWithoutProjectNestedInput = {
    create?: XOR<BoqItemCreateWithoutProjectInput, BoqItemUncheckedCreateWithoutProjectInput> | BoqItemCreateWithoutProjectInput[] | BoqItemUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: BoqItemCreateOrConnectWithoutProjectInput | BoqItemCreateOrConnectWithoutProjectInput[]
    upsert?: BoqItemUpsertWithWhereUniqueWithoutProjectInput | BoqItemUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: BoqItemCreateManyProjectInputEnvelope
    set?: BoqItemWhereUniqueInput | BoqItemWhereUniqueInput[]
    disconnect?: BoqItemWhereUniqueInput | BoqItemWhereUniqueInput[]
    delete?: BoqItemWhereUniqueInput | BoqItemWhereUniqueInput[]
    connect?: BoqItemWhereUniqueInput | BoqItemWhereUniqueInput[]
    update?: BoqItemUpdateWithWhereUniqueWithoutProjectInput | BoqItemUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: BoqItemUpdateManyWithWhereWithoutProjectInput | BoqItemUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: BoqItemScalarWhereInput | BoqItemScalarWhereInput[]
  }

  export type PurchaseOrderUpdateManyWithoutProjectNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutProjectInput, PurchaseOrderUncheckedCreateWithoutProjectInput> | PurchaseOrderCreateWithoutProjectInput[] | PurchaseOrderUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutProjectInput | PurchaseOrderCreateOrConnectWithoutProjectInput[]
    upsert?: PurchaseOrderUpsertWithWhereUniqueWithoutProjectInput | PurchaseOrderUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: PurchaseOrderCreateManyProjectInputEnvelope
    set?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    disconnect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    delete?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    update?: PurchaseOrderUpdateWithWhereUniqueWithoutProjectInput | PurchaseOrderUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: PurchaseOrderUpdateManyWithWhereWithoutProjectInput | PurchaseOrderUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
  }

  export type MaterialRequestUpdateManyWithoutProjectNestedInput = {
    create?: XOR<MaterialRequestCreateWithoutProjectInput, MaterialRequestUncheckedCreateWithoutProjectInput> | MaterialRequestCreateWithoutProjectInput[] | MaterialRequestUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: MaterialRequestCreateOrConnectWithoutProjectInput | MaterialRequestCreateOrConnectWithoutProjectInput[]
    upsert?: MaterialRequestUpsertWithWhereUniqueWithoutProjectInput | MaterialRequestUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: MaterialRequestCreateManyProjectInputEnvelope
    set?: MaterialRequestWhereUniqueInput | MaterialRequestWhereUniqueInput[]
    disconnect?: MaterialRequestWhereUniqueInput | MaterialRequestWhereUniqueInput[]
    delete?: MaterialRequestWhereUniqueInput | MaterialRequestWhereUniqueInput[]
    connect?: MaterialRequestWhereUniqueInput | MaterialRequestWhereUniqueInput[]
    update?: MaterialRequestUpdateWithWhereUniqueWithoutProjectInput | MaterialRequestUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: MaterialRequestUpdateManyWithWhereWithoutProjectInput | MaterialRequestUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: MaterialRequestScalarWhereInput | MaterialRequestScalarWhereInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type FinancialTransactionUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<FinancialTransactionCreateWithoutProjectInput, FinancialTransactionUncheckedCreateWithoutProjectInput> | FinancialTransactionCreateWithoutProjectInput[] | FinancialTransactionUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: FinancialTransactionCreateOrConnectWithoutProjectInput | FinancialTransactionCreateOrConnectWithoutProjectInput[]
    upsert?: FinancialTransactionUpsertWithWhereUniqueWithoutProjectInput | FinancialTransactionUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: FinancialTransactionCreateManyProjectInputEnvelope
    set?: FinancialTransactionWhereUniqueInput | FinancialTransactionWhereUniqueInput[]
    disconnect?: FinancialTransactionWhereUniqueInput | FinancialTransactionWhereUniqueInput[]
    delete?: FinancialTransactionWhereUniqueInput | FinancialTransactionWhereUniqueInput[]
    connect?: FinancialTransactionWhereUniqueInput | FinancialTransactionWhereUniqueInput[]
    update?: FinancialTransactionUpdateWithWhereUniqueWithoutProjectInput | FinancialTransactionUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: FinancialTransactionUpdateManyWithWhereWithoutProjectInput | FinancialTransactionUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: FinancialTransactionScalarWhereInput | FinancialTransactionScalarWhereInput[]
  }

  export type InventoryItemUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<InventoryItemCreateWithoutProjectInput, InventoryItemUncheckedCreateWithoutProjectInput> | InventoryItemCreateWithoutProjectInput[] | InventoryItemUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutProjectInput | InventoryItemCreateOrConnectWithoutProjectInput[]
    upsert?: InventoryItemUpsertWithWhereUniqueWithoutProjectInput | InventoryItemUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: InventoryItemCreateManyProjectInputEnvelope
    set?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    disconnect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    delete?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    update?: InventoryItemUpdateWithWhereUniqueWithoutProjectInput | InventoryItemUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: InventoryItemUpdateManyWithWhereWithoutProjectInput | InventoryItemUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: InventoryItemScalarWhereInput | InventoryItemScalarWhereInput[]
  }

  export type ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectMemberCreateWithoutProjectInput, ProjectMemberUncheckedCreateWithoutProjectInput> | ProjectMemberCreateWithoutProjectInput[] | ProjectMemberUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectMemberCreateOrConnectWithoutProjectInput | ProjectMemberCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectMemberUpsertWithWhereUniqueWithoutProjectInput | ProjectMemberUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectMemberCreateManyProjectInputEnvelope
    set?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    disconnect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    delete?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    connect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    update?: ProjectMemberUpdateWithWhereUniqueWithoutProjectInput | ProjectMemberUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectMemberUpdateManyWithWhereWithoutProjectInput | ProjectMemberUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectMemberScalarWhereInput | ProjectMemberScalarWhereInput[]
  }

  export type BoqItemUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<BoqItemCreateWithoutProjectInput, BoqItemUncheckedCreateWithoutProjectInput> | BoqItemCreateWithoutProjectInput[] | BoqItemUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: BoqItemCreateOrConnectWithoutProjectInput | BoqItemCreateOrConnectWithoutProjectInput[]
    upsert?: BoqItemUpsertWithWhereUniqueWithoutProjectInput | BoqItemUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: BoqItemCreateManyProjectInputEnvelope
    set?: BoqItemWhereUniqueInput | BoqItemWhereUniqueInput[]
    disconnect?: BoqItemWhereUniqueInput | BoqItemWhereUniqueInput[]
    delete?: BoqItemWhereUniqueInput | BoqItemWhereUniqueInput[]
    connect?: BoqItemWhereUniqueInput | BoqItemWhereUniqueInput[]
    update?: BoqItemUpdateWithWhereUniqueWithoutProjectInput | BoqItemUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: BoqItemUpdateManyWithWhereWithoutProjectInput | BoqItemUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: BoqItemScalarWhereInput | BoqItemScalarWhereInput[]
  }

  export type PurchaseOrderUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutProjectInput, PurchaseOrderUncheckedCreateWithoutProjectInput> | PurchaseOrderCreateWithoutProjectInput[] | PurchaseOrderUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutProjectInput | PurchaseOrderCreateOrConnectWithoutProjectInput[]
    upsert?: PurchaseOrderUpsertWithWhereUniqueWithoutProjectInput | PurchaseOrderUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: PurchaseOrderCreateManyProjectInputEnvelope
    set?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    disconnect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    delete?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    update?: PurchaseOrderUpdateWithWhereUniqueWithoutProjectInput | PurchaseOrderUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: PurchaseOrderUpdateManyWithWhereWithoutProjectInput | PurchaseOrderUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
  }

  export type MaterialRequestUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<MaterialRequestCreateWithoutProjectInput, MaterialRequestUncheckedCreateWithoutProjectInput> | MaterialRequestCreateWithoutProjectInput[] | MaterialRequestUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: MaterialRequestCreateOrConnectWithoutProjectInput | MaterialRequestCreateOrConnectWithoutProjectInput[]
    upsert?: MaterialRequestUpsertWithWhereUniqueWithoutProjectInput | MaterialRequestUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: MaterialRequestCreateManyProjectInputEnvelope
    set?: MaterialRequestWhereUniqueInput | MaterialRequestWhereUniqueInput[]
    disconnect?: MaterialRequestWhereUniqueInput | MaterialRequestWhereUniqueInput[]
    delete?: MaterialRequestWhereUniqueInput | MaterialRequestWhereUniqueInput[]
    connect?: MaterialRequestWhereUniqueInput | MaterialRequestWhereUniqueInput[]
    update?: MaterialRequestUpdateWithWhereUniqueWithoutProjectInput | MaterialRequestUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: MaterialRequestUpdateManyWithWhereWithoutProjectInput | MaterialRequestUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: MaterialRequestScalarWhereInput | MaterialRequestScalarWhereInput[]
  }

  export type ProjectCreateNestedOneWithoutTeamMembersInput = {
    create?: XOR<ProjectCreateWithoutTeamMembersInput, ProjectUncheckedCreateWithoutTeamMembersInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutTeamMembersInput
    connect?: ProjectWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutProjectMembersInput = {
    create?: XOR<UserCreateWithoutProjectMembersInput, UserUncheckedCreateWithoutProjectMembersInput>
    connectOrCreate?: UserCreateOrConnectWithoutProjectMembersInput
    connect?: UserWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutTeamMembersNestedInput = {
    create?: XOR<ProjectCreateWithoutTeamMembersInput, ProjectUncheckedCreateWithoutTeamMembersInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutTeamMembersInput
    upsert?: ProjectUpsertWithoutTeamMembersInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutTeamMembersInput, ProjectUpdateWithoutTeamMembersInput>, ProjectUncheckedUpdateWithoutTeamMembersInput>
  }

  export type UserUpdateOneRequiredWithoutProjectMembersNestedInput = {
    create?: XOR<UserCreateWithoutProjectMembersInput, UserUncheckedCreateWithoutProjectMembersInput>
    connectOrCreate?: UserCreateOrConnectWithoutProjectMembersInput
    upsert?: UserUpsertWithoutProjectMembersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProjectMembersInput, UserUpdateWithoutProjectMembersInput>, UserUncheckedUpdateWithoutProjectMembersInput>
  }

  export type ProjectCreateNestedOneWithoutBoqItemsInput = {
    create?: XOR<ProjectCreateWithoutBoqItemsInput, ProjectUncheckedCreateWithoutBoqItemsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutBoqItemsInput
    connect?: ProjectWhereUniqueInput
  }

  export type BoqItemComponentCreateNestedManyWithoutBoqItemInput = {
    create?: XOR<BoqItemComponentCreateWithoutBoqItemInput, BoqItemComponentUncheckedCreateWithoutBoqItemInput> | BoqItemComponentCreateWithoutBoqItemInput[] | BoqItemComponentUncheckedCreateWithoutBoqItemInput[]
    connectOrCreate?: BoqItemComponentCreateOrConnectWithoutBoqItemInput | BoqItemComponentCreateOrConnectWithoutBoqItemInput[]
    createMany?: BoqItemComponentCreateManyBoqItemInputEnvelope
    connect?: BoqItemComponentWhereUniqueInput | BoqItemComponentWhereUniqueInput[]
  }

  export type BoqItemComponentUncheckedCreateNestedManyWithoutBoqItemInput = {
    create?: XOR<BoqItemComponentCreateWithoutBoqItemInput, BoqItemComponentUncheckedCreateWithoutBoqItemInput> | BoqItemComponentCreateWithoutBoqItemInput[] | BoqItemComponentUncheckedCreateWithoutBoqItemInput[]
    connectOrCreate?: BoqItemComponentCreateOrConnectWithoutBoqItemInput | BoqItemComponentCreateOrConnectWithoutBoqItemInput[]
    createMany?: BoqItemComponentCreateManyBoqItemInputEnvelope
    connect?: BoqItemComponentWhereUniqueInput | BoqItemComponentWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type ProjectUpdateOneRequiredWithoutBoqItemsNestedInput = {
    create?: XOR<ProjectCreateWithoutBoqItemsInput, ProjectUncheckedCreateWithoutBoqItemsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutBoqItemsInput
    upsert?: ProjectUpsertWithoutBoqItemsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutBoqItemsInput, ProjectUpdateWithoutBoqItemsInput>, ProjectUncheckedUpdateWithoutBoqItemsInput>
  }

  export type BoqItemComponentUpdateManyWithoutBoqItemNestedInput = {
    create?: XOR<BoqItemComponentCreateWithoutBoqItemInput, BoqItemComponentUncheckedCreateWithoutBoqItemInput> | BoqItemComponentCreateWithoutBoqItemInput[] | BoqItemComponentUncheckedCreateWithoutBoqItemInput[]
    connectOrCreate?: BoqItemComponentCreateOrConnectWithoutBoqItemInput | BoqItemComponentCreateOrConnectWithoutBoqItemInput[]
    upsert?: BoqItemComponentUpsertWithWhereUniqueWithoutBoqItemInput | BoqItemComponentUpsertWithWhereUniqueWithoutBoqItemInput[]
    createMany?: BoqItemComponentCreateManyBoqItemInputEnvelope
    set?: BoqItemComponentWhereUniqueInput | BoqItemComponentWhereUniqueInput[]
    disconnect?: BoqItemComponentWhereUniqueInput | BoqItemComponentWhereUniqueInput[]
    delete?: BoqItemComponentWhereUniqueInput | BoqItemComponentWhereUniqueInput[]
    connect?: BoqItemComponentWhereUniqueInput | BoqItemComponentWhereUniqueInput[]
    update?: BoqItemComponentUpdateWithWhereUniqueWithoutBoqItemInput | BoqItemComponentUpdateWithWhereUniqueWithoutBoqItemInput[]
    updateMany?: BoqItemComponentUpdateManyWithWhereWithoutBoqItemInput | BoqItemComponentUpdateManyWithWhereWithoutBoqItemInput[]
    deleteMany?: BoqItemComponentScalarWhereInput | BoqItemComponentScalarWhereInput[]
  }

  export type BoqItemComponentUncheckedUpdateManyWithoutBoqItemNestedInput = {
    create?: XOR<BoqItemComponentCreateWithoutBoqItemInput, BoqItemComponentUncheckedCreateWithoutBoqItemInput> | BoqItemComponentCreateWithoutBoqItemInput[] | BoqItemComponentUncheckedCreateWithoutBoqItemInput[]
    connectOrCreate?: BoqItemComponentCreateOrConnectWithoutBoqItemInput | BoqItemComponentCreateOrConnectWithoutBoqItemInput[]
    upsert?: BoqItemComponentUpsertWithWhereUniqueWithoutBoqItemInput | BoqItemComponentUpsertWithWhereUniqueWithoutBoqItemInput[]
    createMany?: BoqItemComponentCreateManyBoqItemInputEnvelope
    set?: BoqItemComponentWhereUniqueInput | BoqItemComponentWhereUniqueInput[]
    disconnect?: BoqItemComponentWhereUniqueInput | BoqItemComponentWhereUniqueInput[]
    delete?: BoqItemComponentWhereUniqueInput | BoqItemComponentWhereUniqueInput[]
    connect?: BoqItemComponentWhereUniqueInput | BoqItemComponentWhereUniqueInput[]
    update?: BoqItemComponentUpdateWithWhereUniqueWithoutBoqItemInput | BoqItemComponentUpdateWithWhereUniqueWithoutBoqItemInput[]
    updateMany?: BoqItemComponentUpdateManyWithWhereWithoutBoqItemInput | BoqItemComponentUpdateManyWithWhereWithoutBoqItemInput[]
    deleteMany?: BoqItemComponentScalarWhereInput | BoqItemComponentScalarWhereInput[]
  }

  export type BoqItemCreateNestedOneWithoutBoqComponentsInput = {
    create?: XOR<BoqItemCreateWithoutBoqComponentsInput, BoqItemUncheckedCreateWithoutBoqComponentsInput>
    connectOrCreate?: BoqItemCreateOrConnectWithoutBoqComponentsInput
    connect?: BoqItemWhereUniqueInput
  }

  export type EnumResourceTypeFieldUpdateOperationsInput = {
    set?: $Enums.ResourceType
  }

  export type BoqItemUpdateOneRequiredWithoutBoqComponentsNestedInput = {
    create?: XOR<BoqItemCreateWithoutBoqComponentsInput, BoqItemUncheckedCreateWithoutBoqComponentsInput>
    connectOrCreate?: BoqItemCreateOrConnectWithoutBoqComponentsInput
    upsert?: BoqItemUpsertWithoutBoqComponentsInput
    connect?: BoqItemWhereUniqueInput
    update?: XOR<XOR<BoqItemUpdateToOneWithWhereWithoutBoqComponentsInput, BoqItemUpdateWithoutBoqComponentsInput>, BoqItemUncheckedUpdateWithoutBoqComponentsInput>
  }

  export type ProjectCreateNestedOneWithoutMaterialRequestsInput = {
    create?: XOR<ProjectCreateWithoutMaterialRequestsInput, ProjectUncheckedCreateWithoutMaterialRequestsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutMaterialRequestsInput
    connect?: ProjectWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMaterialRequestsInput = {
    create?: XOR<UserCreateWithoutMaterialRequestsInput, UserUncheckedCreateWithoutMaterialRequestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMaterialRequestsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMrApprovalsInput = {
    create?: XOR<UserCreateWithoutMrApprovalsInput, UserUncheckedCreateWithoutMrApprovalsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMrApprovalsInput
    connect?: UserWhereUniqueInput
  }

  export type MaterialRequestItemCreateNestedManyWithoutMaterialRequestInput = {
    create?: XOR<MaterialRequestItemCreateWithoutMaterialRequestInput, MaterialRequestItemUncheckedCreateWithoutMaterialRequestInput> | MaterialRequestItemCreateWithoutMaterialRequestInput[] | MaterialRequestItemUncheckedCreateWithoutMaterialRequestInput[]
    connectOrCreate?: MaterialRequestItemCreateOrConnectWithoutMaterialRequestInput | MaterialRequestItemCreateOrConnectWithoutMaterialRequestInput[]
    createMany?: MaterialRequestItemCreateManyMaterialRequestInputEnvelope
    connect?: MaterialRequestItemWhereUniqueInput | MaterialRequestItemWhereUniqueInput[]
  }

  export type RFQCreateNestedManyWithoutMaterialRequestInput = {
    create?: XOR<RFQCreateWithoutMaterialRequestInput, RFQUncheckedCreateWithoutMaterialRequestInput> | RFQCreateWithoutMaterialRequestInput[] | RFQUncheckedCreateWithoutMaterialRequestInput[]
    connectOrCreate?: RFQCreateOrConnectWithoutMaterialRequestInput | RFQCreateOrConnectWithoutMaterialRequestInput[]
    createMany?: RFQCreateManyMaterialRequestInputEnvelope
    connect?: RFQWhereUniqueInput | RFQWhereUniqueInput[]
  }

  export type MaterialRequestItemUncheckedCreateNestedManyWithoutMaterialRequestInput = {
    create?: XOR<MaterialRequestItemCreateWithoutMaterialRequestInput, MaterialRequestItemUncheckedCreateWithoutMaterialRequestInput> | MaterialRequestItemCreateWithoutMaterialRequestInput[] | MaterialRequestItemUncheckedCreateWithoutMaterialRequestInput[]
    connectOrCreate?: MaterialRequestItemCreateOrConnectWithoutMaterialRequestInput | MaterialRequestItemCreateOrConnectWithoutMaterialRequestInput[]
    createMany?: MaterialRequestItemCreateManyMaterialRequestInputEnvelope
    connect?: MaterialRequestItemWhereUniqueInput | MaterialRequestItemWhereUniqueInput[]
  }

  export type RFQUncheckedCreateNestedManyWithoutMaterialRequestInput = {
    create?: XOR<RFQCreateWithoutMaterialRequestInput, RFQUncheckedCreateWithoutMaterialRequestInput> | RFQCreateWithoutMaterialRequestInput[] | RFQUncheckedCreateWithoutMaterialRequestInput[]
    connectOrCreate?: RFQCreateOrConnectWithoutMaterialRequestInput | RFQCreateOrConnectWithoutMaterialRequestInput[]
    createMany?: RFQCreateManyMaterialRequestInputEnvelope
    connect?: RFQWhereUniqueInput | RFQWhereUniqueInput[]
  }

  export type EnumMrStatusFieldUpdateOperationsInput = {
    set?: $Enums.MrStatus
  }

  export type ProjectUpdateOneRequiredWithoutMaterialRequestsNestedInput = {
    create?: XOR<ProjectCreateWithoutMaterialRequestsInput, ProjectUncheckedCreateWithoutMaterialRequestsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutMaterialRequestsInput
    upsert?: ProjectUpsertWithoutMaterialRequestsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutMaterialRequestsInput, ProjectUpdateWithoutMaterialRequestsInput>, ProjectUncheckedUpdateWithoutMaterialRequestsInput>
  }

  export type UserUpdateOneRequiredWithoutMaterialRequestsNestedInput = {
    create?: XOR<UserCreateWithoutMaterialRequestsInput, UserUncheckedCreateWithoutMaterialRequestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMaterialRequestsInput
    upsert?: UserUpsertWithoutMaterialRequestsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMaterialRequestsInput, UserUpdateWithoutMaterialRequestsInput>, UserUncheckedUpdateWithoutMaterialRequestsInput>
  }

  export type UserUpdateOneWithoutMrApprovalsNestedInput = {
    create?: XOR<UserCreateWithoutMrApprovalsInput, UserUncheckedCreateWithoutMrApprovalsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMrApprovalsInput
    upsert?: UserUpsertWithoutMrApprovalsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMrApprovalsInput, UserUpdateWithoutMrApprovalsInput>, UserUncheckedUpdateWithoutMrApprovalsInput>
  }

  export type MaterialRequestItemUpdateManyWithoutMaterialRequestNestedInput = {
    create?: XOR<MaterialRequestItemCreateWithoutMaterialRequestInput, MaterialRequestItemUncheckedCreateWithoutMaterialRequestInput> | MaterialRequestItemCreateWithoutMaterialRequestInput[] | MaterialRequestItemUncheckedCreateWithoutMaterialRequestInput[]
    connectOrCreate?: MaterialRequestItemCreateOrConnectWithoutMaterialRequestInput | MaterialRequestItemCreateOrConnectWithoutMaterialRequestInput[]
    upsert?: MaterialRequestItemUpsertWithWhereUniqueWithoutMaterialRequestInput | MaterialRequestItemUpsertWithWhereUniqueWithoutMaterialRequestInput[]
    createMany?: MaterialRequestItemCreateManyMaterialRequestInputEnvelope
    set?: MaterialRequestItemWhereUniqueInput | MaterialRequestItemWhereUniqueInput[]
    disconnect?: MaterialRequestItemWhereUniqueInput | MaterialRequestItemWhereUniqueInput[]
    delete?: MaterialRequestItemWhereUniqueInput | MaterialRequestItemWhereUniqueInput[]
    connect?: MaterialRequestItemWhereUniqueInput | MaterialRequestItemWhereUniqueInput[]
    update?: MaterialRequestItemUpdateWithWhereUniqueWithoutMaterialRequestInput | MaterialRequestItemUpdateWithWhereUniqueWithoutMaterialRequestInput[]
    updateMany?: MaterialRequestItemUpdateManyWithWhereWithoutMaterialRequestInput | MaterialRequestItemUpdateManyWithWhereWithoutMaterialRequestInput[]
    deleteMany?: MaterialRequestItemScalarWhereInput | MaterialRequestItemScalarWhereInput[]
  }

  export type RFQUpdateManyWithoutMaterialRequestNestedInput = {
    create?: XOR<RFQCreateWithoutMaterialRequestInput, RFQUncheckedCreateWithoutMaterialRequestInput> | RFQCreateWithoutMaterialRequestInput[] | RFQUncheckedCreateWithoutMaterialRequestInput[]
    connectOrCreate?: RFQCreateOrConnectWithoutMaterialRequestInput | RFQCreateOrConnectWithoutMaterialRequestInput[]
    upsert?: RFQUpsertWithWhereUniqueWithoutMaterialRequestInput | RFQUpsertWithWhereUniqueWithoutMaterialRequestInput[]
    createMany?: RFQCreateManyMaterialRequestInputEnvelope
    set?: RFQWhereUniqueInput | RFQWhereUniqueInput[]
    disconnect?: RFQWhereUniqueInput | RFQWhereUniqueInput[]
    delete?: RFQWhereUniqueInput | RFQWhereUniqueInput[]
    connect?: RFQWhereUniqueInput | RFQWhereUniqueInput[]
    update?: RFQUpdateWithWhereUniqueWithoutMaterialRequestInput | RFQUpdateWithWhereUniqueWithoutMaterialRequestInput[]
    updateMany?: RFQUpdateManyWithWhereWithoutMaterialRequestInput | RFQUpdateManyWithWhereWithoutMaterialRequestInput[]
    deleteMany?: RFQScalarWhereInput | RFQScalarWhereInput[]
  }

  export type MaterialRequestItemUncheckedUpdateManyWithoutMaterialRequestNestedInput = {
    create?: XOR<MaterialRequestItemCreateWithoutMaterialRequestInput, MaterialRequestItemUncheckedCreateWithoutMaterialRequestInput> | MaterialRequestItemCreateWithoutMaterialRequestInput[] | MaterialRequestItemUncheckedCreateWithoutMaterialRequestInput[]
    connectOrCreate?: MaterialRequestItemCreateOrConnectWithoutMaterialRequestInput | MaterialRequestItemCreateOrConnectWithoutMaterialRequestInput[]
    upsert?: MaterialRequestItemUpsertWithWhereUniqueWithoutMaterialRequestInput | MaterialRequestItemUpsertWithWhereUniqueWithoutMaterialRequestInput[]
    createMany?: MaterialRequestItemCreateManyMaterialRequestInputEnvelope
    set?: MaterialRequestItemWhereUniqueInput | MaterialRequestItemWhereUniqueInput[]
    disconnect?: MaterialRequestItemWhereUniqueInput | MaterialRequestItemWhereUniqueInput[]
    delete?: MaterialRequestItemWhereUniqueInput | MaterialRequestItemWhereUniqueInput[]
    connect?: MaterialRequestItemWhereUniqueInput | MaterialRequestItemWhereUniqueInput[]
    update?: MaterialRequestItemUpdateWithWhereUniqueWithoutMaterialRequestInput | MaterialRequestItemUpdateWithWhereUniqueWithoutMaterialRequestInput[]
    updateMany?: MaterialRequestItemUpdateManyWithWhereWithoutMaterialRequestInput | MaterialRequestItemUpdateManyWithWhereWithoutMaterialRequestInput[]
    deleteMany?: MaterialRequestItemScalarWhereInput | MaterialRequestItemScalarWhereInput[]
  }

  export type RFQUncheckedUpdateManyWithoutMaterialRequestNestedInput = {
    create?: XOR<RFQCreateWithoutMaterialRequestInput, RFQUncheckedCreateWithoutMaterialRequestInput> | RFQCreateWithoutMaterialRequestInput[] | RFQUncheckedCreateWithoutMaterialRequestInput[]
    connectOrCreate?: RFQCreateOrConnectWithoutMaterialRequestInput | RFQCreateOrConnectWithoutMaterialRequestInput[]
    upsert?: RFQUpsertWithWhereUniqueWithoutMaterialRequestInput | RFQUpsertWithWhereUniqueWithoutMaterialRequestInput[]
    createMany?: RFQCreateManyMaterialRequestInputEnvelope
    set?: RFQWhereUniqueInput | RFQWhereUniqueInput[]
    disconnect?: RFQWhereUniqueInput | RFQWhereUniqueInput[]
    delete?: RFQWhereUniqueInput | RFQWhereUniqueInput[]
    connect?: RFQWhereUniqueInput | RFQWhereUniqueInput[]
    update?: RFQUpdateWithWhereUniqueWithoutMaterialRequestInput | RFQUpdateWithWhereUniqueWithoutMaterialRequestInput[]
    updateMany?: RFQUpdateManyWithWhereWithoutMaterialRequestInput | RFQUpdateManyWithWhereWithoutMaterialRequestInput[]
    deleteMany?: RFQScalarWhereInput | RFQScalarWhereInput[]
  }

  export type MaterialRequestCreateNestedOneWithoutItemsInput = {
    create?: XOR<MaterialRequestCreateWithoutItemsInput, MaterialRequestUncheckedCreateWithoutItemsInput>
    connectOrCreate?: MaterialRequestCreateOrConnectWithoutItemsInput
    connect?: MaterialRequestWhereUniqueInput
  }

  export type MaterialRequestUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<MaterialRequestCreateWithoutItemsInput, MaterialRequestUncheckedCreateWithoutItemsInput>
    connectOrCreate?: MaterialRequestCreateOrConnectWithoutItemsInput
    upsert?: MaterialRequestUpsertWithoutItemsInput
    connect?: MaterialRequestWhereUniqueInput
    update?: XOR<XOR<MaterialRequestUpdateToOneWithWhereWithoutItemsInput, MaterialRequestUpdateWithoutItemsInput>, MaterialRequestUncheckedUpdateWithoutItemsInput>
  }

  export type MaterialRequestCreateNestedOneWithoutRfqsInput = {
    create?: XOR<MaterialRequestCreateWithoutRfqsInput, MaterialRequestUncheckedCreateWithoutRfqsInput>
    connectOrCreate?: MaterialRequestCreateOrConnectWithoutRfqsInput
    connect?: MaterialRequestWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutRfqsCreatedInput = {
    create?: XOR<UserCreateWithoutRfqsCreatedInput, UserUncheckedCreateWithoutRfqsCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutRfqsCreatedInput
    connect?: UserWhereUniqueInput
  }

  export type RFQItemCreateNestedManyWithoutRfqInput = {
    create?: XOR<RFQItemCreateWithoutRfqInput, RFQItemUncheckedCreateWithoutRfqInput> | RFQItemCreateWithoutRfqInput[] | RFQItemUncheckedCreateWithoutRfqInput[]
    connectOrCreate?: RFQItemCreateOrConnectWithoutRfqInput | RFQItemCreateOrConnectWithoutRfqInput[]
    createMany?: RFQItemCreateManyRfqInputEnvelope
    connect?: RFQItemWhereUniqueInput | RFQItemWhereUniqueInput[]
  }

  export type SupplierQuotationCreateNestedManyWithoutRfqInput = {
    create?: XOR<SupplierQuotationCreateWithoutRfqInput, SupplierQuotationUncheckedCreateWithoutRfqInput> | SupplierQuotationCreateWithoutRfqInput[] | SupplierQuotationUncheckedCreateWithoutRfqInput[]
    connectOrCreate?: SupplierQuotationCreateOrConnectWithoutRfqInput | SupplierQuotationCreateOrConnectWithoutRfqInput[]
    createMany?: SupplierQuotationCreateManyRfqInputEnvelope
    connect?: SupplierQuotationWhereUniqueInput | SupplierQuotationWhereUniqueInput[]
  }

  export type RFQItemUncheckedCreateNestedManyWithoutRfqInput = {
    create?: XOR<RFQItemCreateWithoutRfqInput, RFQItemUncheckedCreateWithoutRfqInput> | RFQItemCreateWithoutRfqInput[] | RFQItemUncheckedCreateWithoutRfqInput[]
    connectOrCreate?: RFQItemCreateOrConnectWithoutRfqInput | RFQItemCreateOrConnectWithoutRfqInput[]
    createMany?: RFQItemCreateManyRfqInputEnvelope
    connect?: RFQItemWhereUniqueInput | RFQItemWhereUniqueInput[]
  }

  export type SupplierQuotationUncheckedCreateNestedManyWithoutRfqInput = {
    create?: XOR<SupplierQuotationCreateWithoutRfqInput, SupplierQuotationUncheckedCreateWithoutRfqInput> | SupplierQuotationCreateWithoutRfqInput[] | SupplierQuotationUncheckedCreateWithoutRfqInput[]
    connectOrCreate?: SupplierQuotationCreateOrConnectWithoutRfqInput | SupplierQuotationCreateOrConnectWithoutRfqInput[]
    createMany?: SupplierQuotationCreateManyRfqInputEnvelope
    connect?: SupplierQuotationWhereUniqueInput | SupplierQuotationWhereUniqueInput[]
  }

  export type EnumRfqStatusFieldUpdateOperationsInput = {
    set?: $Enums.RfqStatus
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type MaterialRequestUpdateOneWithoutRfqsNestedInput = {
    create?: XOR<MaterialRequestCreateWithoutRfqsInput, MaterialRequestUncheckedCreateWithoutRfqsInput>
    connectOrCreate?: MaterialRequestCreateOrConnectWithoutRfqsInput
    upsert?: MaterialRequestUpsertWithoutRfqsInput
    disconnect?: MaterialRequestWhereInput | boolean
    delete?: MaterialRequestWhereInput | boolean
    connect?: MaterialRequestWhereUniqueInput
    update?: XOR<XOR<MaterialRequestUpdateToOneWithWhereWithoutRfqsInput, MaterialRequestUpdateWithoutRfqsInput>, MaterialRequestUncheckedUpdateWithoutRfqsInput>
  }

  export type UserUpdateOneRequiredWithoutRfqsCreatedNestedInput = {
    create?: XOR<UserCreateWithoutRfqsCreatedInput, UserUncheckedCreateWithoutRfqsCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutRfqsCreatedInput
    upsert?: UserUpsertWithoutRfqsCreatedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRfqsCreatedInput, UserUpdateWithoutRfqsCreatedInput>, UserUncheckedUpdateWithoutRfqsCreatedInput>
  }

  export type RFQItemUpdateManyWithoutRfqNestedInput = {
    create?: XOR<RFQItemCreateWithoutRfqInput, RFQItemUncheckedCreateWithoutRfqInput> | RFQItemCreateWithoutRfqInput[] | RFQItemUncheckedCreateWithoutRfqInput[]
    connectOrCreate?: RFQItemCreateOrConnectWithoutRfqInput | RFQItemCreateOrConnectWithoutRfqInput[]
    upsert?: RFQItemUpsertWithWhereUniqueWithoutRfqInput | RFQItemUpsertWithWhereUniqueWithoutRfqInput[]
    createMany?: RFQItemCreateManyRfqInputEnvelope
    set?: RFQItemWhereUniqueInput | RFQItemWhereUniqueInput[]
    disconnect?: RFQItemWhereUniqueInput | RFQItemWhereUniqueInput[]
    delete?: RFQItemWhereUniqueInput | RFQItemWhereUniqueInput[]
    connect?: RFQItemWhereUniqueInput | RFQItemWhereUniqueInput[]
    update?: RFQItemUpdateWithWhereUniqueWithoutRfqInput | RFQItemUpdateWithWhereUniqueWithoutRfqInput[]
    updateMany?: RFQItemUpdateManyWithWhereWithoutRfqInput | RFQItemUpdateManyWithWhereWithoutRfqInput[]
    deleteMany?: RFQItemScalarWhereInput | RFQItemScalarWhereInput[]
  }

  export type SupplierQuotationUpdateManyWithoutRfqNestedInput = {
    create?: XOR<SupplierQuotationCreateWithoutRfqInput, SupplierQuotationUncheckedCreateWithoutRfqInput> | SupplierQuotationCreateWithoutRfqInput[] | SupplierQuotationUncheckedCreateWithoutRfqInput[]
    connectOrCreate?: SupplierQuotationCreateOrConnectWithoutRfqInput | SupplierQuotationCreateOrConnectWithoutRfqInput[]
    upsert?: SupplierQuotationUpsertWithWhereUniqueWithoutRfqInput | SupplierQuotationUpsertWithWhereUniqueWithoutRfqInput[]
    createMany?: SupplierQuotationCreateManyRfqInputEnvelope
    set?: SupplierQuotationWhereUniqueInput | SupplierQuotationWhereUniqueInput[]
    disconnect?: SupplierQuotationWhereUniqueInput | SupplierQuotationWhereUniqueInput[]
    delete?: SupplierQuotationWhereUniqueInput | SupplierQuotationWhereUniqueInput[]
    connect?: SupplierQuotationWhereUniqueInput | SupplierQuotationWhereUniqueInput[]
    update?: SupplierQuotationUpdateWithWhereUniqueWithoutRfqInput | SupplierQuotationUpdateWithWhereUniqueWithoutRfqInput[]
    updateMany?: SupplierQuotationUpdateManyWithWhereWithoutRfqInput | SupplierQuotationUpdateManyWithWhereWithoutRfqInput[]
    deleteMany?: SupplierQuotationScalarWhereInput | SupplierQuotationScalarWhereInput[]
  }

  export type RFQItemUncheckedUpdateManyWithoutRfqNestedInput = {
    create?: XOR<RFQItemCreateWithoutRfqInput, RFQItemUncheckedCreateWithoutRfqInput> | RFQItemCreateWithoutRfqInput[] | RFQItemUncheckedCreateWithoutRfqInput[]
    connectOrCreate?: RFQItemCreateOrConnectWithoutRfqInput | RFQItemCreateOrConnectWithoutRfqInput[]
    upsert?: RFQItemUpsertWithWhereUniqueWithoutRfqInput | RFQItemUpsertWithWhereUniqueWithoutRfqInput[]
    createMany?: RFQItemCreateManyRfqInputEnvelope
    set?: RFQItemWhereUniqueInput | RFQItemWhereUniqueInput[]
    disconnect?: RFQItemWhereUniqueInput | RFQItemWhereUniqueInput[]
    delete?: RFQItemWhereUniqueInput | RFQItemWhereUniqueInput[]
    connect?: RFQItemWhereUniqueInput | RFQItemWhereUniqueInput[]
    update?: RFQItemUpdateWithWhereUniqueWithoutRfqInput | RFQItemUpdateWithWhereUniqueWithoutRfqInput[]
    updateMany?: RFQItemUpdateManyWithWhereWithoutRfqInput | RFQItemUpdateManyWithWhereWithoutRfqInput[]
    deleteMany?: RFQItemScalarWhereInput | RFQItemScalarWhereInput[]
  }

  export type SupplierQuotationUncheckedUpdateManyWithoutRfqNestedInput = {
    create?: XOR<SupplierQuotationCreateWithoutRfqInput, SupplierQuotationUncheckedCreateWithoutRfqInput> | SupplierQuotationCreateWithoutRfqInput[] | SupplierQuotationUncheckedCreateWithoutRfqInput[]
    connectOrCreate?: SupplierQuotationCreateOrConnectWithoutRfqInput | SupplierQuotationCreateOrConnectWithoutRfqInput[]
    upsert?: SupplierQuotationUpsertWithWhereUniqueWithoutRfqInput | SupplierQuotationUpsertWithWhereUniqueWithoutRfqInput[]
    createMany?: SupplierQuotationCreateManyRfqInputEnvelope
    set?: SupplierQuotationWhereUniqueInput | SupplierQuotationWhereUniqueInput[]
    disconnect?: SupplierQuotationWhereUniqueInput | SupplierQuotationWhereUniqueInput[]
    delete?: SupplierQuotationWhereUniqueInput | SupplierQuotationWhereUniqueInput[]
    connect?: SupplierQuotationWhereUniqueInput | SupplierQuotationWhereUniqueInput[]
    update?: SupplierQuotationUpdateWithWhereUniqueWithoutRfqInput | SupplierQuotationUpdateWithWhereUniqueWithoutRfqInput[]
    updateMany?: SupplierQuotationUpdateManyWithWhereWithoutRfqInput | SupplierQuotationUpdateManyWithWhereWithoutRfqInput[]
    deleteMany?: SupplierQuotationScalarWhereInput | SupplierQuotationScalarWhereInput[]
  }

  export type RFQCreateNestedOneWithoutItemsInput = {
    create?: XOR<RFQCreateWithoutItemsInput, RFQUncheckedCreateWithoutItemsInput>
    connectOrCreate?: RFQCreateOrConnectWithoutItemsInput
    connect?: RFQWhereUniqueInput
  }

  export type RFQUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<RFQCreateWithoutItemsInput, RFQUncheckedCreateWithoutItemsInput>
    connectOrCreate?: RFQCreateOrConnectWithoutItemsInput
    upsert?: RFQUpsertWithoutItemsInput
    connect?: RFQWhereUniqueInput
    update?: XOR<XOR<RFQUpdateToOneWithWhereWithoutItemsInput, RFQUpdateWithoutItemsInput>, RFQUncheckedUpdateWithoutItemsInput>
  }

  export type SupplierQuotationCreateNestedManyWithoutSupplierInput = {
    create?: XOR<SupplierQuotationCreateWithoutSupplierInput, SupplierQuotationUncheckedCreateWithoutSupplierInput> | SupplierQuotationCreateWithoutSupplierInput[] | SupplierQuotationUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: SupplierQuotationCreateOrConnectWithoutSupplierInput | SupplierQuotationCreateOrConnectWithoutSupplierInput[]
    createMany?: SupplierQuotationCreateManySupplierInputEnvelope
    connect?: SupplierQuotationWhereUniqueInput | SupplierQuotationWhereUniqueInput[]
  }

  export type PurchaseOrderCreateNestedManyWithoutSupplierInput = {
    create?: XOR<PurchaseOrderCreateWithoutSupplierInput, PurchaseOrderUncheckedCreateWithoutSupplierInput> | PurchaseOrderCreateWithoutSupplierInput[] | PurchaseOrderUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutSupplierInput | PurchaseOrderCreateOrConnectWithoutSupplierInput[]
    createMany?: PurchaseOrderCreateManySupplierInputEnvelope
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
  }

  export type SupplierInvoiceCreateNestedManyWithoutSupplierInput = {
    create?: XOR<SupplierInvoiceCreateWithoutSupplierInput, SupplierInvoiceUncheckedCreateWithoutSupplierInput> | SupplierInvoiceCreateWithoutSupplierInput[] | SupplierInvoiceUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: SupplierInvoiceCreateOrConnectWithoutSupplierInput | SupplierInvoiceCreateOrConnectWithoutSupplierInput[]
    createMany?: SupplierInvoiceCreateManySupplierInputEnvelope
    connect?: SupplierInvoiceWhereUniqueInput | SupplierInvoiceWhereUniqueInput[]
  }

  export type SupplierQuotationUncheckedCreateNestedManyWithoutSupplierInput = {
    create?: XOR<SupplierQuotationCreateWithoutSupplierInput, SupplierQuotationUncheckedCreateWithoutSupplierInput> | SupplierQuotationCreateWithoutSupplierInput[] | SupplierQuotationUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: SupplierQuotationCreateOrConnectWithoutSupplierInput | SupplierQuotationCreateOrConnectWithoutSupplierInput[]
    createMany?: SupplierQuotationCreateManySupplierInputEnvelope
    connect?: SupplierQuotationWhereUniqueInput | SupplierQuotationWhereUniqueInput[]
  }

  export type PurchaseOrderUncheckedCreateNestedManyWithoutSupplierInput = {
    create?: XOR<PurchaseOrderCreateWithoutSupplierInput, PurchaseOrderUncheckedCreateWithoutSupplierInput> | PurchaseOrderCreateWithoutSupplierInput[] | PurchaseOrderUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutSupplierInput | PurchaseOrderCreateOrConnectWithoutSupplierInput[]
    createMany?: PurchaseOrderCreateManySupplierInputEnvelope
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
  }

  export type SupplierInvoiceUncheckedCreateNestedManyWithoutSupplierInput = {
    create?: XOR<SupplierInvoiceCreateWithoutSupplierInput, SupplierInvoiceUncheckedCreateWithoutSupplierInput> | SupplierInvoiceCreateWithoutSupplierInput[] | SupplierInvoiceUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: SupplierInvoiceCreateOrConnectWithoutSupplierInput | SupplierInvoiceCreateOrConnectWithoutSupplierInput[]
    createMany?: SupplierInvoiceCreateManySupplierInputEnvelope
    connect?: SupplierInvoiceWhereUniqueInput | SupplierInvoiceWhereUniqueInput[]
  }

  export type SupplierQuotationUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<SupplierQuotationCreateWithoutSupplierInput, SupplierQuotationUncheckedCreateWithoutSupplierInput> | SupplierQuotationCreateWithoutSupplierInput[] | SupplierQuotationUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: SupplierQuotationCreateOrConnectWithoutSupplierInput | SupplierQuotationCreateOrConnectWithoutSupplierInput[]
    upsert?: SupplierQuotationUpsertWithWhereUniqueWithoutSupplierInput | SupplierQuotationUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: SupplierQuotationCreateManySupplierInputEnvelope
    set?: SupplierQuotationWhereUniqueInput | SupplierQuotationWhereUniqueInput[]
    disconnect?: SupplierQuotationWhereUniqueInput | SupplierQuotationWhereUniqueInput[]
    delete?: SupplierQuotationWhereUniqueInput | SupplierQuotationWhereUniqueInput[]
    connect?: SupplierQuotationWhereUniqueInput | SupplierQuotationWhereUniqueInput[]
    update?: SupplierQuotationUpdateWithWhereUniqueWithoutSupplierInput | SupplierQuotationUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: SupplierQuotationUpdateManyWithWhereWithoutSupplierInput | SupplierQuotationUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: SupplierQuotationScalarWhereInput | SupplierQuotationScalarWhereInput[]
  }

  export type PurchaseOrderUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutSupplierInput, PurchaseOrderUncheckedCreateWithoutSupplierInput> | PurchaseOrderCreateWithoutSupplierInput[] | PurchaseOrderUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutSupplierInput | PurchaseOrderCreateOrConnectWithoutSupplierInput[]
    upsert?: PurchaseOrderUpsertWithWhereUniqueWithoutSupplierInput | PurchaseOrderUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: PurchaseOrderCreateManySupplierInputEnvelope
    set?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    disconnect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    delete?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    update?: PurchaseOrderUpdateWithWhereUniqueWithoutSupplierInput | PurchaseOrderUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: PurchaseOrderUpdateManyWithWhereWithoutSupplierInput | PurchaseOrderUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
  }

  export type SupplierInvoiceUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<SupplierInvoiceCreateWithoutSupplierInput, SupplierInvoiceUncheckedCreateWithoutSupplierInput> | SupplierInvoiceCreateWithoutSupplierInput[] | SupplierInvoiceUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: SupplierInvoiceCreateOrConnectWithoutSupplierInput | SupplierInvoiceCreateOrConnectWithoutSupplierInput[]
    upsert?: SupplierInvoiceUpsertWithWhereUniqueWithoutSupplierInput | SupplierInvoiceUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: SupplierInvoiceCreateManySupplierInputEnvelope
    set?: SupplierInvoiceWhereUniqueInput | SupplierInvoiceWhereUniqueInput[]
    disconnect?: SupplierInvoiceWhereUniqueInput | SupplierInvoiceWhereUniqueInput[]
    delete?: SupplierInvoiceWhereUniqueInput | SupplierInvoiceWhereUniqueInput[]
    connect?: SupplierInvoiceWhereUniqueInput | SupplierInvoiceWhereUniqueInput[]
    update?: SupplierInvoiceUpdateWithWhereUniqueWithoutSupplierInput | SupplierInvoiceUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: SupplierInvoiceUpdateManyWithWhereWithoutSupplierInput | SupplierInvoiceUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: SupplierInvoiceScalarWhereInput | SupplierInvoiceScalarWhereInput[]
  }

  export type SupplierQuotationUncheckedUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<SupplierQuotationCreateWithoutSupplierInput, SupplierQuotationUncheckedCreateWithoutSupplierInput> | SupplierQuotationCreateWithoutSupplierInput[] | SupplierQuotationUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: SupplierQuotationCreateOrConnectWithoutSupplierInput | SupplierQuotationCreateOrConnectWithoutSupplierInput[]
    upsert?: SupplierQuotationUpsertWithWhereUniqueWithoutSupplierInput | SupplierQuotationUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: SupplierQuotationCreateManySupplierInputEnvelope
    set?: SupplierQuotationWhereUniqueInput | SupplierQuotationWhereUniqueInput[]
    disconnect?: SupplierQuotationWhereUniqueInput | SupplierQuotationWhereUniqueInput[]
    delete?: SupplierQuotationWhereUniqueInput | SupplierQuotationWhereUniqueInput[]
    connect?: SupplierQuotationWhereUniqueInput | SupplierQuotationWhereUniqueInput[]
    update?: SupplierQuotationUpdateWithWhereUniqueWithoutSupplierInput | SupplierQuotationUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: SupplierQuotationUpdateManyWithWhereWithoutSupplierInput | SupplierQuotationUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: SupplierQuotationScalarWhereInput | SupplierQuotationScalarWhereInput[]
  }

  export type PurchaseOrderUncheckedUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutSupplierInput, PurchaseOrderUncheckedCreateWithoutSupplierInput> | PurchaseOrderCreateWithoutSupplierInput[] | PurchaseOrderUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutSupplierInput | PurchaseOrderCreateOrConnectWithoutSupplierInput[]
    upsert?: PurchaseOrderUpsertWithWhereUniqueWithoutSupplierInput | PurchaseOrderUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: PurchaseOrderCreateManySupplierInputEnvelope
    set?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    disconnect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    delete?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    update?: PurchaseOrderUpdateWithWhereUniqueWithoutSupplierInput | PurchaseOrderUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: PurchaseOrderUpdateManyWithWhereWithoutSupplierInput | PurchaseOrderUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
  }

  export type SupplierInvoiceUncheckedUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<SupplierInvoiceCreateWithoutSupplierInput, SupplierInvoiceUncheckedCreateWithoutSupplierInput> | SupplierInvoiceCreateWithoutSupplierInput[] | SupplierInvoiceUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: SupplierInvoiceCreateOrConnectWithoutSupplierInput | SupplierInvoiceCreateOrConnectWithoutSupplierInput[]
    upsert?: SupplierInvoiceUpsertWithWhereUniqueWithoutSupplierInput | SupplierInvoiceUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: SupplierInvoiceCreateManySupplierInputEnvelope
    set?: SupplierInvoiceWhereUniqueInput | SupplierInvoiceWhereUniqueInput[]
    disconnect?: SupplierInvoiceWhereUniqueInput | SupplierInvoiceWhereUniqueInput[]
    delete?: SupplierInvoiceWhereUniqueInput | SupplierInvoiceWhereUniqueInput[]
    connect?: SupplierInvoiceWhereUniqueInput | SupplierInvoiceWhereUniqueInput[]
    update?: SupplierInvoiceUpdateWithWhereUniqueWithoutSupplierInput | SupplierInvoiceUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: SupplierInvoiceUpdateManyWithWhereWithoutSupplierInput | SupplierInvoiceUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: SupplierInvoiceScalarWhereInput | SupplierInvoiceScalarWhereInput[]
  }

  export type InventoryItemCreateNestedManyWithoutWarehouseInput = {
    create?: XOR<InventoryItemCreateWithoutWarehouseInput, InventoryItemUncheckedCreateWithoutWarehouseInput> | InventoryItemCreateWithoutWarehouseInput[] | InventoryItemUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutWarehouseInput | InventoryItemCreateOrConnectWithoutWarehouseInput[]
    createMany?: InventoryItemCreateManyWarehouseInputEnvelope
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
  }

  export type InventoryItemUncheckedCreateNestedManyWithoutWarehouseInput = {
    create?: XOR<InventoryItemCreateWithoutWarehouseInput, InventoryItemUncheckedCreateWithoutWarehouseInput> | InventoryItemCreateWithoutWarehouseInput[] | InventoryItemUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutWarehouseInput | InventoryItemCreateOrConnectWithoutWarehouseInput[]
    createMany?: InventoryItemCreateManyWarehouseInputEnvelope
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
  }

  export type InventoryItemUpdateManyWithoutWarehouseNestedInput = {
    create?: XOR<InventoryItemCreateWithoutWarehouseInput, InventoryItemUncheckedCreateWithoutWarehouseInput> | InventoryItemCreateWithoutWarehouseInput[] | InventoryItemUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutWarehouseInput | InventoryItemCreateOrConnectWithoutWarehouseInput[]
    upsert?: InventoryItemUpsertWithWhereUniqueWithoutWarehouseInput | InventoryItemUpsertWithWhereUniqueWithoutWarehouseInput[]
    createMany?: InventoryItemCreateManyWarehouseInputEnvelope
    set?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    disconnect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    delete?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    update?: InventoryItemUpdateWithWhereUniqueWithoutWarehouseInput | InventoryItemUpdateWithWhereUniqueWithoutWarehouseInput[]
    updateMany?: InventoryItemUpdateManyWithWhereWithoutWarehouseInput | InventoryItemUpdateManyWithWhereWithoutWarehouseInput[]
    deleteMany?: InventoryItemScalarWhereInput | InventoryItemScalarWhereInput[]
  }

  export type InventoryItemUncheckedUpdateManyWithoutWarehouseNestedInput = {
    create?: XOR<InventoryItemCreateWithoutWarehouseInput, InventoryItemUncheckedCreateWithoutWarehouseInput> | InventoryItemCreateWithoutWarehouseInput[] | InventoryItemUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutWarehouseInput | InventoryItemCreateOrConnectWithoutWarehouseInput[]
    upsert?: InventoryItemUpsertWithWhereUniqueWithoutWarehouseInput | InventoryItemUpsertWithWhereUniqueWithoutWarehouseInput[]
    createMany?: InventoryItemCreateManyWarehouseInputEnvelope
    set?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    disconnect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    delete?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    update?: InventoryItemUpdateWithWhereUniqueWithoutWarehouseInput | InventoryItemUpdateWithWhereUniqueWithoutWarehouseInput[]
    updateMany?: InventoryItemUpdateManyWithWhereWithoutWarehouseInput | InventoryItemUpdateManyWithWhereWithoutWarehouseInput[]
    deleteMany?: InventoryItemScalarWhereInput | InventoryItemScalarWhereInput[]
  }

  export type RFQCreateNestedOneWithoutQuotationsInput = {
    create?: XOR<RFQCreateWithoutQuotationsInput, RFQUncheckedCreateWithoutQuotationsInput>
    connectOrCreate?: RFQCreateOrConnectWithoutQuotationsInput
    connect?: RFQWhereUniqueInput
  }

  export type SupplierCreateNestedOneWithoutQuotationsInput = {
    create?: XOR<SupplierCreateWithoutQuotationsInput, SupplierUncheckedCreateWithoutQuotationsInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutQuotationsInput
    connect?: SupplierWhereUniqueInput
  }

  export type QuotationItemCreateNestedManyWithoutSupplierQuotationInput = {
    create?: XOR<QuotationItemCreateWithoutSupplierQuotationInput, QuotationItemUncheckedCreateWithoutSupplierQuotationInput> | QuotationItemCreateWithoutSupplierQuotationInput[] | QuotationItemUncheckedCreateWithoutSupplierQuotationInput[]
    connectOrCreate?: QuotationItemCreateOrConnectWithoutSupplierQuotationInput | QuotationItemCreateOrConnectWithoutSupplierQuotationInput[]
    createMany?: QuotationItemCreateManySupplierQuotationInputEnvelope
    connect?: QuotationItemWhereUniqueInput | QuotationItemWhereUniqueInput[]
  }

  export type QuotationItemUncheckedCreateNestedManyWithoutSupplierQuotationInput = {
    create?: XOR<QuotationItemCreateWithoutSupplierQuotationInput, QuotationItemUncheckedCreateWithoutSupplierQuotationInput> | QuotationItemCreateWithoutSupplierQuotationInput[] | QuotationItemUncheckedCreateWithoutSupplierQuotationInput[]
    connectOrCreate?: QuotationItemCreateOrConnectWithoutSupplierQuotationInput | QuotationItemCreateOrConnectWithoutSupplierQuotationInput[]
    createMany?: QuotationItemCreateManySupplierQuotationInputEnvelope
    connect?: QuotationItemWhereUniqueInput | QuotationItemWhereUniqueInput[]
  }

  export type RFQUpdateOneRequiredWithoutQuotationsNestedInput = {
    create?: XOR<RFQCreateWithoutQuotationsInput, RFQUncheckedCreateWithoutQuotationsInput>
    connectOrCreate?: RFQCreateOrConnectWithoutQuotationsInput
    upsert?: RFQUpsertWithoutQuotationsInput
    connect?: RFQWhereUniqueInput
    update?: XOR<XOR<RFQUpdateToOneWithWhereWithoutQuotationsInput, RFQUpdateWithoutQuotationsInput>, RFQUncheckedUpdateWithoutQuotationsInput>
  }

  export type SupplierUpdateOneRequiredWithoutQuotationsNestedInput = {
    create?: XOR<SupplierCreateWithoutQuotationsInput, SupplierUncheckedCreateWithoutQuotationsInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutQuotationsInput
    upsert?: SupplierUpsertWithoutQuotationsInput
    connect?: SupplierWhereUniqueInput
    update?: XOR<XOR<SupplierUpdateToOneWithWhereWithoutQuotationsInput, SupplierUpdateWithoutQuotationsInput>, SupplierUncheckedUpdateWithoutQuotationsInput>
  }

  export type QuotationItemUpdateManyWithoutSupplierQuotationNestedInput = {
    create?: XOR<QuotationItemCreateWithoutSupplierQuotationInput, QuotationItemUncheckedCreateWithoutSupplierQuotationInput> | QuotationItemCreateWithoutSupplierQuotationInput[] | QuotationItemUncheckedCreateWithoutSupplierQuotationInput[]
    connectOrCreate?: QuotationItemCreateOrConnectWithoutSupplierQuotationInput | QuotationItemCreateOrConnectWithoutSupplierQuotationInput[]
    upsert?: QuotationItemUpsertWithWhereUniqueWithoutSupplierQuotationInput | QuotationItemUpsertWithWhereUniqueWithoutSupplierQuotationInput[]
    createMany?: QuotationItemCreateManySupplierQuotationInputEnvelope
    set?: QuotationItemWhereUniqueInput | QuotationItemWhereUniqueInput[]
    disconnect?: QuotationItemWhereUniqueInput | QuotationItemWhereUniqueInput[]
    delete?: QuotationItemWhereUniqueInput | QuotationItemWhereUniqueInput[]
    connect?: QuotationItemWhereUniqueInput | QuotationItemWhereUniqueInput[]
    update?: QuotationItemUpdateWithWhereUniqueWithoutSupplierQuotationInput | QuotationItemUpdateWithWhereUniqueWithoutSupplierQuotationInput[]
    updateMany?: QuotationItemUpdateManyWithWhereWithoutSupplierQuotationInput | QuotationItemUpdateManyWithWhereWithoutSupplierQuotationInput[]
    deleteMany?: QuotationItemScalarWhereInput | QuotationItemScalarWhereInput[]
  }

  export type QuotationItemUncheckedUpdateManyWithoutSupplierQuotationNestedInput = {
    create?: XOR<QuotationItemCreateWithoutSupplierQuotationInput, QuotationItemUncheckedCreateWithoutSupplierQuotationInput> | QuotationItemCreateWithoutSupplierQuotationInput[] | QuotationItemUncheckedCreateWithoutSupplierQuotationInput[]
    connectOrCreate?: QuotationItemCreateOrConnectWithoutSupplierQuotationInput | QuotationItemCreateOrConnectWithoutSupplierQuotationInput[]
    upsert?: QuotationItemUpsertWithWhereUniqueWithoutSupplierQuotationInput | QuotationItemUpsertWithWhereUniqueWithoutSupplierQuotationInput[]
    createMany?: QuotationItemCreateManySupplierQuotationInputEnvelope
    set?: QuotationItemWhereUniqueInput | QuotationItemWhereUniqueInput[]
    disconnect?: QuotationItemWhereUniqueInput | QuotationItemWhereUniqueInput[]
    delete?: QuotationItemWhereUniqueInput | QuotationItemWhereUniqueInput[]
    connect?: QuotationItemWhereUniqueInput | QuotationItemWhereUniqueInput[]
    update?: QuotationItemUpdateWithWhereUniqueWithoutSupplierQuotationInput | QuotationItemUpdateWithWhereUniqueWithoutSupplierQuotationInput[]
    updateMany?: QuotationItemUpdateManyWithWhereWithoutSupplierQuotationInput | QuotationItemUpdateManyWithWhereWithoutSupplierQuotationInput[]
    deleteMany?: QuotationItemScalarWhereInput | QuotationItemScalarWhereInput[]
  }

  export type SupplierQuotationCreateNestedOneWithoutItemsInput = {
    create?: XOR<SupplierQuotationCreateWithoutItemsInput, SupplierQuotationUncheckedCreateWithoutItemsInput>
    connectOrCreate?: SupplierQuotationCreateOrConnectWithoutItemsInput
    connect?: SupplierQuotationWhereUniqueInput
  }

  export type SupplierQuotationUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<SupplierQuotationCreateWithoutItemsInput, SupplierQuotationUncheckedCreateWithoutItemsInput>
    connectOrCreate?: SupplierQuotationCreateOrConnectWithoutItemsInput
    upsert?: SupplierQuotationUpsertWithoutItemsInput
    connect?: SupplierQuotationWhereUniqueInput
    update?: XOR<XOR<SupplierQuotationUpdateToOneWithWhereWithoutItemsInput, SupplierQuotationUpdateWithoutItemsInput>, SupplierQuotationUncheckedUpdateWithoutItemsInput>
  }

  export type ProjectCreateNestedOneWithoutPurchaseOrdersInput = {
    create?: XOR<ProjectCreateWithoutPurchaseOrdersInput, ProjectUncheckedCreateWithoutPurchaseOrdersInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutPurchaseOrdersInput
    connect?: ProjectWhereUniqueInput
  }

  export type SupplierCreateNestedOneWithoutPurchaseOrdersInput = {
    create?: XOR<SupplierCreateWithoutPurchaseOrdersInput, SupplierUncheckedCreateWithoutPurchaseOrdersInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutPurchaseOrdersInput
    connect?: SupplierWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPurchaseOrdersInput = {
    create?: XOR<UserCreateWithoutPurchaseOrdersInput, UserUncheckedCreateWithoutPurchaseOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutPurchaseOrdersInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPoApprovalsInput = {
    create?: XOR<UserCreateWithoutPoApprovalsInput, UserUncheckedCreateWithoutPoApprovalsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPoApprovalsInput
    connect?: UserWhereUniqueInput
  }

  export type PurchaseOrderItemCreateNestedManyWithoutPurchaseOrderInput = {
    create?: XOR<PurchaseOrderItemCreateWithoutPurchaseOrderInput, PurchaseOrderItemUncheckedCreateWithoutPurchaseOrderInput> | PurchaseOrderItemCreateWithoutPurchaseOrderInput[] | PurchaseOrderItemUncheckedCreateWithoutPurchaseOrderInput[]
    connectOrCreate?: PurchaseOrderItemCreateOrConnectWithoutPurchaseOrderInput | PurchaseOrderItemCreateOrConnectWithoutPurchaseOrderInput[]
    createMany?: PurchaseOrderItemCreateManyPurchaseOrderInputEnvelope
    connect?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
  }

  export type ReceivingReportCreateNestedManyWithoutPurchaseOrderInput = {
    create?: XOR<ReceivingReportCreateWithoutPurchaseOrderInput, ReceivingReportUncheckedCreateWithoutPurchaseOrderInput> | ReceivingReportCreateWithoutPurchaseOrderInput[] | ReceivingReportUncheckedCreateWithoutPurchaseOrderInput[]
    connectOrCreate?: ReceivingReportCreateOrConnectWithoutPurchaseOrderInput | ReceivingReportCreateOrConnectWithoutPurchaseOrderInput[]
    createMany?: ReceivingReportCreateManyPurchaseOrderInputEnvelope
    connect?: ReceivingReportWhereUniqueInput | ReceivingReportWhereUniqueInput[]
  }

  export type SupplierInvoiceCreateNestedManyWithoutPurchaseOrderInput = {
    create?: XOR<SupplierInvoiceCreateWithoutPurchaseOrderInput, SupplierInvoiceUncheckedCreateWithoutPurchaseOrderInput> | SupplierInvoiceCreateWithoutPurchaseOrderInput[] | SupplierInvoiceUncheckedCreateWithoutPurchaseOrderInput[]
    connectOrCreate?: SupplierInvoiceCreateOrConnectWithoutPurchaseOrderInput | SupplierInvoiceCreateOrConnectWithoutPurchaseOrderInput[]
    createMany?: SupplierInvoiceCreateManyPurchaseOrderInputEnvelope
    connect?: SupplierInvoiceWhereUniqueInput | SupplierInvoiceWhereUniqueInput[]
  }

  export type DisbursementCreateNestedManyWithoutPurchaseOrderInput = {
    create?: XOR<DisbursementCreateWithoutPurchaseOrderInput, DisbursementUncheckedCreateWithoutPurchaseOrderInput> | DisbursementCreateWithoutPurchaseOrderInput[] | DisbursementUncheckedCreateWithoutPurchaseOrderInput[]
    connectOrCreate?: DisbursementCreateOrConnectWithoutPurchaseOrderInput | DisbursementCreateOrConnectWithoutPurchaseOrderInput[]
    createMany?: DisbursementCreateManyPurchaseOrderInputEnvelope
    connect?: DisbursementWhereUniqueInput | DisbursementWhereUniqueInput[]
  }

  export type PurchaseOrderItemUncheckedCreateNestedManyWithoutPurchaseOrderInput = {
    create?: XOR<PurchaseOrderItemCreateWithoutPurchaseOrderInput, PurchaseOrderItemUncheckedCreateWithoutPurchaseOrderInput> | PurchaseOrderItemCreateWithoutPurchaseOrderInput[] | PurchaseOrderItemUncheckedCreateWithoutPurchaseOrderInput[]
    connectOrCreate?: PurchaseOrderItemCreateOrConnectWithoutPurchaseOrderInput | PurchaseOrderItemCreateOrConnectWithoutPurchaseOrderInput[]
    createMany?: PurchaseOrderItemCreateManyPurchaseOrderInputEnvelope
    connect?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
  }

  export type ReceivingReportUncheckedCreateNestedManyWithoutPurchaseOrderInput = {
    create?: XOR<ReceivingReportCreateWithoutPurchaseOrderInput, ReceivingReportUncheckedCreateWithoutPurchaseOrderInput> | ReceivingReportCreateWithoutPurchaseOrderInput[] | ReceivingReportUncheckedCreateWithoutPurchaseOrderInput[]
    connectOrCreate?: ReceivingReportCreateOrConnectWithoutPurchaseOrderInput | ReceivingReportCreateOrConnectWithoutPurchaseOrderInput[]
    createMany?: ReceivingReportCreateManyPurchaseOrderInputEnvelope
    connect?: ReceivingReportWhereUniqueInput | ReceivingReportWhereUniqueInput[]
  }

  export type SupplierInvoiceUncheckedCreateNestedManyWithoutPurchaseOrderInput = {
    create?: XOR<SupplierInvoiceCreateWithoutPurchaseOrderInput, SupplierInvoiceUncheckedCreateWithoutPurchaseOrderInput> | SupplierInvoiceCreateWithoutPurchaseOrderInput[] | SupplierInvoiceUncheckedCreateWithoutPurchaseOrderInput[]
    connectOrCreate?: SupplierInvoiceCreateOrConnectWithoutPurchaseOrderInput | SupplierInvoiceCreateOrConnectWithoutPurchaseOrderInput[]
    createMany?: SupplierInvoiceCreateManyPurchaseOrderInputEnvelope
    connect?: SupplierInvoiceWhereUniqueInput | SupplierInvoiceWhereUniqueInput[]
  }

  export type DisbursementUncheckedCreateNestedManyWithoutPurchaseOrderInput = {
    create?: XOR<DisbursementCreateWithoutPurchaseOrderInput, DisbursementUncheckedCreateWithoutPurchaseOrderInput> | DisbursementCreateWithoutPurchaseOrderInput[] | DisbursementUncheckedCreateWithoutPurchaseOrderInput[]
    connectOrCreate?: DisbursementCreateOrConnectWithoutPurchaseOrderInput | DisbursementCreateOrConnectWithoutPurchaseOrderInput[]
    createMany?: DisbursementCreateManyPurchaseOrderInputEnvelope
    connect?: DisbursementWhereUniqueInput | DisbursementWhereUniqueInput[]
  }

  export type EnumPoStatusFieldUpdateOperationsInput = {
    set?: $Enums.PoStatus
  }

  export type ProjectUpdateOneRequiredWithoutPurchaseOrdersNestedInput = {
    create?: XOR<ProjectCreateWithoutPurchaseOrdersInput, ProjectUncheckedCreateWithoutPurchaseOrdersInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutPurchaseOrdersInput
    upsert?: ProjectUpsertWithoutPurchaseOrdersInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutPurchaseOrdersInput, ProjectUpdateWithoutPurchaseOrdersInput>, ProjectUncheckedUpdateWithoutPurchaseOrdersInput>
  }

  export type SupplierUpdateOneWithoutPurchaseOrdersNestedInput = {
    create?: XOR<SupplierCreateWithoutPurchaseOrdersInput, SupplierUncheckedCreateWithoutPurchaseOrdersInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutPurchaseOrdersInput
    upsert?: SupplierUpsertWithoutPurchaseOrdersInput
    disconnect?: SupplierWhereInput | boolean
    delete?: SupplierWhereInput | boolean
    connect?: SupplierWhereUniqueInput
    update?: XOR<XOR<SupplierUpdateToOneWithWhereWithoutPurchaseOrdersInput, SupplierUpdateWithoutPurchaseOrdersInput>, SupplierUncheckedUpdateWithoutPurchaseOrdersInput>
  }

  export type UserUpdateOneRequiredWithoutPurchaseOrdersNestedInput = {
    create?: XOR<UserCreateWithoutPurchaseOrdersInput, UserUncheckedCreateWithoutPurchaseOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutPurchaseOrdersInput
    upsert?: UserUpsertWithoutPurchaseOrdersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPurchaseOrdersInput, UserUpdateWithoutPurchaseOrdersInput>, UserUncheckedUpdateWithoutPurchaseOrdersInput>
  }

  export type UserUpdateOneWithoutPoApprovalsNestedInput = {
    create?: XOR<UserCreateWithoutPoApprovalsInput, UserUncheckedCreateWithoutPoApprovalsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPoApprovalsInput
    upsert?: UserUpsertWithoutPoApprovalsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPoApprovalsInput, UserUpdateWithoutPoApprovalsInput>, UserUncheckedUpdateWithoutPoApprovalsInput>
  }

  export type PurchaseOrderItemUpdateManyWithoutPurchaseOrderNestedInput = {
    create?: XOR<PurchaseOrderItemCreateWithoutPurchaseOrderInput, PurchaseOrderItemUncheckedCreateWithoutPurchaseOrderInput> | PurchaseOrderItemCreateWithoutPurchaseOrderInput[] | PurchaseOrderItemUncheckedCreateWithoutPurchaseOrderInput[]
    connectOrCreate?: PurchaseOrderItemCreateOrConnectWithoutPurchaseOrderInput | PurchaseOrderItemCreateOrConnectWithoutPurchaseOrderInput[]
    upsert?: PurchaseOrderItemUpsertWithWhereUniqueWithoutPurchaseOrderInput | PurchaseOrderItemUpsertWithWhereUniqueWithoutPurchaseOrderInput[]
    createMany?: PurchaseOrderItemCreateManyPurchaseOrderInputEnvelope
    set?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    disconnect?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    delete?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    connect?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    update?: PurchaseOrderItemUpdateWithWhereUniqueWithoutPurchaseOrderInput | PurchaseOrderItemUpdateWithWhereUniqueWithoutPurchaseOrderInput[]
    updateMany?: PurchaseOrderItemUpdateManyWithWhereWithoutPurchaseOrderInput | PurchaseOrderItemUpdateManyWithWhereWithoutPurchaseOrderInput[]
    deleteMany?: PurchaseOrderItemScalarWhereInput | PurchaseOrderItemScalarWhereInput[]
  }

  export type ReceivingReportUpdateManyWithoutPurchaseOrderNestedInput = {
    create?: XOR<ReceivingReportCreateWithoutPurchaseOrderInput, ReceivingReportUncheckedCreateWithoutPurchaseOrderInput> | ReceivingReportCreateWithoutPurchaseOrderInput[] | ReceivingReportUncheckedCreateWithoutPurchaseOrderInput[]
    connectOrCreate?: ReceivingReportCreateOrConnectWithoutPurchaseOrderInput | ReceivingReportCreateOrConnectWithoutPurchaseOrderInput[]
    upsert?: ReceivingReportUpsertWithWhereUniqueWithoutPurchaseOrderInput | ReceivingReportUpsertWithWhereUniqueWithoutPurchaseOrderInput[]
    createMany?: ReceivingReportCreateManyPurchaseOrderInputEnvelope
    set?: ReceivingReportWhereUniqueInput | ReceivingReportWhereUniqueInput[]
    disconnect?: ReceivingReportWhereUniqueInput | ReceivingReportWhereUniqueInput[]
    delete?: ReceivingReportWhereUniqueInput | ReceivingReportWhereUniqueInput[]
    connect?: ReceivingReportWhereUniqueInput | ReceivingReportWhereUniqueInput[]
    update?: ReceivingReportUpdateWithWhereUniqueWithoutPurchaseOrderInput | ReceivingReportUpdateWithWhereUniqueWithoutPurchaseOrderInput[]
    updateMany?: ReceivingReportUpdateManyWithWhereWithoutPurchaseOrderInput | ReceivingReportUpdateManyWithWhereWithoutPurchaseOrderInput[]
    deleteMany?: ReceivingReportScalarWhereInput | ReceivingReportScalarWhereInput[]
  }

  export type SupplierInvoiceUpdateManyWithoutPurchaseOrderNestedInput = {
    create?: XOR<SupplierInvoiceCreateWithoutPurchaseOrderInput, SupplierInvoiceUncheckedCreateWithoutPurchaseOrderInput> | SupplierInvoiceCreateWithoutPurchaseOrderInput[] | SupplierInvoiceUncheckedCreateWithoutPurchaseOrderInput[]
    connectOrCreate?: SupplierInvoiceCreateOrConnectWithoutPurchaseOrderInput | SupplierInvoiceCreateOrConnectWithoutPurchaseOrderInput[]
    upsert?: SupplierInvoiceUpsertWithWhereUniqueWithoutPurchaseOrderInput | SupplierInvoiceUpsertWithWhereUniqueWithoutPurchaseOrderInput[]
    createMany?: SupplierInvoiceCreateManyPurchaseOrderInputEnvelope
    set?: SupplierInvoiceWhereUniqueInput | SupplierInvoiceWhereUniqueInput[]
    disconnect?: SupplierInvoiceWhereUniqueInput | SupplierInvoiceWhereUniqueInput[]
    delete?: SupplierInvoiceWhereUniqueInput | SupplierInvoiceWhereUniqueInput[]
    connect?: SupplierInvoiceWhereUniqueInput | SupplierInvoiceWhereUniqueInput[]
    update?: SupplierInvoiceUpdateWithWhereUniqueWithoutPurchaseOrderInput | SupplierInvoiceUpdateWithWhereUniqueWithoutPurchaseOrderInput[]
    updateMany?: SupplierInvoiceUpdateManyWithWhereWithoutPurchaseOrderInput | SupplierInvoiceUpdateManyWithWhereWithoutPurchaseOrderInput[]
    deleteMany?: SupplierInvoiceScalarWhereInput | SupplierInvoiceScalarWhereInput[]
  }

  export type DisbursementUpdateManyWithoutPurchaseOrderNestedInput = {
    create?: XOR<DisbursementCreateWithoutPurchaseOrderInput, DisbursementUncheckedCreateWithoutPurchaseOrderInput> | DisbursementCreateWithoutPurchaseOrderInput[] | DisbursementUncheckedCreateWithoutPurchaseOrderInput[]
    connectOrCreate?: DisbursementCreateOrConnectWithoutPurchaseOrderInput | DisbursementCreateOrConnectWithoutPurchaseOrderInput[]
    upsert?: DisbursementUpsertWithWhereUniqueWithoutPurchaseOrderInput | DisbursementUpsertWithWhereUniqueWithoutPurchaseOrderInput[]
    createMany?: DisbursementCreateManyPurchaseOrderInputEnvelope
    set?: DisbursementWhereUniqueInput | DisbursementWhereUniqueInput[]
    disconnect?: DisbursementWhereUniqueInput | DisbursementWhereUniqueInput[]
    delete?: DisbursementWhereUniqueInput | DisbursementWhereUniqueInput[]
    connect?: DisbursementWhereUniqueInput | DisbursementWhereUniqueInput[]
    update?: DisbursementUpdateWithWhereUniqueWithoutPurchaseOrderInput | DisbursementUpdateWithWhereUniqueWithoutPurchaseOrderInput[]
    updateMany?: DisbursementUpdateManyWithWhereWithoutPurchaseOrderInput | DisbursementUpdateManyWithWhereWithoutPurchaseOrderInput[]
    deleteMany?: DisbursementScalarWhereInput | DisbursementScalarWhereInput[]
  }

  export type PurchaseOrderItemUncheckedUpdateManyWithoutPurchaseOrderNestedInput = {
    create?: XOR<PurchaseOrderItemCreateWithoutPurchaseOrderInput, PurchaseOrderItemUncheckedCreateWithoutPurchaseOrderInput> | PurchaseOrderItemCreateWithoutPurchaseOrderInput[] | PurchaseOrderItemUncheckedCreateWithoutPurchaseOrderInput[]
    connectOrCreate?: PurchaseOrderItemCreateOrConnectWithoutPurchaseOrderInput | PurchaseOrderItemCreateOrConnectWithoutPurchaseOrderInput[]
    upsert?: PurchaseOrderItemUpsertWithWhereUniqueWithoutPurchaseOrderInput | PurchaseOrderItemUpsertWithWhereUniqueWithoutPurchaseOrderInput[]
    createMany?: PurchaseOrderItemCreateManyPurchaseOrderInputEnvelope
    set?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    disconnect?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    delete?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    connect?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    update?: PurchaseOrderItemUpdateWithWhereUniqueWithoutPurchaseOrderInput | PurchaseOrderItemUpdateWithWhereUniqueWithoutPurchaseOrderInput[]
    updateMany?: PurchaseOrderItemUpdateManyWithWhereWithoutPurchaseOrderInput | PurchaseOrderItemUpdateManyWithWhereWithoutPurchaseOrderInput[]
    deleteMany?: PurchaseOrderItemScalarWhereInput | PurchaseOrderItemScalarWhereInput[]
  }

  export type ReceivingReportUncheckedUpdateManyWithoutPurchaseOrderNestedInput = {
    create?: XOR<ReceivingReportCreateWithoutPurchaseOrderInput, ReceivingReportUncheckedCreateWithoutPurchaseOrderInput> | ReceivingReportCreateWithoutPurchaseOrderInput[] | ReceivingReportUncheckedCreateWithoutPurchaseOrderInput[]
    connectOrCreate?: ReceivingReportCreateOrConnectWithoutPurchaseOrderInput | ReceivingReportCreateOrConnectWithoutPurchaseOrderInput[]
    upsert?: ReceivingReportUpsertWithWhereUniqueWithoutPurchaseOrderInput | ReceivingReportUpsertWithWhereUniqueWithoutPurchaseOrderInput[]
    createMany?: ReceivingReportCreateManyPurchaseOrderInputEnvelope
    set?: ReceivingReportWhereUniqueInput | ReceivingReportWhereUniqueInput[]
    disconnect?: ReceivingReportWhereUniqueInput | ReceivingReportWhereUniqueInput[]
    delete?: ReceivingReportWhereUniqueInput | ReceivingReportWhereUniqueInput[]
    connect?: ReceivingReportWhereUniqueInput | ReceivingReportWhereUniqueInput[]
    update?: ReceivingReportUpdateWithWhereUniqueWithoutPurchaseOrderInput | ReceivingReportUpdateWithWhereUniqueWithoutPurchaseOrderInput[]
    updateMany?: ReceivingReportUpdateManyWithWhereWithoutPurchaseOrderInput | ReceivingReportUpdateManyWithWhereWithoutPurchaseOrderInput[]
    deleteMany?: ReceivingReportScalarWhereInput | ReceivingReportScalarWhereInput[]
  }

  export type SupplierInvoiceUncheckedUpdateManyWithoutPurchaseOrderNestedInput = {
    create?: XOR<SupplierInvoiceCreateWithoutPurchaseOrderInput, SupplierInvoiceUncheckedCreateWithoutPurchaseOrderInput> | SupplierInvoiceCreateWithoutPurchaseOrderInput[] | SupplierInvoiceUncheckedCreateWithoutPurchaseOrderInput[]
    connectOrCreate?: SupplierInvoiceCreateOrConnectWithoutPurchaseOrderInput | SupplierInvoiceCreateOrConnectWithoutPurchaseOrderInput[]
    upsert?: SupplierInvoiceUpsertWithWhereUniqueWithoutPurchaseOrderInput | SupplierInvoiceUpsertWithWhereUniqueWithoutPurchaseOrderInput[]
    createMany?: SupplierInvoiceCreateManyPurchaseOrderInputEnvelope
    set?: SupplierInvoiceWhereUniqueInput | SupplierInvoiceWhereUniqueInput[]
    disconnect?: SupplierInvoiceWhereUniqueInput | SupplierInvoiceWhereUniqueInput[]
    delete?: SupplierInvoiceWhereUniqueInput | SupplierInvoiceWhereUniqueInput[]
    connect?: SupplierInvoiceWhereUniqueInput | SupplierInvoiceWhereUniqueInput[]
    update?: SupplierInvoiceUpdateWithWhereUniqueWithoutPurchaseOrderInput | SupplierInvoiceUpdateWithWhereUniqueWithoutPurchaseOrderInput[]
    updateMany?: SupplierInvoiceUpdateManyWithWhereWithoutPurchaseOrderInput | SupplierInvoiceUpdateManyWithWhereWithoutPurchaseOrderInput[]
    deleteMany?: SupplierInvoiceScalarWhereInput | SupplierInvoiceScalarWhereInput[]
  }

  export type DisbursementUncheckedUpdateManyWithoutPurchaseOrderNestedInput = {
    create?: XOR<DisbursementCreateWithoutPurchaseOrderInput, DisbursementUncheckedCreateWithoutPurchaseOrderInput> | DisbursementCreateWithoutPurchaseOrderInput[] | DisbursementUncheckedCreateWithoutPurchaseOrderInput[]
    connectOrCreate?: DisbursementCreateOrConnectWithoutPurchaseOrderInput | DisbursementCreateOrConnectWithoutPurchaseOrderInput[]
    upsert?: DisbursementUpsertWithWhereUniqueWithoutPurchaseOrderInput | DisbursementUpsertWithWhereUniqueWithoutPurchaseOrderInput[]
    createMany?: DisbursementCreateManyPurchaseOrderInputEnvelope
    set?: DisbursementWhereUniqueInput | DisbursementWhereUniqueInput[]
    disconnect?: DisbursementWhereUniqueInput | DisbursementWhereUniqueInput[]
    delete?: DisbursementWhereUniqueInput | DisbursementWhereUniqueInput[]
    connect?: DisbursementWhereUniqueInput | DisbursementWhereUniqueInput[]
    update?: DisbursementUpdateWithWhereUniqueWithoutPurchaseOrderInput | DisbursementUpdateWithWhereUniqueWithoutPurchaseOrderInput[]
    updateMany?: DisbursementUpdateManyWithWhereWithoutPurchaseOrderInput | DisbursementUpdateManyWithWhereWithoutPurchaseOrderInput[]
    deleteMany?: DisbursementScalarWhereInput | DisbursementScalarWhereInput[]
  }

  export type PurchaseOrderCreateNestedOneWithoutItemsInput = {
    create?: XOR<PurchaseOrderCreateWithoutItemsInput, PurchaseOrderUncheckedCreateWithoutItemsInput>
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutItemsInput
    connect?: PurchaseOrderWhereUniqueInput
  }

  export type PurchaseOrderUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutItemsInput, PurchaseOrderUncheckedCreateWithoutItemsInput>
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutItemsInput
    upsert?: PurchaseOrderUpsertWithoutItemsInput
    connect?: PurchaseOrderWhereUniqueInput
    update?: XOR<XOR<PurchaseOrderUpdateToOneWithWhereWithoutItemsInput, PurchaseOrderUpdateWithoutItemsInput>, PurchaseOrderUncheckedUpdateWithoutItemsInput>
  }

  export type PurchaseOrderCreateNestedOneWithoutReceivingInput = {
    create?: XOR<PurchaseOrderCreateWithoutReceivingInput, PurchaseOrderUncheckedCreateWithoutReceivingInput>
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutReceivingInput
    connect?: PurchaseOrderWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReceivedItemsInput = {
    create?: XOR<UserCreateWithoutReceivedItemsInput, UserUncheckedCreateWithoutReceivedItemsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceivedItemsInput
    connect?: UserWhereUniqueInput
  }

  export type ReceivingItemCreateNestedManyWithoutReceivingReportInput = {
    create?: XOR<ReceivingItemCreateWithoutReceivingReportInput, ReceivingItemUncheckedCreateWithoutReceivingReportInput> | ReceivingItemCreateWithoutReceivingReportInput[] | ReceivingItemUncheckedCreateWithoutReceivingReportInput[]
    connectOrCreate?: ReceivingItemCreateOrConnectWithoutReceivingReportInput | ReceivingItemCreateOrConnectWithoutReceivingReportInput[]
    createMany?: ReceivingItemCreateManyReceivingReportInputEnvelope
    connect?: ReceivingItemWhereUniqueInput | ReceivingItemWhereUniqueInput[]
  }

  export type SupplierInvoiceCreateNestedManyWithoutReceivingReportInput = {
    create?: XOR<SupplierInvoiceCreateWithoutReceivingReportInput, SupplierInvoiceUncheckedCreateWithoutReceivingReportInput> | SupplierInvoiceCreateWithoutReceivingReportInput[] | SupplierInvoiceUncheckedCreateWithoutReceivingReportInput[]
    connectOrCreate?: SupplierInvoiceCreateOrConnectWithoutReceivingReportInput | SupplierInvoiceCreateOrConnectWithoutReceivingReportInput[]
    createMany?: SupplierInvoiceCreateManyReceivingReportInputEnvelope
    connect?: SupplierInvoiceWhereUniqueInput | SupplierInvoiceWhereUniqueInput[]
  }

  export type ReceivingItemUncheckedCreateNestedManyWithoutReceivingReportInput = {
    create?: XOR<ReceivingItemCreateWithoutReceivingReportInput, ReceivingItemUncheckedCreateWithoutReceivingReportInput> | ReceivingItemCreateWithoutReceivingReportInput[] | ReceivingItemUncheckedCreateWithoutReceivingReportInput[]
    connectOrCreate?: ReceivingItemCreateOrConnectWithoutReceivingReportInput | ReceivingItemCreateOrConnectWithoutReceivingReportInput[]
    createMany?: ReceivingItemCreateManyReceivingReportInputEnvelope
    connect?: ReceivingItemWhereUniqueInput | ReceivingItemWhereUniqueInput[]
  }

  export type SupplierInvoiceUncheckedCreateNestedManyWithoutReceivingReportInput = {
    create?: XOR<SupplierInvoiceCreateWithoutReceivingReportInput, SupplierInvoiceUncheckedCreateWithoutReceivingReportInput> | SupplierInvoiceCreateWithoutReceivingReportInput[] | SupplierInvoiceUncheckedCreateWithoutReceivingReportInput[]
    connectOrCreate?: SupplierInvoiceCreateOrConnectWithoutReceivingReportInput | SupplierInvoiceCreateOrConnectWithoutReceivingReportInput[]
    createMany?: SupplierInvoiceCreateManyReceivingReportInputEnvelope
    connect?: SupplierInvoiceWhereUniqueInput | SupplierInvoiceWhereUniqueInput[]
  }

  export type PurchaseOrderUpdateOneRequiredWithoutReceivingNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutReceivingInput, PurchaseOrderUncheckedCreateWithoutReceivingInput>
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutReceivingInput
    upsert?: PurchaseOrderUpsertWithoutReceivingInput
    connect?: PurchaseOrderWhereUniqueInput
    update?: XOR<XOR<PurchaseOrderUpdateToOneWithWhereWithoutReceivingInput, PurchaseOrderUpdateWithoutReceivingInput>, PurchaseOrderUncheckedUpdateWithoutReceivingInput>
  }

  export type UserUpdateOneRequiredWithoutReceivedItemsNestedInput = {
    create?: XOR<UserCreateWithoutReceivedItemsInput, UserUncheckedCreateWithoutReceivedItemsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceivedItemsInput
    upsert?: UserUpsertWithoutReceivedItemsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReceivedItemsInput, UserUpdateWithoutReceivedItemsInput>, UserUncheckedUpdateWithoutReceivedItemsInput>
  }

  export type ReceivingItemUpdateManyWithoutReceivingReportNestedInput = {
    create?: XOR<ReceivingItemCreateWithoutReceivingReportInput, ReceivingItemUncheckedCreateWithoutReceivingReportInput> | ReceivingItemCreateWithoutReceivingReportInput[] | ReceivingItemUncheckedCreateWithoutReceivingReportInput[]
    connectOrCreate?: ReceivingItemCreateOrConnectWithoutReceivingReportInput | ReceivingItemCreateOrConnectWithoutReceivingReportInput[]
    upsert?: ReceivingItemUpsertWithWhereUniqueWithoutReceivingReportInput | ReceivingItemUpsertWithWhereUniqueWithoutReceivingReportInput[]
    createMany?: ReceivingItemCreateManyReceivingReportInputEnvelope
    set?: ReceivingItemWhereUniqueInput | ReceivingItemWhereUniqueInput[]
    disconnect?: ReceivingItemWhereUniqueInput | ReceivingItemWhereUniqueInput[]
    delete?: ReceivingItemWhereUniqueInput | ReceivingItemWhereUniqueInput[]
    connect?: ReceivingItemWhereUniqueInput | ReceivingItemWhereUniqueInput[]
    update?: ReceivingItemUpdateWithWhereUniqueWithoutReceivingReportInput | ReceivingItemUpdateWithWhereUniqueWithoutReceivingReportInput[]
    updateMany?: ReceivingItemUpdateManyWithWhereWithoutReceivingReportInput | ReceivingItemUpdateManyWithWhereWithoutReceivingReportInput[]
    deleteMany?: ReceivingItemScalarWhereInput | ReceivingItemScalarWhereInput[]
  }

  export type SupplierInvoiceUpdateManyWithoutReceivingReportNestedInput = {
    create?: XOR<SupplierInvoiceCreateWithoutReceivingReportInput, SupplierInvoiceUncheckedCreateWithoutReceivingReportInput> | SupplierInvoiceCreateWithoutReceivingReportInput[] | SupplierInvoiceUncheckedCreateWithoutReceivingReportInput[]
    connectOrCreate?: SupplierInvoiceCreateOrConnectWithoutReceivingReportInput | SupplierInvoiceCreateOrConnectWithoutReceivingReportInput[]
    upsert?: SupplierInvoiceUpsertWithWhereUniqueWithoutReceivingReportInput | SupplierInvoiceUpsertWithWhereUniqueWithoutReceivingReportInput[]
    createMany?: SupplierInvoiceCreateManyReceivingReportInputEnvelope
    set?: SupplierInvoiceWhereUniqueInput | SupplierInvoiceWhereUniqueInput[]
    disconnect?: SupplierInvoiceWhereUniqueInput | SupplierInvoiceWhereUniqueInput[]
    delete?: SupplierInvoiceWhereUniqueInput | SupplierInvoiceWhereUniqueInput[]
    connect?: SupplierInvoiceWhereUniqueInput | SupplierInvoiceWhereUniqueInput[]
    update?: SupplierInvoiceUpdateWithWhereUniqueWithoutReceivingReportInput | SupplierInvoiceUpdateWithWhereUniqueWithoutReceivingReportInput[]
    updateMany?: SupplierInvoiceUpdateManyWithWhereWithoutReceivingReportInput | SupplierInvoiceUpdateManyWithWhereWithoutReceivingReportInput[]
    deleteMany?: SupplierInvoiceScalarWhereInput | SupplierInvoiceScalarWhereInput[]
  }

  export type ReceivingItemUncheckedUpdateManyWithoutReceivingReportNestedInput = {
    create?: XOR<ReceivingItemCreateWithoutReceivingReportInput, ReceivingItemUncheckedCreateWithoutReceivingReportInput> | ReceivingItemCreateWithoutReceivingReportInput[] | ReceivingItemUncheckedCreateWithoutReceivingReportInput[]
    connectOrCreate?: ReceivingItemCreateOrConnectWithoutReceivingReportInput | ReceivingItemCreateOrConnectWithoutReceivingReportInput[]
    upsert?: ReceivingItemUpsertWithWhereUniqueWithoutReceivingReportInput | ReceivingItemUpsertWithWhereUniqueWithoutReceivingReportInput[]
    createMany?: ReceivingItemCreateManyReceivingReportInputEnvelope
    set?: ReceivingItemWhereUniqueInput | ReceivingItemWhereUniqueInput[]
    disconnect?: ReceivingItemWhereUniqueInput | ReceivingItemWhereUniqueInput[]
    delete?: ReceivingItemWhereUniqueInput | ReceivingItemWhereUniqueInput[]
    connect?: ReceivingItemWhereUniqueInput | ReceivingItemWhereUniqueInput[]
    update?: ReceivingItemUpdateWithWhereUniqueWithoutReceivingReportInput | ReceivingItemUpdateWithWhereUniqueWithoutReceivingReportInput[]
    updateMany?: ReceivingItemUpdateManyWithWhereWithoutReceivingReportInput | ReceivingItemUpdateManyWithWhereWithoutReceivingReportInput[]
    deleteMany?: ReceivingItemScalarWhereInput | ReceivingItemScalarWhereInput[]
  }

  export type SupplierInvoiceUncheckedUpdateManyWithoutReceivingReportNestedInput = {
    create?: XOR<SupplierInvoiceCreateWithoutReceivingReportInput, SupplierInvoiceUncheckedCreateWithoutReceivingReportInput> | SupplierInvoiceCreateWithoutReceivingReportInput[] | SupplierInvoiceUncheckedCreateWithoutReceivingReportInput[]
    connectOrCreate?: SupplierInvoiceCreateOrConnectWithoutReceivingReportInput | SupplierInvoiceCreateOrConnectWithoutReceivingReportInput[]
    upsert?: SupplierInvoiceUpsertWithWhereUniqueWithoutReceivingReportInput | SupplierInvoiceUpsertWithWhereUniqueWithoutReceivingReportInput[]
    createMany?: SupplierInvoiceCreateManyReceivingReportInputEnvelope
    set?: SupplierInvoiceWhereUniqueInput | SupplierInvoiceWhereUniqueInput[]
    disconnect?: SupplierInvoiceWhereUniqueInput | SupplierInvoiceWhereUniqueInput[]
    delete?: SupplierInvoiceWhereUniqueInput | SupplierInvoiceWhereUniqueInput[]
    connect?: SupplierInvoiceWhereUniqueInput | SupplierInvoiceWhereUniqueInput[]
    update?: SupplierInvoiceUpdateWithWhereUniqueWithoutReceivingReportInput | SupplierInvoiceUpdateWithWhereUniqueWithoutReceivingReportInput[]
    updateMany?: SupplierInvoiceUpdateManyWithWhereWithoutReceivingReportInput | SupplierInvoiceUpdateManyWithWhereWithoutReceivingReportInput[]
    deleteMany?: SupplierInvoiceScalarWhereInput | SupplierInvoiceScalarWhereInput[]
  }

  export type ReceivingReportCreateNestedOneWithoutItemsInput = {
    create?: XOR<ReceivingReportCreateWithoutItemsInput, ReceivingReportUncheckedCreateWithoutItemsInput>
    connectOrCreate?: ReceivingReportCreateOrConnectWithoutItemsInput
    connect?: ReceivingReportWhereUniqueInput
  }

  export type ReceivingReportUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<ReceivingReportCreateWithoutItemsInput, ReceivingReportUncheckedCreateWithoutItemsInput>
    connectOrCreate?: ReceivingReportCreateOrConnectWithoutItemsInput
    upsert?: ReceivingReportUpsertWithoutItemsInput
    connect?: ReceivingReportWhereUniqueInput
    update?: XOR<XOR<ReceivingReportUpdateToOneWithWhereWithoutItemsInput, ReceivingReportUpdateWithoutItemsInput>, ReceivingReportUncheckedUpdateWithoutItemsInput>
  }

  export type ProjectCreateNestedOneWithoutInventoryInput = {
    create?: XOR<ProjectCreateWithoutInventoryInput, ProjectUncheckedCreateWithoutInventoryInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutInventoryInput
    connect?: ProjectWhereUniqueInput
  }

  export type WarehouseCreateNestedOneWithoutInventoryInput = {
    create?: XOR<WarehouseCreateWithoutInventoryInput, WarehouseUncheckedCreateWithoutInventoryInput>
    connectOrCreate?: WarehouseCreateOrConnectWithoutInventoryInput
    connect?: WarehouseWhereUniqueInput
  }

  export type ProjectUpdateOneWithoutInventoryNestedInput = {
    create?: XOR<ProjectCreateWithoutInventoryInput, ProjectUncheckedCreateWithoutInventoryInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutInventoryInput
    upsert?: ProjectUpsertWithoutInventoryInput
    disconnect?: ProjectWhereInput | boolean
    delete?: ProjectWhereInput | boolean
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutInventoryInput, ProjectUpdateWithoutInventoryInput>, ProjectUncheckedUpdateWithoutInventoryInput>
  }

  export type WarehouseUpdateOneWithoutInventoryNestedInput = {
    create?: XOR<WarehouseCreateWithoutInventoryInput, WarehouseUncheckedCreateWithoutInventoryInput>
    connectOrCreate?: WarehouseCreateOrConnectWithoutInventoryInput
    upsert?: WarehouseUpsertWithoutInventoryInput
    disconnect?: WarehouseWhereInput | boolean
    delete?: WarehouseWhereInput | boolean
    connect?: WarehouseWhereUniqueInput
    update?: XOR<XOR<WarehouseUpdateToOneWithWhereWithoutInventoryInput, WarehouseUpdateWithoutInventoryInput>, WarehouseUncheckedUpdateWithoutInventoryInput>
  }

  export type SupplierCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<SupplierCreateWithoutInvoicesInput, SupplierUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutInvoicesInput
    connect?: SupplierWhereUniqueInput
  }

  export type PurchaseOrderCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<PurchaseOrderCreateWithoutInvoicesInput, PurchaseOrderUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutInvoicesInput
    connect?: PurchaseOrderWhereUniqueInput
  }

  export type ReceivingReportCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<ReceivingReportCreateWithoutInvoicesInput, ReceivingReportUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: ReceivingReportCreateOrConnectWithoutInvoicesInput
    connect?: ReceivingReportWhereUniqueInput
  }

  export type SupplierUpdateOneRequiredWithoutInvoicesNestedInput = {
    create?: XOR<SupplierCreateWithoutInvoicesInput, SupplierUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutInvoicesInput
    upsert?: SupplierUpsertWithoutInvoicesInput
    connect?: SupplierWhereUniqueInput
    update?: XOR<XOR<SupplierUpdateToOneWithWhereWithoutInvoicesInput, SupplierUpdateWithoutInvoicesInput>, SupplierUncheckedUpdateWithoutInvoicesInput>
  }

  export type PurchaseOrderUpdateOneWithoutInvoicesNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutInvoicesInput, PurchaseOrderUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutInvoicesInput
    upsert?: PurchaseOrderUpsertWithoutInvoicesInput
    disconnect?: PurchaseOrderWhereInput | boolean
    delete?: PurchaseOrderWhereInput | boolean
    connect?: PurchaseOrderWhereUniqueInput
    update?: XOR<XOR<PurchaseOrderUpdateToOneWithWhereWithoutInvoicesInput, PurchaseOrderUpdateWithoutInvoicesInput>, PurchaseOrderUncheckedUpdateWithoutInvoicesInput>
  }

  export type ReceivingReportUpdateOneWithoutInvoicesNestedInput = {
    create?: XOR<ReceivingReportCreateWithoutInvoicesInput, ReceivingReportUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: ReceivingReportCreateOrConnectWithoutInvoicesInput
    upsert?: ReceivingReportUpsertWithoutInvoicesInput
    disconnect?: ReceivingReportWhereInput | boolean
    delete?: ReceivingReportWhereInput | boolean
    connect?: ReceivingReportWhereUniqueInput
    update?: XOR<XOR<ReceivingReportUpdateToOneWithWhereWithoutInvoicesInput, ReceivingReportUpdateWithoutInvoicesInput>, ReceivingReportUncheckedUpdateWithoutInvoicesInput>
  }

  export type PurchaseOrderCreateNestedOneWithoutDisbursementsInput = {
    create?: XOR<PurchaseOrderCreateWithoutDisbursementsInput, PurchaseOrderUncheckedCreateWithoutDisbursementsInput>
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutDisbursementsInput
    connect?: PurchaseOrderWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutDisbursementsInput = {
    create?: XOR<UserCreateWithoutDisbursementsInput, UserUncheckedCreateWithoutDisbursementsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDisbursementsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumPaymentMethodFieldUpdateOperationsInput = {
    set?: $Enums.PaymentMethod
  }

  export type PurchaseOrderUpdateOneWithoutDisbursementsNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutDisbursementsInput, PurchaseOrderUncheckedCreateWithoutDisbursementsInput>
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutDisbursementsInput
    upsert?: PurchaseOrderUpsertWithoutDisbursementsInput
    disconnect?: PurchaseOrderWhereInput | boolean
    delete?: PurchaseOrderWhereInput | boolean
    connect?: PurchaseOrderWhereUniqueInput
    update?: XOR<XOR<PurchaseOrderUpdateToOneWithWhereWithoutDisbursementsInput, PurchaseOrderUpdateWithoutDisbursementsInput>, PurchaseOrderUncheckedUpdateWithoutDisbursementsInput>
  }

  export type UserUpdateOneRequiredWithoutDisbursementsNestedInput = {
    create?: XOR<UserCreateWithoutDisbursementsInput, UserUncheckedCreateWithoutDisbursementsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDisbursementsInput
    upsert?: UserUpsertWithoutDisbursementsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDisbursementsInput, UserUpdateWithoutDisbursementsInput>, UserUncheckedUpdateWithoutDisbursementsInput>
  }

  export type ProjectCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<ProjectCreateWithoutTransactionsInput, ProjectUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutTransactionsInput
    connect?: ProjectWhereUniqueInput
  }

  export type ProjectUpdateOneWithoutTransactionsNestedInput = {
    create?: XOR<ProjectCreateWithoutTransactionsInput, ProjectUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutTransactionsInput
    upsert?: ProjectUpsertWithoutTransactionsInput
    disconnect?: ProjectWhereInput | boolean
    delete?: ProjectWhereInput | boolean
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutTransactionsInput, ProjectUpdateWithoutTransactionsInput>, ProjectUncheckedUpdateWithoutTransactionsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[]
    notIn?: $Enums.UserRole[]
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[]
    notIn?: $Enums.UserRole[]
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumResourceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ResourceType | EnumResourceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ResourceType[]
    notIn?: $Enums.ResourceType[]
    not?: NestedEnumResourceTypeFilter<$PrismaModel> | $Enums.ResourceType
  }

  export type NestedEnumResourceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ResourceType | EnumResourceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ResourceType[]
    notIn?: $Enums.ResourceType[]
    not?: NestedEnumResourceTypeWithAggregatesFilter<$PrismaModel> | $Enums.ResourceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumResourceTypeFilter<$PrismaModel>
    _max?: NestedEnumResourceTypeFilter<$PrismaModel>
  }

  export type NestedEnumMrStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MrStatus | EnumMrStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MrStatus[]
    notIn?: $Enums.MrStatus[]
    not?: NestedEnumMrStatusFilter<$PrismaModel> | $Enums.MrStatus
  }

  export type NestedEnumMrStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MrStatus | EnumMrStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MrStatus[]
    notIn?: $Enums.MrStatus[]
    not?: NestedEnumMrStatusWithAggregatesFilter<$PrismaModel> | $Enums.MrStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMrStatusFilter<$PrismaModel>
    _max?: NestedEnumMrStatusFilter<$PrismaModel>
  }

  export type NestedEnumRfqStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RfqStatus | EnumRfqStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RfqStatus[]
    notIn?: $Enums.RfqStatus[]
    not?: NestedEnumRfqStatusFilter<$PrismaModel> | $Enums.RfqStatus
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumRfqStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RfqStatus | EnumRfqStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RfqStatus[]
    notIn?: $Enums.RfqStatus[]
    not?: NestedEnumRfqStatusWithAggregatesFilter<$PrismaModel> | $Enums.RfqStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRfqStatusFilter<$PrismaModel>
    _max?: NestedEnumRfqStatusFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumPoStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PoStatus | EnumPoStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PoStatus[]
    notIn?: $Enums.PoStatus[]
    not?: NestedEnumPoStatusFilter<$PrismaModel> | $Enums.PoStatus
  }

  export type NestedEnumPoStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PoStatus | EnumPoStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PoStatus[]
    notIn?: $Enums.PoStatus[]
    not?: NestedEnumPoStatusWithAggregatesFilter<$PrismaModel> | $Enums.PoStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPoStatusFilter<$PrismaModel>
    _max?: NestedEnumPoStatusFilter<$PrismaModel>
  }

  export type NestedEnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[]
    notIn?: $Enums.PaymentMethod[]
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[]
    notIn?: $Enums.PaymentMethod[]
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type PurchaseOrderCreateWithoutRequesterInput = {
    orderDate?: Date | string
    status?: $Enums.PoStatus
    remarks?: string | null
    totalAmount?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutPurchaseOrdersInput
    supplier?: SupplierCreateNestedOneWithoutPurchaseOrdersInput
    approver?: UserCreateNestedOneWithoutPoApprovalsInput
    items?: PurchaseOrderItemCreateNestedManyWithoutPurchaseOrderInput
    receiving?: ReceivingReportCreateNestedManyWithoutPurchaseOrderInput
    invoices?: SupplierInvoiceCreateNestedManyWithoutPurchaseOrderInput
    disbursements?: DisbursementCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseOrderUncheckedCreateWithoutRequesterInput = {
    id?: number
    orderDate?: Date | string
    projectId: number
    supplierId?: number | null
    approverId?: number | null
    status?: $Enums.PoStatus
    remarks?: string | null
    totalAmount?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: PurchaseOrderItemUncheckedCreateNestedManyWithoutPurchaseOrderInput
    receiving?: ReceivingReportUncheckedCreateNestedManyWithoutPurchaseOrderInput
    invoices?: SupplierInvoiceUncheckedCreateNestedManyWithoutPurchaseOrderInput
    disbursements?: DisbursementUncheckedCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseOrderCreateOrConnectWithoutRequesterInput = {
    where: PurchaseOrderWhereUniqueInput
    create: XOR<PurchaseOrderCreateWithoutRequesterInput, PurchaseOrderUncheckedCreateWithoutRequesterInput>
  }

  export type PurchaseOrderCreateManyRequesterInputEnvelope = {
    data: PurchaseOrderCreateManyRequesterInput | PurchaseOrderCreateManyRequesterInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseOrderCreateWithoutApproverInput = {
    orderDate?: Date | string
    status?: $Enums.PoStatus
    remarks?: string | null
    totalAmount?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutPurchaseOrdersInput
    supplier?: SupplierCreateNestedOneWithoutPurchaseOrdersInput
    requester: UserCreateNestedOneWithoutPurchaseOrdersInput
    items?: PurchaseOrderItemCreateNestedManyWithoutPurchaseOrderInput
    receiving?: ReceivingReportCreateNestedManyWithoutPurchaseOrderInput
    invoices?: SupplierInvoiceCreateNestedManyWithoutPurchaseOrderInput
    disbursements?: DisbursementCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseOrderUncheckedCreateWithoutApproverInput = {
    id?: number
    orderDate?: Date | string
    projectId: number
    supplierId?: number | null
    requesterId: number
    status?: $Enums.PoStatus
    remarks?: string | null
    totalAmount?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: PurchaseOrderItemUncheckedCreateNestedManyWithoutPurchaseOrderInput
    receiving?: ReceivingReportUncheckedCreateNestedManyWithoutPurchaseOrderInput
    invoices?: SupplierInvoiceUncheckedCreateNestedManyWithoutPurchaseOrderInput
    disbursements?: DisbursementUncheckedCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseOrderCreateOrConnectWithoutApproverInput = {
    where: PurchaseOrderWhereUniqueInput
    create: XOR<PurchaseOrderCreateWithoutApproverInput, PurchaseOrderUncheckedCreateWithoutApproverInput>
  }

  export type PurchaseOrderCreateManyApproverInputEnvelope = {
    data: PurchaseOrderCreateManyApproverInput | PurchaseOrderCreateManyApproverInput[]
    skipDuplicates?: boolean
  }

  export type MaterialRequestCreateWithoutRequesterInput = {
    requestDate?: Date | string
    status?: $Enums.MrStatus
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutMaterialRequestsInput
    approver?: UserCreateNestedOneWithoutMrApprovalsInput
    items?: MaterialRequestItemCreateNestedManyWithoutMaterialRequestInput
    rfqs?: RFQCreateNestedManyWithoutMaterialRequestInput
  }

  export type MaterialRequestUncheckedCreateWithoutRequesterInput = {
    id?: number
    projectId: number
    approverId?: number | null
    requestDate?: Date | string
    status?: $Enums.MrStatus
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: MaterialRequestItemUncheckedCreateNestedManyWithoutMaterialRequestInput
    rfqs?: RFQUncheckedCreateNestedManyWithoutMaterialRequestInput
  }

  export type MaterialRequestCreateOrConnectWithoutRequesterInput = {
    where: MaterialRequestWhereUniqueInput
    create: XOR<MaterialRequestCreateWithoutRequesterInput, MaterialRequestUncheckedCreateWithoutRequesterInput>
  }

  export type MaterialRequestCreateManyRequesterInputEnvelope = {
    data: MaterialRequestCreateManyRequesterInput | MaterialRequestCreateManyRequesterInput[]
    skipDuplicates?: boolean
  }

  export type MaterialRequestCreateWithoutApproverInput = {
    requestDate?: Date | string
    status?: $Enums.MrStatus
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutMaterialRequestsInput
    requester: UserCreateNestedOneWithoutMaterialRequestsInput
    items?: MaterialRequestItemCreateNestedManyWithoutMaterialRequestInput
    rfqs?: RFQCreateNestedManyWithoutMaterialRequestInput
  }

  export type MaterialRequestUncheckedCreateWithoutApproverInput = {
    id?: number
    projectId: number
    requesterId: number
    requestDate?: Date | string
    status?: $Enums.MrStatus
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: MaterialRequestItemUncheckedCreateNestedManyWithoutMaterialRequestInput
    rfqs?: RFQUncheckedCreateNestedManyWithoutMaterialRequestInput
  }

  export type MaterialRequestCreateOrConnectWithoutApproverInput = {
    where: MaterialRequestWhereUniqueInput
    create: XOR<MaterialRequestCreateWithoutApproverInput, MaterialRequestUncheckedCreateWithoutApproverInput>
  }

  export type MaterialRequestCreateManyApproverInputEnvelope = {
    data: MaterialRequestCreateManyApproverInput | MaterialRequestCreateManyApproverInput[]
    skipDuplicates?: boolean
  }

  export type RFQCreateWithoutCreatedByInput = {
    title: string
    status?: $Enums.RfqStatus
    dueDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    materialRequest?: MaterialRequestCreateNestedOneWithoutRfqsInput
    items?: RFQItemCreateNestedManyWithoutRfqInput
    quotations?: SupplierQuotationCreateNestedManyWithoutRfqInput
  }

  export type RFQUncheckedCreateWithoutCreatedByInput = {
    id?: number
    mrId?: number | null
    title: string
    status?: $Enums.RfqStatus
    dueDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: RFQItemUncheckedCreateNestedManyWithoutRfqInput
    quotations?: SupplierQuotationUncheckedCreateNestedManyWithoutRfqInput
  }

  export type RFQCreateOrConnectWithoutCreatedByInput = {
    where: RFQWhereUniqueInput
    create: XOR<RFQCreateWithoutCreatedByInput, RFQUncheckedCreateWithoutCreatedByInput>
  }

  export type RFQCreateManyCreatedByInputEnvelope = {
    data: RFQCreateManyCreatedByInput | RFQCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type ReceivingReportCreateWithoutReceivedByInput = {
    receivedDate?: Date | string
    deliveryNoteNo?: string | null
    notes?: string | null
    purchaseOrder: PurchaseOrderCreateNestedOneWithoutReceivingInput
    items?: ReceivingItemCreateNestedManyWithoutReceivingReportInput
    invoices?: SupplierInvoiceCreateNestedManyWithoutReceivingReportInput
  }

  export type ReceivingReportUncheckedCreateWithoutReceivedByInput = {
    id?: number
    purchaseOrderId: number
    receivedDate?: Date | string
    deliveryNoteNo?: string | null
    notes?: string | null
    items?: ReceivingItemUncheckedCreateNestedManyWithoutReceivingReportInput
    invoices?: SupplierInvoiceUncheckedCreateNestedManyWithoutReceivingReportInput
  }

  export type ReceivingReportCreateOrConnectWithoutReceivedByInput = {
    where: ReceivingReportWhereUniqueInput
    create: XOR<ReceivingReportCreateWithoutReceivedByInput, ReceivingReportUncheckedCreateWithoutReceivedByInput>
  }

  export type ReceivingReportCreateManyReceivedByInputEnvelope = {
    data: ReceivingReportCreateManyReceivedByInput | ReceivingReportCreateManyReceivedByInput[]
    skipDuplicates?: boolean
  }

  export type DisbursementCreateWithoutProcessedByInput = {
    amount: Decimal | DecimalJsLike | number | string
    paymentDate?: Date | string
    method: $Enums.PaymentMethod
    referenceNumber?: string | null
    status?: string
    purchaseOrder?: PurchaseOrderCreateNestedOneWithoutDisbursementsInput
  }

  export type DisbursementUncheckedCreateWithoutProcessedByInput = {
    id?: number
    purchaseOrderId?: number | null
    amount: Decimal | DecimalJsLike | number | string
    paymentDate?: Date | string
    method: $Enums.PaymentMethod
    referenceNumber?: string | null
    status?: string
  }

  export type DisbursementCreateOrConnectWithoutProcessedByInput = {
    where: DisbursementWhereUniqueInput
    create: XOR<DisbursementCreateWithoutProcessedByInput, DisbursementUncheckedCreateWithoutProcessedByInput>
  }

  export type DisbursementCreateManyProcessedByInputEnvelope = {
    data: DisbursementCreateManyProcessedByInput | DisbursementCreateManyProcessedByInput[]
    skipDuplicates?: boolean
  }

  export type ProjectMemberCreateWithoutUserInput = {
    role: string
    assignedAt?: Date | string
    project: ProjectCreateNestedOneWithoutTeamMembersInput
  }

  export type ProjectMemberUncheckedCreateWithoutUserInput = {
    id?: number
    projectId: number
    role: string
    assignedAt?: Date | string
  }

  export type ProjectMemberCreateOrConnectWithoutUserInput = {
    where: ProjectMemberWhereUniqueInput
    create: XOR<ProjectMemberCreateWithoutUserInput, ProjectMemberUncheckedCreateWithoutUserInput>
  }

  export type ProjectMemberCreateManyUserInputEnvelope = {
    data: ProjectMemberCreateManyUserInput | ProjectMemberCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseOrderUpsertWithWhereUniqueWithoutRequesterInput = {
    where: PurchaseOrderWhereUniqueInput
    update: XOR<PurchaseOrderUpdateWithoutRequesterInput, PurchaseOrderUncheckedUpdateWithoutRequesterInput>
    create: XOR<PurchaseOrderCreateWithoutRequesterInput, PurchaseOrderUncheckedCreateWithoutRequesterInput>
  }

  export type PurchaseOrderUpdateWithWhereUniqueWithoutRequesterInput = {
    where: PurchaseOrderWhereUniqueInput
    data: XOR<PurchaseOrderUpdateWithoutRequesterInput, PurchaseOrderUncheckedUpdateWithoutRequesterInput>
  }

  export type PurchaseOrderUpdateManyWithWhereWithoutRequesterInput = {
    where: PurchaseOrderScalarWhereInput
    data: XOR<PurchaseOrderUpdateManyMutationInput, PurchaseOrderUncheckedUpdateManyWithoutRequesterInput>
  }

  export type PurchaseOrderScalarWhereInput = {
    AND?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
    OR?: PurchaseOrderScalarWhereInput[]
    NOT?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
    id?: IntFilter<"PurchaseOrder"> | number
    orderDate?: DateTimeFilter<"PurchaseOrder"> | Date | string
    projectId?: IntFilter<"PurchaseOrder"> | number
    supplierId?: IntNullableFilter<"PurchaseOrder"> | number | null
    requesterId?: IntFilter<"PurchaseOrder"> | number
    approverId?: IntNullableFilter<"PurchaseOrder"> | number | null
    status?: EnumPoStatusFilter<"PurchaseOrder"> | $Enums.PoStatus
    remarks?: StringNullableFilter<"PurchaseOrder"> | string | null
    totalAmount?: DecimalFilter<"PurchaseOrder"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"PurchaseOrder"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseOrder"> | Date | string
  }

  export type PurchaseOrderUpsertWithWhereUniqueWithoutApproverInput = {
    where: PurchaseOrderWhereUniqueInput
    update: XOR<PurchaseOrderUpdateWithoutApproverInput, PurchaseOrderUncheckedUpdateWithoutApproverInput>
    create: XOR<PurchaseOrderCreateWithoutApproverInput, PurchaseOrderUncheckedCreateWithoutApproverInput>
  }

  export type PurchaseOrderUpdateWithWhereUniqueWithoutApproverInput = {
    where: PurchaseOrderWhereUniqueInput
    data: XOR<PurchaseOrderUpdateWithoutApproverInput, PurchaseOrderUncheckedUpdateWithoutApproverInput>
  }

  export type PurchaseOrderUpdateManyWithWhereWithoutApproverInput = {
    where: PurchaseOrderScalarWhereInput
    data: XOR<PurchaseOrderUpdateManyMutationInput, PurchaseOrderUncheckedUpdateManyWithoutApproverInput>
  }

  export type MaterialRequestUpsertWithWhereUniqueWithoutRequesterInput = {
    where: MaterialRequestWhereUniqueInput
    update: XOR<MaterialRequestUpdateWithoutRequesterInput, MaterialRequestUncheckedUpdateWithoutRequesterInput>
    create: XOR<MaterialRequestCreateWithoutRequesterInput, MaterialRequestUncheckedCreateWithoutRequesterInput>
  }

  export type MaterialRequestUpdateWithWhereUniqueWithoutRequesterInput = {
    where: MaterialRequestWhereUniqueInput
    data: XOR<MaterialRequestUpdateWithoutRequesterInput, MaterialRequestUncheckedUpdateWithoutRequesterInput>
  }

  export type MaterialRequestUpdateManyWithWhereWithoutRequesterInput = {
    where: MaterialRequestScalarWhereInput
    data: XOR<MaterialRequestUpdateManyMutationInput, MaterialRequestUncheckedUpdateManyWithoutRequesterInput>
  }

  export type MaterialRequestScalarWhereInput = {
    AND?: MaterialRequestScalarWhereInput | MaterialRequestScalarWhereInput[]
    OR?: MaterialRequestScalarWhereInput[]
    NOT?: MaterialRequestScalarWhereInput | MaterialRequestScalarWhereInput[]
    id?: IntFilter<"MaterialRequest"> | number
    projectId?: IntFilter<"MaterialRequest"> | number
    requesterId?: IntFilter<"MaterialRequest"> | number
    approverId?: IntNullableFilter<"MaterialRequest"> | number | null
    requestDate?: DateTimeFilter<"MaterialRequest"> | Date | string
    status?: EnumMrStatusFilter<"MaterialRequest"> | $Enums.MrStatus
    remarks?: StringNullableFilter<"MaterialRequest"> | string | null
    createdAt?: DateTimeFilter<"MaterialRequest"> | Date | string
    updatedAt?: DateTimeFilter<"MaterialRequest"> | Date | string
  }

  export type MaterialRequestUpsertWithWhereUniqueWithoutApproverInput = {
    where: MaterialRequestWhereUniqueInput
    update: XOR<MaterialRequestUpdateWithoutApproverInput, MaterialRequestUncheckedUpdateWithoutApproverInput>
    create: XOR<MaterialRequestCreateWithoutApproverInput, MaterialRequestUncheckedCreateWithoutApproverInput>
  }

  export type MaterialRequestUpdateWithWhereUniqueWithoutApproverInput = {
    where: MaterialRequestWhereUniqueInput
    data: XOR<MaterialRequestUpdateWithoutApproverInput, MaterialRequestUncheckedUpdateWithoutApproverInput>
  }

  export type MaterialRequestUpdateManyWithWhereWithoutApproverInput = {
    where: MaterialRequestScalarWhereInput
    data: XOR<MaterialRequestUpdateManyMutationInput, MaterialRequestUncheckedUpdateManyWithoutApproverInput>
  }

  export type RFQUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: RFQWhereUniqueInput
    update: XOR<RFQUpdateWithoutCreatedByInput, RFQUncheckedUpdateWithoutCreatedByInput>
    create: XOR<RFQCreateWithoutCreatedByInput, RFQUncheckedCreateWithoutCreatedByInput>
  }

  export type RFQUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: RFQWhereUniqueInput
    data: XOR<RFQUpdateWithoutCreatedByInput, RFQUncheckedUpdateWithoutCreatedByInput>
  }

  export type RFQUpdateManyWithWhereWithoutCreatedByInput = {
    where: RFQScalarWhereInput
    data: XOR<RFQUpdateManyMutationInput, RFQUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type RFQScalarWhereInput = {
    AND?: RFQScalarWhereInput | RFQScalarWhereInput[]
    OR?: RFQScalarWhereInput[]
    NOT?: RFQScalarWhereInput | RFQScalarWhereInput[]
    id?: IntFilter<"RFQ"> | number
    mrId?: IntNullableFilter<"RFQ"> | number | null
    createdById?: IntFilter<"RFQ"> | number
    title?: StringFilter<"RFQ"> | string
    status?: EnumRfqStatusFilter<"RFQ"> | $Enums.RfqStatus
    dueDate?: DateTimeNullableFilter<"RFQ"> | Date | string | null
    createdAt?: DateTimeFilter<"RFQ"> | Date | string
    updatedAt?: DateTimeFilter<"RFQ"> | Date | string
  }

  export type ReceivingReportUpsertWithWhereUniqueWithoutReceivedByInput = {
    where: ReceivingReportWhereUniqueInput
    update: XOR<ReceivingReportUpdateWithoutReceivedByInput, ReceivingReportUncheckedUpdateWithoutReceivedByInput>
    create: XOR<ReceivingReportCreateWithoutReceivedByInput, ReceivingReportUncheckedCreateWithoutReceivedByInput>
  }

  export type ReceivingReportUpdateWithWhereUniqueWithoutReceivedByInput = {
    where: ReceivingReportWhereUniqueInput
    data: XOR<ReceivingReportUpdateWithoutReceivedByInput, ReceivingReportUncheckedUpdateWithoutReceivedByInput>
  }

  export type ReceivingReportUpdateManyWithWhereWithoutReceivedByInput = {
    where: ReceivingReportScalarWhereInput
    data: XOR<ReceivingReportUpdateManyMutationInput, ReceivingReportUncheckedUpdateManyWithoutReceivedByInput>
  }

  export type ReceivingReportScalarWhereInput = {
    AND?: ReceivingReportScalarWhereInput | ReceivingReportScalarWhereInput[]
    OR?: ReceivingReportScalarWhereInput[]
    NOT?: ReceivingReportScalarWhereInput | ReceivingReportScalarWhereInput[]
    id?: IntFilter<"ReceivingReport"> | number
    purchaseOrderId?: IntFilter<"ReceivingReport"> | number
    receivedById?: IntFilter<"ReceivingReport"> | number
    receivedDate?: DateTimeFilter<"ReceivingReport"> | Date | string
    deliveryNoteNo?: StringNullableFilter<"ReceivingReport"> | string | null
    notes?: StringNullableFilter<"ReceivingReport"> | string | null
  }

  export type DisbursementUpsertWithWhereUniqueWithoutProcessedByInput = {
    where: DisbursementWhereUniqueInput
    update: XOR<DisbursementUpdateWithoutProcessedByInput, DisbursementUncheckedUpdateWithoutProcessedByInput>
    create: XOR<DisbursementCreateWithoutProcessedByInput, DisbursementUncheckedCreateWithoutProcessedByInput>
  }

  export type DisbursementUpdateWithWhereUniqueWithoutProcessedByInput = {
    where: DisbursementWhereUniqueInput
    data: XOR<DisbursementUpdateWithoutProcessedByInput, DisbursementUncheckedUpdateWithoutProcessedByInput>
  }

  export type DisbursementUpdateManyWithWhereWithoutProcessedByInput = {
    where: DisbursementScalarWhereInput
    data: XOR<DisbursementUpdateManyMutationInput, DisbursementUncheckedUpdateManyWithoutProcessedByInput>
  }

  export type DisbursementScalarWhereInput = {
    AND?: DisbursementScalarWhereInput | DisbursementScalarWhereInput[]
    OR?: DisbursementScalarWhereInput[]
    NOT?: DisbursementScalarWhereInput | DisbursementScalarWhereInput[]
    id?: IntFilter<"Disbursement"> | number
    purchaseOrderId?: IntNullableFilter<"Disbursement"> | number | null
    processedById?: IntFilter<"Disbursement"> | number
    amount?: DecimalFilter<"Disbursement"> | Decimal | DecimalJsLike | number | string
    paymentDate?: DateTimeFilter<"Disbursement"> | Date | string
    method?: EnumPaymentMethodFilter<"Disbursement"> | $Enums.PaymentMethod
    referenceNumber?: StringNullableFilter<"Disbursement"> | string | null
    status?: StringFilter<"Disbursement"> | string
  }

  export type ProjectMemberUpsertWithWhereUniqueWithoutUserInput = {
    where: ProjectMemberWhereUniqueInput
    update: XOR<ProjectMemberUpdateWithoutUserInput, ProjectMemberUncheckedUpdateWithoutUserInput>
    create: XOR<ProjectMemberCreateWithoutUserInput, ProjectMemberUncheckedCreateWithoutUserInput>
  }

  export type ProjectMemberUpdateWithWhereUniqueWithoutUserInput = {
    where: ProjectMemberWhereUniqueInput
    data: XOR<ProjectMemberUpdateWithoutUserInput, ProjectMemberUncheckedUpdateWithoutUserInput>
  }

  export type ProjectMemberUpdateManyWithWhereWithoutUserInput = {
    where: ProjectMemberScalarWhereInput
    data: XOR<ProjectMemberUpdateManyMutationInput, ProjectMemberUncheckedUpdateManyWithoutUserInput>
  }

  export type ProjectMemberScalarWhereInput = {
    AND?: ProjectMemberScalarWhereInput | ProjectMemberScalarWhereInput[]
    OR?: ProjectMemberScalarWhereInput[]
    NOT?: ProjectMemberScalarWhereInput | ProjectMemberScalarWhereInput[]
    id?: IntFilter<"ProjectMember"> | number
    projectId?: IntFilter<"ProjectMember"> | number
    userId?: IntFilter<"ProjectMember"> | number
    role?: StringFilter<"ProjectMember"> | string
    assignedAt?: DateTimeFilter<"ProjectMember"> | Date | string
  }

  export type ProjectCreateWithoutClientInput = {
    name: string
    location?: string | null
    duration?: string | null
    budget: Decimal | DecimalJsLike | number | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    totalFloorArea?: Decimal | DecimalJsLike | number | string | null
    carportArea?: Decimal | DecimalJsLike | number | string | null
    transactions?: FinancialTransactionCreateNestedManyWithoutProjectInput
    inventory?: InventoryItemCreateNestedManyWithoutProjectInput
    teamMembers?: ProjectMemberCreateNestedManyWithoutProjectInput
    boqItems?: BoqItemCreateNestedManyWithoutProjectInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutProjectInput
    materialRequests?: MaterialRequestCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutClientInput = {
    id?: number
    name: string
    location?: string | null
    duration?: string | null
    budget: Decimal | DecimalJsLike | number | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    totalFloorArea?: Decimal | DecimalJsLike | number | string | null
    carportArea?: Decimal | DecimalJsLike | number | string | null
    transactions?: FinancialTransactionUncheckedCreateNestedManyWithoutProjectInput
    inventory?: InventoryItemUncheckedCreateNestedManyWithoutProjectInput
    teamMembers?: ProjectMemberUncheckedCreateNestedManyWithoutProjectInput
    boqItems?: BoqItemUncheckedCreateNestedManyWithoutProjectInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutProjectInput
    materialRequests?: MaterialRequestUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutClientInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutClientInput, ProjectUncheckedCreateWithoutClientInput>
  }

  export type ProjectCreateManyClientInputEnvelope = {
    data: ProjectCreateManyClientInput | ProjectCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type ProjectUpsertWithWhereUniqueWithoutClientInput = {
    where: ProjectWhereUniqueInput
    update: XOR<ProjectUpdateWithoutClientInput, ProjectUncheckedUpdateWithoutClientInput>
    create: XOR<ProjectCreateWithoutClientInput, ProjectUncheckedCreateWithoutClientInput>
  }

  export type ProjectUpdateWithWhereUniqueWithoutClientInput = {
    where: ProjectWhereUniqueInput
    data: XOR<ProjectUpdateWithoutClientInput, ProjectUncheckedUpdateWithoutClientInput>
  }

  export type ProjectUpdateManyWithWhereWithoutClientInput = {
    where: ProjectScalarWhereInput
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyWithoutClientInput>
  }

  export type ProjectScalarWhereInput = {
    AND?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
    OR?: ProjectScalarWhereInput[]
    NOT?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
    id?: IntFilter<"Project"> | number
    clientId?: IntNullableFilter<"Project"> | number | null
    name?: StringFilter<"Project"> | string
    location?: StringNullableFilter<"Project"> | string | null
    duration?: StringNullableFilter<"Project"> | string | null
    budget?: DecimalFilter<"Project"> | Decimal | DecimalJsLike | number | string
    status?: StringFilter<"Project"> | string
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    totalFloorArea?: DecimalNullableFilter<"Project"> | Decimal | DecimalJsLike | number | string | null
    carportArea?: DecimalNullableFilter<"Project"> | Decimal | DecimalJsLike | number | string | null
  }

  export type ClientCreateWithoutProjectsInput = {
    name: string
    contactPerson?: string | null
    contractType?: string | null
    paymentTerms?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientUncheckedCreateWithoutProjectsInput = {
    id?: number
    name: string
    contactPerson?: string | null
    contractType?: string | null
    paymentTerms?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientCreateOrConnectWithoutProjectsInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutProjectsInput, ClientUncheckedCreateWithoutProjectsInput>
  }

  export type FinancialTransactionCreateWithoutProjectInput = {
    date?: Date | string
    type: string
    category: string
    description?: string | null
    amount: Decimal | DecimalJsLike | number | string
    reference?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type FinancialTransactionUncheckedCreateWithoutProjectInput = {
    id?: number
    date?: Date | string
    type: string
    category: string
    description?: string | null
    amount: Decimal | DecimalJsLike | number | string
    reference?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type FinancialTransactionCreateOrConnectWithoutProjectInput = {
    where: FinancialTransactionWhereUniqueInput
    create: XOR<FinancialTransactionCreateWithoutProjectInput, FinancialTransactionUncheckedCreateWithoutProjectInput>
  }

  export type FinancialTransactionCreateManyProjectInputEnvelope = {
    data: FinancialTransactionCreateManyProjectInput | FinancialTransactionCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type InventoryItemCreateWithoutProjectInput = {
    materialName: string
    quantity: Decimal | DecimalJsLike | number | string
    unit: string
    lastUpdated?: Date | string
    warehouse?: WarehouseCreateNestedOneWithoutInventoryInput
  }

  export type InventoryItemUncheckedCreateWithoutProjectInput = {
    id?: number
    materialName: string
    warehouseId?: number | null
    quantity: Decimal | DecimalJsLike | number | string
    unit: string
    lastUpdated?: Date | string
  }

  export type InventoryItemCreateOrConnectWithoutProjectInput = {
    where: InventoryItemWhereUniqueInput
    create: XOR<InventoryItemCreateWithoutProjectInput, InventoryItemUncheckedCreateWithoutProjectInput>
  }

  export type InventoryItemCreateManyProjectInputEnvelope = {
    data: InventoryItemCreateManyProjectInput | InventoryItemCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type ProjectMemberCreateWithoutProjectInput = {
    role: string
    assignedAt?: Date | string
    user: UserCreateNestedOneWithoutProjectMembersInput
  }

  export type ProjectMemberUncheckedCreateWithoutProjectInput = {
    id?: number
    userId: number
    role: string
    assignedAt?: Date | string
  }

  export type ProjectMemberCreateOrConnectWithoutProjectInput = {
    where: ProjectMemberWhereUniqueInput
    create: XOR<ProjectMemberCreateWithoutProjectInput, ProjectMemberUncheckedCreateWithoutProjectInput>
  }

  export type ProjectMemberCreateManyProjectInputEnvelope = {
    data: ProjectMemberCreateManyProjectInput | ProjectMemberCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type BoqItemCreateWithoutProjectInput = {
    itemDescription: string
    unit: string
    materialUnitPrice: Decimal | DecimalJsLike | number | string
    laborUnitPrice?: Decimal | DecimalJsLike | number | string
    quantity: Decimal | DecimalJsLike | number | string
    isCarport?: boolean
    boqComponents?: BoqItemComponentCreateNestedManyWithoutBoqItemInput
  }

  export type BoqItemUncheckedCreateWithoutProjectInput = {
    id?: number
    itemDescription: string
    unit: string
    materialUnitPrice: Decimal | DecimalJsLike | number | string
    laborUnitPrice?: Decimal | DecimalJsLike | number | string
    quantity: Decimal | DecimalJsLike | number | string
    isCarport?: boolean
    boqComponents?: BoqItemComponentUncheckedCreateNestedManyWithoutBoqItemInput
  }

  export type BoqItemCreateOrConnectWithoutProjectInput = {
    where: BoqItemWhereUniqueInput
    create: XOR<BoqItemCreateWithoutProjectInput, BoqItemUncheckedCreateWithoutProjectInput>
  }

  export type BoqItemCreateManyProjectInputEnvelope = {
    data: BoqItemCreateManyProjectInput | BoqItemCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseOrderCreateWithoutProjectInput = {
    orderDate?: Date | string
    status?: $Enums.PoStatus
    remarks?: string | null
    totalAmount?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    supplier?: SupplierCreateNestedOneWithoutPurchaseOrdersInput
    requester: UserCreateNestedOneWithoutPurchaseOrdersInput
    approver?: UserCreateNestedOneWithoutPoApprovalsInput
    items?: PurchaseOrderItemCreateNestedManyWithoutPurchaseOrderInput
    receiving?: ReceivingReportCreateNestedManyWithoutPurchaseOrderInput
    invoices?: SupplierInvoiceCreateNestedManyWithoutPurchaseOrderInput
    disbursements?: DisbursementCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseOrderUncheckedCreateWithoutProjectInput = {
    id?: number
    orderDate?: Date | string
    supplierId?: number | null
    requesterId: number
    approverId?: number | null
    status?: $Enums.PoStatus
    remarks?: string | null
    totalAmount?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: PurchaseOrderItemUncheckedCreateNestedManyWithoutPurchaseOrderInput
    receiving?: ReceivingReportUncheckedCreateNestedManyWithoutPurchaseOrderInput
    invoices?: SupplierInvoiceUncheckedCreateNestedManyWithoutPurchaseOrderInput
    disbursements?: DisbursementUncheckedCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseOrderCreateOrConnectWithoutProjectInput = {
    where: PurchaseOrderWhereUniqueInput
    create: XOR<PurchaseOrderCreateWithoutProjectInput, PurchaseOrderUncheckedCreateWithoutProjectInput>
  }

  export type PurchaseOrderCreateManyProjectInputEnvelope = {
    data: PurchaseOrderCreateManyProjectInput | PurchaseOrderCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type MaterialRequestCreateWithoutProjectInput = {
    requestDate?: Date | string
    status?: $Enums.MrStatus
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    requester: UserCreateNestedOneWithoutMaterialRequestsInput
    approver?: UserCreateNestedOneWithoutMrApprovalsInput
    items?: MaterialRequestItemCreateNestedManyWithoutMaterialRequestInput
    rfqs?: RFQCreateNestedManyWithoutMaterialRequestInput
  }

  export type MaterialRequestUncheckedCreateWithoutProjectInput = {
    id?: number
    requesterId: number
    approverId?: number | null
    requestDate?: Date | string
    status?: $Enums.MrStatus
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: MaterialRequestItemUncheckedCreateNestedManyWithoutMaterialRequestInput
    rfqs?: RFQUncheckedCreateNestedManyWithoutMaterialRequestInput
  }

  export type MaterialRequestCreateOrConnectWithoutProjectInput = {
    where: MaterialRequestWhereUniqueInput
    create: XOR<MaterialRequestCreateWithoutProjectInput, MaterialRequestUncheckedCreateWithoutProjectInput>
  }

  export type MaterialRequestCreateManyProjectInputEnvelope = {
    data: MaterialRequestCreateManyProjectInput | MaterialRequestCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type ClientUpsertWithoutProjectsInput = {
    update: XOR<ClientUpdateWithoutProjectsInput, ClientUncheckedUpdateWithoutProjectsInput>
    create: XOR<ClientCreateWithoutProjectsInput, ClientUncheckedCreateWithoutProjectsInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutProjectsInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutProjectsInput, ClientUncheckedUpdateWithoutProjectsInput>
  }

  export type ClientUpdateWithoutProjectsInput = {
    name?: StringFieldUpdateOperationsInput | string
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    contractType?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientUncheckedUpdateWithoutProjectsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    contractType?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FinancialTransactionUpsertWithWhereUniqueWithoutProjectInput = {
    where: FinancialTransactionWhereUniqueInput
    update: XOR<FinancialTransactionUpdateWithoutProjectInput, FinancialTransactionUncheckedUpdateWithoutProjectInput>
    create: XOR<FinancialTransactionCreateWithoutProjectInput, FinancialTransactionUncheckedCreateWithoutProjectInput>
  }

  export type FinancialTransactionUpdateWithWhereUniqueWithoutProjectInput = {
    where: FinancialTransactionWhereUniqueInput
    data: XOR<FinancialTransactionUpdateWithoutProjectInput, FinancialTransactionUncheckedUpdateWithoutProjectInput>
  }

  export type FinancialTransactionUpdateManyWithWhereWithoutProjectInput = {
    where: FinancialTransactionScalarWhereInput
    data: XOR<FinancialTransactionUpdateManyMutationInput, FinancialTransactionUncheckedUpdateManyWithoutProjectInput>
  }

  export type FinancialTransactionScalarWhereInput = {
    AND?: FinancialTransactionScalarWhereInput | FinancialTransactionScalarWhereInput[]
    OR?: FinancialTransactionScalarWhereInput[]
    NOT?: FinancialTransactionScalarWhereInput | FinancialTransactionScalarWhereInput[]
    id?: IntFilter<"FinancialTransaction"> | number
    projectId?: IntNullableFilter<"FinancialTransaction"> | number | null
    date?: DateTimeFilter<"FinancialTransaction"> | Date | string
    type?: StringFilter<"FinancialTransaction"> | string
    category?: StringFilter<"FinancialTransaction"> | string
    description?: StringNullableFilter<"FinancialTransaction"> | string | null
    amount?: DecimalFilter<"FinancialTransaction"> | Decimal | DecimalJsLike | number | string
    reference?: StringNullableFilter<"FinancialTransaction"> | string | null
    metadata?: JsonNullableFilter<"FinancialTransaction">
  }

  export type InventoryItemUpsertWithWhereUniqueWithoutProjectInput = {
    where: InventoryItemWhereUniqueInput
    update: XOR<InventoryItemUpdateWithoutProjectInput, InventoryItemUncheckedUpdateWithoutProjectInput>
    create: XOR<InventoryItemCreateWithoutProjectInput, InventoryItemUncheckedCreateWithoutProjectInput>
  }

  export type InventoryItemUpdateWithWhereUniqueWithoutProjectInput = {
    where: InventoryItemWhereUniqueInput
    data: XOR<InventoryItemUpdateWithoutProjectInput, InventoryItemUncheckedUpdateWithoutProjectInput>
  }

  export type InventoryItemUpdateManyWithWhereWithoutProjectInput = {
    where: InventoryItemScalarWhereInput
    data: XOR<InventoryItemUpdateManyMutationInput, InventoryItemUncheckedUpdateManyWithoutProjectInput>
  }

  export type InventoryItemScalarWhereInput = {
    AND?: InventoryItemScalarWhereInput | InventoryItemScalarWhereInput[]
    OR?: InventoryItemScalarWhereInput[]
    NOT?: InventoryItemScalarWhereInput | InventoryItemScalarWhereInput[]
    id?: IntFilter<"InventoryItem"> | number
    materialName?: StringFilter<"InventoryItem"> | string
    projectId?: IntNullableFilter<"InventoryItem"> | number | null
    warehouseId?: IntNullableFilter<"InventoryItem"> | number | null
    quantity?: DecimalFilter<"InventoryItem"> | Decimal | DecimalJsLike | number | string
    unit?: StringFilter<"InventoryItem"> | string
    lastUpdated?: DateTimeFilter<"InventoryItem"> | Date | string
  }

  export type ProjectMemberUpsertWithWhereUniqueWithoutProjectInput = {
    where: ProjectMemberWhereUniqueInput
    update: XOR<ProjectMemberUpdateWithoutProjectInput, ProjectMemberUncheckedUpdateWithoutProjectInput>
    create: XOR<ProjectMemberCreateWithoutProjectInput, ProjectMemberUncheckedCreateWithoutProjectInput>
  }

  export type ProjectMemberUpdateWithWhereUniqueWithoutProjectInput = {
    where: ProjectMemberWhereUniqueInput
    data: XOR<ProjectMemberUpdateWithoutProjectInput, ProjectMemberUncheckedUpdateWithoutProjectInput>
  }

  export type ProjectMemberUpdateManyWithWhereWithoutProjectInput = {
    where: ProjectMemberScalarWhereInput
    data: XOR<ProjectMemberUpdateManyMutationInput, ProjectMemberUncheckedUpdateManyWithoutProjectInput>
  }

  export type BoqItemUpsertWithWhereUniqueWithoutProjectInput = {
    where: BoqItemWhereUniqueInput
    update: XOR<BoqItemUpdateWithoutProjectInput, BoqItemUncheckedUpdateWithoutProjectInput>
    create: XOR<BoqItemCreateWithoutProjectInput, BoqItemUncheckedCreateWithoutProjectInput>
  }

  export type BoqItemUpdateWithWhereUniqueWithoutProjectInput = {
    where: BoqItemWhereUniqueInput
    data: XOR<BoqItemUpdateWithoutProjectInput, BoqItemUncheckedUpdateWithoutProjectInput>
  }

  export type BoqItemUpdateManyWithWhereWithoutProjectInput = {
    where: BoqItemScalarWhereInput
    data: XOR<BoqItemUpdateManyMutationInput, BoqItemUncheckedUpdateManyWithoutProjectInput>
  }

  export type BoqItemScalarWhereInput = {
    AND?: BoqItemScalarWhereInput | BoqItemScalarWhereInput[]
    OR?: BoqItemScalarWhereInput[]
    NOT?: BoqItemScalarWhereInput | BoqItemScalarWhereInput[]
    id?: IntFilter<"BoqItem"> | number
    projectId?: IntFilter<"BoqItem"> | number
    itemDescription?: StringFilter<"BoqItem"> | string
    unit?: StringFilter<"BoqItem"> | string
    materialUnitPrice?: DecimalFilter<"BoqItem"> | Decimal | DecimalJsLike | number | string
    laborUnitPrice?: DecimalFilter<"BoqItem"> | Decimal | DecimalJsLike | number | string
    quantity?: DecimalFilter<"BoqItem"> | Decimal | DecimalJsLike | number | string
    isCarport?: BoolFilter<"BoqItem"> | boolean
  }

  export type PurchaseOrderUpsertWithWhereUniqueWithoutProjectInput = {
    where: PurchaseOrderWhereUniqueInput
    update: XOR<PurchaseOrderUpdateWithoutProjectInput, PurchaseOrderUncheckedUpdateWithoutProjectInput>
    create: XOR<PurchaseOrderCreateWithoutProjectInput, PurchaseOrderUncheckedCreateWithoutProjectInput>
  }

  export type PurchaseOrderUpdateWithWhereUniqueWithoutProjectInput = {
    where: PurchaseOrderWhereUniqueInput
    data: XOR<PurchaseOrderUpdateWithoutProjectInput, PurchaseOrderUncheckedUpdateWithoutProjectInput>
  }

  export type PurchaseOrderUpdateManyWithWhereWithoutProjectInput = {
    where: PurchaseOrderScalarWhereInput
    data: XOR<PurchaseOrderUpdateManyMutationInput, PurchaseOrderUncheckedUpdateManyWithoutProjectInput>
  }

  export type MaterialRequestUpsertWithWhereUniqueWithoutProjectInput = {
    where: MaterialRequestWhereUniqueInput
    update: XOR<MaterialRequestUpdateWithoutProjectInput, MaterialRequestUncheckedUpdateWithoutProjectInput>
    create: XOR<MaterialRequestCreateWithoutProjectInput, MaterialRequestUncheckedCreateWithoutProjectInput>
  }

  export type MaterialRequestUpdateWithWhereUniqueWithoutProjectInput = {
    where: MaterialRequestWhereUniqueInput
    data: XOR<MaterialRequestUpdateWithoutProjectInput, MaterialRequestUncheckedUpdateWithoutProjectInput>
  }

  export type MaterialRequestUpdateManyWithWhereWithoutProjectInput = {
    where: MaterialRequestScalarWhereInput
    data: XOR<MaterialRequestUpdateManyMutationInput, MaterialRequestUncheckedUpdateManyWithoutProjectInput>
  }

  export type ProjectCreateWithoutTeamMembersInput = {
    name: string
    location?: string | null
    duration?: string | null
    budget: Decimal | DecimalJsLike | number | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    totalFloorArea?: Decimal | DecimalJsLike | number | string | null
    carportArea?: Decimal | DecimalJsLike | number | string | null
    client?: ClientCreateNestedOneWithoutProjectsInput
    transactions?: FinancialTransactionCreateNestedManyWithoutProjectInput
    inventory?: InventoryItemCreateNestedManyWithoutProjectInput
    boqItems?: BoqItemCreateNestedManyWithoutProjectInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutProjectInput
    materialRequests?: MaterialRequestCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutTeamMembersInput = {
    id?: number
    clientId?: number | null
    name: string
    location?: string | null
    duration?: string | null
    budget: Decimal | DecimalJsLike | number | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    totalFloorArea?: Decimal | DecimalJsLike | number | string | null
    carportArea?: Decimal | DecimalJsLike | number | string | null
    transactions?: FinancialTransactionUncheckedCreateNestedManyWithoutProjectInput
    inventory?: InventoryItemUncheckedCreateNestedManyWithoutProjectInput
    boqItems?: BoqItemUncheckedCreateNestedManyWithoutProjectInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutProjectInput
    materialRequests?: MaterialRequestUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutTeamMembersInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutTeamMembersInput, ProjectUncheckedCreateWithoutTeamMembersInput>
  }

  export type UserCreateWithoutProjectMembersInput = {
    email: string
    name: string
    password: string
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutRequesterInput
    poApprovals?: PurchaseOrderCreateNestedManyWithoutApproverInput
    materialRequests?: MaterialRequestCreateNestedManyWithoutRequesterInput
    mrApprovals?: MaterialRequestCreateNestedManyWithoutApproverInput
    rfqsCreated?: RFQCreateNestedManyWithoutCreatedByInput
    receivedItems?: ReceivingReportCreateNestedManyWithoutReceivedByInput
    disbursements?: DisbursementCreateNestedManyWithoutProcessedByInput
  }

  export type UserUncheckedCreateWithoutProjectMembersInput = {
    id?: number
    email: string
    name: string
    password: string
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutRequesterInput
    poApprovals?: PurchaseOrderUncheckedCreateNestedManyWithoutApproverInput
    materialRequests?: MaterialRequestUncheckedCreateNestedManyWithoutRequesterInput
    mrApprovals?: MaterialRequestUncheckedCreateNestedManyWithoutApproverInput
    rfqsCreated?: RFQUncheckedCreateNestedManyWithoutCreatedByInput
    receivedItems?: ReceivingReportUncheckedCreateNestedManyWithoutReceivedByInput
    disbursements?: DisbursementUncheckedCreateNestedManyWithoutProcessedByInput
  }

  export type UserCreateOrConnectWithoutProjectMembersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProjectMembersInput, UserUncheckedCreateWithoutProjectMembersInput>
  }

  export type ProjectUpsertWithoutTeamMembersInput = {
    update: XOR<ProjectUpdateWithoutTeamMembersInput, ProjectUncheckedUpdateWithoutTeamMembersInput>
    create: XOR<ProjectCreateWithoutTeamMembersInput, ProjectUncheckedCreateWithoutTeamMembersInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutTeamMembersInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutTeamMembersInput, ProjectUncheckedUpdateWithoutTeamMembersInput>
  }

  export type ProjectUpdateWithoutTeamMembersInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalFloorArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    carportArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    client?: ClientUpdateOneWithoutProjectsNestedInput
    transactions?: FinancialTransactionUpdateManyWithoutProjectNestedInput
    inventory?: InventoryItemUpdateManyWithoutProjectNestedInput
    boqItems?: BoqItemUpdateManyWithoutProjectNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutProjectNestedInput
    materialRequests?: MaterialRequestUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutTeamMembersInput = {
    id?: IntFieldUpdateOperationsInput | number
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalFloorArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    carportArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    transactions?: FinancialTransactionUncheckedUpdateManyWithoutProjectNestedInput
    inventory?: InventoryItemUncheckedUpdateManyWithoutProjectNestedInput
    boqItems?: BoqItemUncheckedUpdateManyWithoutProjectNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutProjectNestedInput
    materialRequests?: MaterialRequestUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type UserUpsertWithoutProjectMembersInput = {
    update: XOR<UserUpdateWithoutProjectMembersInput, UserUncheckedUpdateWithoutProjectMembersInput>
    create: XOR<UserCreateWithoutProjectMembersInput, UserUncheckedCreateWithoutProjectMembersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProjectMembersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProjectMembersInput, UserUncheckedUpdateWithoutProjectMembersInput>
  }

  export type UserUpdateWithoutProjectMembersInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrders?: PurchaseOrderUpdateManyWithoutRequesterNestedInput
    poApprovals?: PurchaseOrderUpdateManyWithoutApproverNestedInput
    materialRequests?: MaterialRequestUpdateManyWithoutRequesterNestedInput
    mrApprovals?: MaterialRequestUpdateManyWithoutApproverNestedInput
    rfqsCreated?: RFQUpdateManyWithoutCreatedByNestedInput
    receivedItems?: ReceivingReportUpdateManyWithoutReceivedByNestedInput
    disbursements?: DisbursementUpdateManyWithoutProcessedByNestedInput
  }

  export type UserUncheckedUpdateWithoutProjectMembersInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutRequesterNestedInput
    poApprovals?: PurchaseOrderUncheckedUpdateManyWithoutApproverNestedInput
    materialRequests?: MaterialRequestUncheckedUpdateManyWithoutRequesterNestedInput
    mrApprovals?: MaterialRequestUncheckedUpdateManyWithoutApproverNestedInput
    rfqsCreated?: RFQUncheckedUpdateManyWithoutCreatedByNestedInput
    receivedItems?: ReceivingReportUncheckedUpdateManyWithoutReceivedByNestedInput
    disbursements?: DisbursementUncheckedUpdateManyWithoutProcessedByNestedInput
  }

  export type ProjectCreateWithoutBoqItemsInput = {
    name: string
    location?: string | null
    duration?: string | null
    budget: Decimal | DecimalJsLike | number | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    totalFloorArea?: Decimal | DecimalJsLike | number | string | null
    carportArea?: Decimal | DecimalJsLike | number | string | null
    client?: ClientCreateNestedOneWithoutProjectsInput
    transactions?: FinancialTransactionCreateNestedManyWithoutProjectInput
    inventory?: InventoryItemCreateNestedManyWithoutProjectInput
    teamMembers?: ProjectMemberCreateNestedManyWithoutProjectInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutProjectInput
    materialRequests?: MaterialRequestCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutBoqItemsInput = {
    id?: number
    clientId?: number | null
    name: string
    location?: string | null
    duration?: string | null
    budget: Decimal | DecimalJsLike | number | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    totalFloorArea?: Decimal | DecimalJsLike | number | string | null
    carportArea?: Decimal | DecimalJsLike | number | string | null
    transactions?: FinancialTransactionUncheckedCreateNestedManyWithoutProjectInput
    inventory?: InventoryItemUncheckedCreateNestedManyWithoutProjectInput
    teamMembers?: ProjectMemberUncheckedCreateNestedManyWithoutProjectInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutProjectInput
    materialRequests?: MaterialRequestUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutBoqItemsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutBoqItemsInput, ProjectUncheckedCreateWithoutBoqItemsInput>
  }

  export type BoqItemComponentCreateWithoutBoqItemInput = {
    resourceType: $Enums.ResourceType
    name: string
    quantityFactor: Decimal | DecimalJsLike | number | string
    unitRate: Decimal | DecimalJsLike | number | string
    totalComponentCost: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BoqItemComponentUncheckedCreateWithoutBoqItemInput = {
    id?: number
    resourceType: $Enums.ResourceType
    name: string
    quantityFactor: Decimal | DecimalJsLike | number | string
    unitRate: Decimal | DecimalJsLike | number | string
    totalComponentCost: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BoqItemComponentCreateOrConnectWithoutBoqItemInput = {
    where: BoqItemComponentWhereUniqueInput
    create: XOR<BoqItemComponentCreateWithoutBoqItemInput, BoqItemComponentUncheckedCreateWithoutBoqItemInput>
  }

  export type BoqItemComponentCreateManyBoqItemInputEnvelope = {
    data: BoqItemComponentCreateManyBoqItemInput | BoqItemComponentCreateManyBoqItemInput[]
    skipDuplicates?: boolean
  }

  export type ProjectUpsertWithoutBoqItemsInput = {
    update: XOR<ProjectUpdateWithoutBoqItemsInput, ProjectUncheckedUpdateWithoutBoqItemsInput>
    create: XOR<ProjectCreateWithoutBoqItemsInput, ProjectUncheckedCreateWithoutBoqItemsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutBoqItemsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutBoqItemsInput, ProjectUncheckedUpdateWithoutBoqItemsInput>
  }

  export type ProjectUpdateWithoutBoqItemsInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalFloorArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    carportArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    client?: ClientUpdateOneWithoutProjectsNestedInput
    transactions?: FinancialTransactionUpdateManyWithoutProjectNestedInput
    inventory?: InventoryItemUpdateManyWithoutProjectNestedInput
    teamMembers?: ProjectMemberUpdateManyWithoutProjectNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutProjectNestedInput
    materialRequests?: MaterialRequestUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutBoqItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalFloorArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    carportArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    transactions?: FinancialTransactionUncheckedUpdateManyWithoutProjectNestedInput
    inventory?: InventoryItemUncheckedUpdateManyWithoutProjectNestedInput
    teamMembers?: ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutProjectNestedInput
    materialRequests?: MaterialRequestUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type BoqItemComponentUpsertWithWhereUniqueWithoutBoqItemInput = {
    where: BoqItemComponentWhereUniqueInput
    update: XOR<BoqItemComponentUpdateWithoutBoqItemInput, BoqItemComponentUncheckedUpdateWithoutBoqItemInput>
    create: XOR<BoqItemComponentCreateWithoutBoqItemInput, BoqItemComponentUncheckedCreateWithoutBoqItemInput>
  }

  export type BoqItemComponentUpdateWithWhereUniqueWithoutBoqItemInput = {
    where: BoqItemComponentWhereUniqueInput
    data: XOR<BoqItemComponentUpdateWithoutBoqItemInput, BoqItemComponentUncheckedUpdateWithoutBoqItemInput>
  }

  export type BoqItemComponentUpdateManyWithWhereWithoutBoqItemInput = {
    where: BoqItemComponentScalarWhereInput
    data: XOR<BoqItemComponentUpdateManyMutationInput, BoqItemComponentUncheckedUpdateManyWithoutBoqItemInput>
  }

  export type BoqItemComponentScalarWhereInput = {
    AND?: BoqItemComponentScalarWhereInput | BoqItemComponentScalarWhereInput[]
    OR?: BoqItemComponentScalarWhereInput[]
    NOT?: BoqItemComponentScalarWhereInput | BoqItemComponentScalarWhereInput[]
    id?: IntFilter<"BoqItemComponent"> | number
    boqItemId?: IntFilter<"BoqItemComponent"> | number
    resourceType?: EnumResourceTypeFilter<"BoqItemComponent"> | $Enums.ResourceType
    name?: StringFilter<"BoqItemComponent"> | string
    quantityFactor?: DecimalFilter<"BoqItemComponent"> | Decimal | DecimalJsLike | number | string
    unitRate?: DecimalFilter<"BoqItemComponent"> | Decimal | DecimalJsLike | number | string
    totalComponentCost?: DecimalFilter<"BoqItemComponent"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"BoqItemComponent"> | Date | string
    updatedAt?: DateTimeFilter<"BoqItemComponent"> | Date | string
  }

  export type BoqItemCreateWithoutBoqComponentsInput = {
    itemDescription: string
    unit: string
    materialUnitPrice: Decimal | DecimalJsLike | number | string
    laborUnitPrice?: Decimal | DecimalJsLike | number | string
    quantity: Decimal | DecimalJsLike | number | string
    isCarport?: boolean
    project: ProjectCreateNestedOneWithoutBoqItemsInput
  }

  export type BoqItemUncheckedCreateWithoutBoqComponentsInput = {
    id?: number
    projectId: number
    itemDescription: string
    unit: string
    materialUnitPrice: Decimal | DecimalJsLike | number | string
    laborUnitPrice?: Decimal | DecimalJsLike | number | string
    quantity: Decimal | DecimalJsLike | number | string
    isCarport?: boolean
  }

  export type BoqItemCreateOrConnectWithoutBoqComponentsInput = {
    where: BoqItemWhereUniqueInput
    create: XOR<BoqItemCreateWithoutBoqComponentsInput, BoqItemUncheckedCreateWithoutBoqComponentsInput>
  }

  export type BoqItemUpsertWithoutBoqComponentsInput = {
    update: XOR<BoqItemUpdateWithoutBoqComponentsInput, BoqItemUncheckedUpdateWithoutBoqComponentsInput>
    create: XOR<BoqItemCreateWithoutBoqComponentsInput, BoqItemUncheckedCreateWithoutBoqComponentsInput>
    where?: BoqItemWhereInput
  }

  export type BoqItemUpdateToOneWithWhereWithoutBoqComponentsInput = {
    where?: BoqItemWhereInput
    data: XOR<BoqItemUpdateWithoutBoqComponentsInput, BoqItemUncheckedUpdateWithoutBoqComponentsInput>
  }

  export type BoqItemUpdateWithoutBoqComponentsInput = {
    itemDescription?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    materialUnitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    laborUnitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isCarport?: BoolFieldUpdateOperationsInput | boolean
    project?: ProjectUpdateOneRequiredWithoutBoqItemsNestedInput
  }

  export type BoqItemUncheckedUpdateWithoutBoqComponentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    itemDescription?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    materialUnitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    laborUnitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isCarport?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProjectCreateWithoutMaterialRequestsInput = {
    name: string
    location?: string | null
    duration?: string | null
    budget: Decimal | DecimalJsLike | number | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    totalFloorArea?: Decimal | DecimalJsLike | number | string | null
    carportArea?: Decimal | DecimalJsLike | number | string | null
    client?: ClientCreateNestedOneWithoutProjectsInput
    transactions?: FinancialTransactionCreateNestedManyWithoutProjectInput
    inventory?: InventoryItemCreateNestedManyWithoutProjectInput
    teamMembers?: ProjectMemberCreateNestedManyWithoutProjectInput
    boqItems?: BoqItemCreateNestedManyWithoutProjectInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutMaterialRequestsInput = {
    id?: number
    clientId?: number | null
    name: string
    location?: string | null
    duration?: string | null
    budget: Decimal | DecimalJsLike | number | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    totalFloorArea?: Decimal | DecimalJsLike | number | string | null
    carportArea?: Decimal | DecimalJsLike | number | string | null
    transactions?: FinancialTransactionUncheckedCreateNestedManyWithoutProjectInput
    inventory?: InventoryItemUncheckedCreateNestedManyWithoutProjectInput
    teamMembers?: ProjectMemberUncheckedCreateNestedManyWithoutProjectInput
    boqItems?: BoqItemUncheckedCreateNestedManyWithoutProjectInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutMaterialRequestsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutMaterialRequestsInput, ProjectUncheckedCreateWithoutMaterialRequestsInput>
  }

  export type UserCreateWithoutMaterialRequestsInput = {
    email: string
    name: string
    password: string
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutRequesterInput
    poApprovals?: PurchaseOrderCreateNestedManyWithoutApproverInput
    mrApprovals?: MaterialRequestCreateNestedManyWithoutApproverInput
    rfqsCreated?: RFQCreateNestedManyWithoutCreatedByInput
    receivedItems?: ReceivingReportCreateNestedManyWithoutReceivedByInput
    disbursements?: DisbursementCreateNestedManyWithoutProcessedByInput
    projectMembers?: ProjectMemberCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMaterialRequestsInput = {
    id?: number
    email: string
    name: string
    password: string
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutRequesterInput
    poApprovals?: PurchaseOrderUncheckedCreateNestedManyWithoutApproverInput
    mrApprovals?: MaterialRequestUncheckedCreateNestedManyWithoutApproverInput
    rfqsCreated?: RFQUncheckedCreateNestedManyWithoutCreatedByInput
    receivedItems?: ReceivingReportUncheckedCreateNestedManyWithoutReceivedByInput
    disbursements?: DisbursementUncheckedCreateNestedManyWithoutProcessedByInput
    projectMembers?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMaterialRequestsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMaterialRequestsInput, UserUncheckedCreateWithoutMaterialRequestsInput>
  }

  export type UserCreateWithoutMrApprovalsInput = {
    email: string
    name: string
    password: string
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutRequesterInput
    poApprovals?: PurchaseOrderCreateNestedManyWithoutApproverInput
    materialRequests?: MaterialRequestCreateNestedManyWithoutRequesterInput
    rfqsCreated?: RFQCreateNestedManyWithoutCreatedByInput
    receivedItems?: ReceivingReportCreateNestedManyWithoutReceivedByInput
    disbursements?: DisbursementCreateNestedManyWithoutProcessedByInput
    projectMembers?: ProjectMemberCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMrApprovalsInput = {
    id?: number
    email: string
    name: string
    password: string
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutRequesterInput
    poApprovals?: PurchaseOrderUncheckedCreateNestedManyWithoutApproverInput
    materialRequests?: MaterialRequestUncheckedCreateNestedManyWithoutRequesterInput
    rfqsCreated?: RFQUncheckedCreateNestedManyWithoutCreatedByInput
    receivedItems?: ReceivingReportUncheckedCreateNestedManyWithoutReceivedByInput
    disbursements?: DisbursementUncheckedCreateNestedManyWithoutProcessedByInput
    projectMembers?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMrApprovalsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMrApprovalsInput, UserUncheckedCreateWithoutMrApprovalsInput>
  }

  export type MaterialRequestItemCreateWithoutMaterialRequestInput = {
    itemDescription: string
    description?: string | null
    quantity: Decimal | DecimalJsLike | number | string
    materialUnitPrice?: Decimal | DecimalJsLike | number | string
    laborUnitPrice?: Decimal | DecimalJsLike | number | string
    unit: string
  }

  export type MaterialRequestItemUncheckedCreateWithoutMaterialRequestInput = {
    id?: number
    itemDescription: string
    description?: string | null
    quantity: Decimal | DecimalJsLike | number | string
    materialUnitPrice?: Decimal | DecimalJsLike | number | string
    laborUnitPrice?: Decimal | DecimalJsLike | number | string
    unit: string
  }

  export type MaterialRequestItemCreateOrConnectWithoutMaterialRequestInput = {
    where: MaterialRequestItemWhereUniqueInput
    create: XOR<MaterialRequestItemCreateWithoutMaterialRequestInput, MaterialRequestItemUncheckedCreateWithoutMaterialRequestInput>
  }

  export type MaterialRequestItemCreateManyMaterialRequestInputEnvelope = {
    data: MaterialRequestItemCreateManyMaterialRequestInput | MaterialRequestItemCreateManyMaterialRequestInput[]
    skipDuplicates?: boolean
  }

  export type RFQCreateWithoutMaterialRequestInput = {
    title: string
    status?: $Enums.RfqStatus
    dueDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutRfqsCreatedInput
    items?: RFQItemCreateNestedManyWithoutRfqInput
    quotations?: SupplierQuotationCreateNestedManyWithoutRfqInput
  }

  export type RFQUncheckedCreateWithoutMaterialRequestInput = {
    id?: number
    createdById: number
    title: string
    status?: $Enums.RfqStatus
    dueDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: RFQItemUncheckedCreateNestedManyWithoutRfqInput
    quotations?: SupplierQuotationUncheckedCreateNestedManyWithoutRfqInput
  }

  export type RFQCreateOrConnectWithoutMaterialRequestInput = {
    where: RFQWhereUniqueInput
    create: XOR<RFQCreateWithoutMaterialRequestInput, RFQUncheckedCreateWithoutMaterialRequestInput>
  }

  export type RFQCreateManyMaterialRequestInputEnvelope = {
    data: RFQCreateManyMaterialRequestInput | RFQCreateManyMaterialRequestInput[]
    skipDuplicates?: boolean
  }

  export type ProjectUpsertWithoutMaterialRequestsInput = {
    update: XOR<ProjectUpdateWithoutMaterialRequestsInput, ProjectUncheckedUpdateWithoutMaterialRequestsInput>
    create: XOR<ProjectCreateWithoutMaterialRequestsInput, ProjectUncheckedCreateWithoutMaterialRequestsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutMaterialRequestsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutMaterialRequestsInput, ProjectUncheckedUpdateWithoutMaterialRequestsInput>
  }

  export type ProjectUpdateWithoutMaterialRequestsInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalFloorArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    carportArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    client?: ClientUpdateOneWithoutProjectsNestedInput
    transactions?: FinancialTransactionUpdateManyWithoutProjectNestedInput
    inventory?: InventoryItemUpdateManyWithoutProjectNestedInput
    teamMembers?: ProjectMemberUpdateManyWithoutProjectNestedInput
    boqItems?: BoqItemUpdateManyWithoutProjectNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutMaterialRequestsInput = {
    id?: IntFieldUpdateOperationsInput | number
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalFloorArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    carportArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    transactions?: FinancialTransactionUncheckedUpdateManyWithoutProjectNestedInput
    inventory?: InventoryItemUncheckedUpdateManyWithoutProjectNestedInput
    teamMembers?: ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
    boqItems?: BoqItemUncheckedUpdateManyWithoutProjectNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type UserUpsertWithoutMaterialRequestsInput = {
    update: XOR<UserUpdateWithoutMaterialRequestsInput, UserUncheckedUpdateWithoutMaterialRequestsInput>
    create: XOR<UserCreateWithoutMaterialRequestsInput, UserUncheckedCreateWithoutMaterialRequestsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMaterialRequestsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMaterialRequestsInput, UserUncheckedUpdateWithoutMaterialRequestsInput>
  }

  export type UserUpdateWithoutMaterialRequestsInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrders?: PurchaseOrderUpdateManyWithoutRequesterNestedInput
    poApprovals?: PurchaseOrderUpdateManyWithoutApproverNestedInput
    mrApprovals?: MaterialRequestUpdateManyWithoutApproverNestedInput
    rfqsCreated?: RFQUpdateManyWithoutCreatedByNestedInput
    receivedItems?: ReceivingReportUpdateManyWithoutReceivedByNestedInput
    disbursements?: DisbursementUpdateManyWithoutProcessedByNestedInput
    projectMembers?: ProjectMemberUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMaterialRequestsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutRequesterNestedInput
    poApprovals?: PurchaseOrderUncheckedUpdateManyWithoutApproverNestedInput
    mrApprovals?: MaterialRequestUncheckedUpdateManyWithoutApproverNestedInput
    rfqsCreated?: RFQUncheckedUpdateManyWithoutCreatedByNestedInput
    receivedItems?: ReceivingReportUncheckedUpdateManyWithoutReceivedByNestedInput
    disbursements?: DisbursementUncheckedUpdateManyWithoutProcessedByNestedInput
    projectMembers?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutMrApprovalsInput = {
    update: XOR<UserUpdateWithoutMrApprovalsInput, UserUncheckedUpdateWithoutMrApprovalsInput>
    create: XOR<UserCreateWithoutMrApprovalsInput, UserUncheckedCreateWithoutMrApprovalsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMrApprovalsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMrApprovalsInput, UserUncheckedUpdateWithoutMrApprovalsInput>
  }

  export type UserUpdateWithoutMrApprovalsInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrders?: PurchaseOrderUpdateManyWithoutRequesterNestedInput
    poApprovals?: PurchaseOrderUpdateManyWithoutApproverNestedInput
    materialRequests?: MaterialRequestUpdateManyWithoutRequesterNestedInput
    rfqsCreated?: RFQUpdateManyWithoutCreatedByNestedInput
    receivedItems?: ReceivingReportUpdateManyWithoutReceivedByNestedInput
    disbursements?: DisbursementUpdateManyWithoutProcessedByNestedInput
    projectMembers?: ProjectMemberUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMrApprovalsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutRequesterNestedInput
    poApprovals?: PurchaseOrderUncheckedUpdateManyWithoutApproverNestedInput
    materialRequests?: MaterialRequestUncheckedUpdateManyWithoutRequesterNestedInput
    rfqsCreated?: RFQUncheckedUpdateManyWithoutCreatedByNestedInput
    receivedItems?: ReceivingReportUncheckedUpdateManyWithoutReceivedByNestedInput
    disbursements?: DisbursementUncheckedUpdateManyWithoutProcessedByNestedInput
    projectMembers?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
  }

  export type MaterialRequestItemUpsertWithWhereUniqueWithoutMaterialRequestInput = {
    where: MaterialRequestItemWhereUniqueInput
    update: XOR<MaterialRequestItemUpdateWithoutMaterialRequestInput, MaterialRequestItemUncheckedUpdateWithoutMaterialRequestInput>
    create: XOR<MaterialRequestItemCreateWithoutMaterialRequestInput, MaterialRequestItemUncheckedCreateWithoutMaterialRequestInput>
  }

  export type MaterialRequestItemUpdateWithWhereUniqueWithoutMaterialRequestInput = {
    where: MaterialRequestItemWhereUniqueInput
    data: XOR<MaterialRequestItemUpdateWithoutMaterialRequestInput, MaterialRequestItemUncheckedUpdateWithoutMaterialRequestInput>
  }

  export type MaterialRequestItemUpdateManyWithWhereWithoutMaterialRequestInput = {
    where: MaterialRequestItemScalarWhereInput
    data: XOR<MaterialRequestItemUpdateManyMutationInput, MaterialRequestItemUncheckedUpdateManyWithoutMaterialRequestInput>
  }

  export type MaterialRequestItemScalarWhereInput = {
    AND?: MaterialRequestItemScalarWhereInput | MaterialRequestItemScalarWhereInput[]
    OR?: MaterialRequestItemScalarWhereInput[]
    NOT?: MaterialRequestItemScalarWhereInput | MaterialRequestItemScalarWhereInput[]
    id?: IntFilter<"MaterialRequestItem"> | number
    materialRequestId?: IntFilter<"MaterialRequestItem"> | number
    itemDescription?: StringFilter<"MaterialRequestItem"> | string
    description?: StringNullableFilter<"MaterialRequestItem"> | string | null
    quantity?: DecimalFilter<"MaterialRequestItem"> | Decimal | DecimalJsLike | number | string
    materialUnitPrice?: DecimalFilter<"MaterialRequestItem"> | Decimal | DecimalJsLike | number | string
    laborUnitPrice?: DecimalFilter<"MaterialRequestItem"> | Decimal | DecimalJsLike | number | string
    unit?: StringFilter<"MaterialRequestItem"> | string
  }

  export type RFQUpsertWithWhereUniqueWithoutMaterialRequestInput = {
    where: RFQWhereUniqueInput
    update: XOR<RFQUpdateWithoutMaterialRequestInput, RFQUncheckedUpdateWithoutMaterialRequestInput>
    create: XOR<RFQCreateWithoutMaterialRequestInput, RFQUncheckedCreateWithoutMaterialRequestInput>
  }

  export type RFQUpdateWithWhereUniqueWithoutMaterialRequestInput = {
    where: RFQWhereUniqueInput
    data: XOR<RFQUpdateWithoutMaterialRequestInput, RFQUncheckedUpdateWithoutMaterialRequestInput>
  }

  export type RFQUpdateManyWithWhereWithoutMaterialRequestInput = {
    where: RFQScalarWhereInput
    data: XOR<RFQUpdateManyMutationInput, RFQUncheckedUpdateManyWithoutMaterialRequestInput>
  }

  export type MaterialRequestCreateWithoutItemsInput = {
    requestDate?: Date | string
    status?: $Enums.MrStatus
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutMaterialRequestsInput
    requester: UserCreateNestedOneWithoutMaterialRequestsInput
    approver?: UserCreateNestedOneWithoutMrApprovalsInput
    rfqs?: RFQCreateNestedManyWithoutMaterialRequestInput
  }

  export type MaterialRequestUncheckedCreateWithoutItemsInput = {
    id?: number
    projectId: number
    requesterId: number
    approverId?: number | null
    requestDate?: Date | string
    status?: $Enums.MrStatus
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rfqs?: RFQUncheckedCreateNestedManyWithoutMaterialRequestInput
  }

  export type MaterialRequestCreateOrConnectWithoutItemsInput = {
    where: MaterialRequestWhereUniqueInput
    create: XOR<MaterialRequestCreateWithoutItemsInput, MaterialRequestUncheckedCreateWithoutItemsInput>
  }

  export type MaterialRequestUpsertWithoutItemsInput = {
    update: XOR<MaterialRequestUpdateWithoutItemsInput, MaterialRequestUncheckedUpdateWithoutItemsInput>
    create: XOR<MaterialRequestCreateWithoutItemsInput, MaterialRequestUncheckedCreateWithoutItemsInput>
    where?: MaterialRequestWhereInput
  }

  export type MaterialRequestUpdateToOneWithWhereWithoutItemsInput = {
    where?: MaterialRequestWhereInput
    data: XOR<MaterialRequestUpdateWithoutItemsInput, MaterialRequestUncheckedUpdateWithoutItemsInput>
  }

  export type MaterialRequestUpdateWithoutItemsInput = {
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumMrStatusFieldUpdateOperationsInput | $Enums.MrStatus
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutMaterialRequestsNestedInput
    requester?: UserUpdateOneRequiredWithoutMaterialRequestsNestedInput
    approver?: UserUpdateOneWithoutMrApprovalsNestedInput
    rfqs?: RFQUpdateManyWithoutMaterialRequestNestedInput
  }

  export type MaterialRequestUncheckedUpdateWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    requesterId?: IntFieldUpdateOperationsInput | number
    approverId?: NullableIntFieldUpdateOperationsInput | number | null
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumMrStatusFieldUpdateOperationsInput | $Enums.MrStatus
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rfqs?: RFQUncheckedUpdateManyWithoutMaterialRequestNestedInput
  }

  export type MaterialRequestCreateWithoutRfqsInput = {
    requestDate?: Date | string
    status?: $Enums.MrStatus
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutMaterialRequestsInput
    requester: UserCreateNestedOneWithoutMaterialRequestsInput
    approver?: UserCreateNestedOneWithoutMrApprovalsInput
    items?: MaterialRequestItemCreateNestedManyWithoutMaterialRequestInput
  }

  export type MaterialRequestUncheckedCreateWithoutRfqsInput = {
    id?: number
    projectId: number
    requesterId: number
    approverId?: number | null
    requestDate?: Date | string
    status?: $Enums.MrStatus
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: MaterialRequestItemUncheckedCreateNestedManyWithoutMaterialRequestInput
  }

  export type MaterialRequestCreateOrConnectWithoutRfqsInput = {
    where: MaterialRequestWhereUniqueInput
    create: XOR<MaterialRequestCreateWithoutRfqsInput, MaterialRequestUncheckedCreateWithoutRfqsInput>
  }

  export type UserCreateWithoutRfqsCreatedInput = {
    email: string
    name: string
    password: string
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutRequesterInput
    poApprovals?: PurchaseOrderCreateNestedManyWithoutApproverInput
    materialRequests?: MaterialRequestCreateNestedManyWithoutRequesterInput
    mrApprovals?: MaterialRequestCreateNestedManyWithoutApproverInput
    receivedItems?: ReceivingReportCreateNestedManyWithoutReceivedByInput
    disbursements?: DisbursementCreateNestedManyWithoutProcessedByInput
    projectMembers?: ProjectMemberCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRfqsCreatedInput = {
    id?: number
    email: string
    name: string
    password: string
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutRequesterInput
    poApprovals?: PurchaseOrderUncheckedCreateNestedManyWithoutApproverInput
    materialRequests?: MaterialRequestUncheckedCreateNestedManyWithoutRequesterInput
    mrApprovals?: MaterialRequestUncheckedCreateNestedManyWithoutApproverInput
    receivedItems?: ReceivingReportUncheckedCreateNestedManyWithoutReceivedByInput
    disbursements?: DisbursementUncheckedCreateNestedManyWithoutProcessedByInput
    projectMembers?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRfqsCreatedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRfqsCreatedInput, UserUncheckedCreateWithoutRfqsCreatedInput>
  }

  export type RFQItemCreateWithoutRfqInput = {
    materialName: string
    quantity: Decimal | DecimalJsLike | number | string
    unit: string
  }

  export type RFQItemUncheckedCreateWithoutRfqInput = {
    id?: number
    materialName: string
    quantity: Decimal | DecimalJsLike | number | string
    unit: string
  }

  export type RFQItemCreateOrConnectWithoutRfqInput = {
    where: RFQItemWhereUniqueInput
    create: XOR<RFQItemCreateWithoutRfqInput, RFQItemUncheckedCreateWithoutRfqInput>
  }

  export type RFQItemCreateManyRfqInputEnvelope = {
    data: RFQItemCreateManyRfqInput | RFQItemCreateManyRfqInput[]
    skipDuplicates?: boolean
  }

  export type SupplierQuotationCreateWithoutRfqInput = {
    quoteDate?: Date | string
    totalAmount?: Decimal | DecimalJsLike | number | string
    currency?: string
    isSelected?: boolean
    supplier: SupplierCreateNestedOneWithoutQuotationsInput
    items?: QuotationItemCreateNestedManyWithoutSupplierQuotationInput
  }

  export type SupplierQuotationUncheckedCreateWithoutRfqInput = {
    id?: number
    supplierId: number
    quoteDate?: Date | string
    totalAmount?: Decimal | DecimalJsLike | number | string
    currency?: string
    isSelected?: boolean
    items?: QuotationItemUncheckedCreateNestedManyWithoutSupplierQuotationInput
  }

  export type SupplierQuotationCreateOrConnectWithoutRfqInput = {
    where: SupplierQuotationWhereUniqueInput
    create: XOR<SupplierQuotationCreateWithoutRfqInput, SupplierQuotationUncheckedCreateWithoutRfqInput>
  }

  export type SupplierQuotationCreateManyRfqInputEnvelope = {
    data: SupplierQuotationCreateManyRfqInput | SupplierQuotationCreateManyRfqInput[]
    skipDuplicates?: boolean
  }

  export type MaterialRequestUpsertWithoutRfqsInput = {
    update: XOR<MaterialRequestUpdateWithoutRfqsInput, MaterialRequestUncheckedUpdateWithoutRfqsInput>
    create: XOR<MaterialRequestCreateWithoutRfqsInput, MaterialRequestUncheckedCreateWithoutRfqsInput>
    where?: MaterialRequestWhereInput
  }

  export type MaterialRequestUpdateToOneWithWhereWithoutRfqsInput = {
    where?: MaterialRequestWhereInput
    data: XOR<MaterialRequestUpdateWithoutRfqsInput, MaterialRequestUncheckedUpdateWithoutRfqsInput>
  }

  export type MaterialRequestUpdateWithoutRfqsInput = {
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumMrStatusFieldUpdateOperationsInput | $Enums.MrStatus
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutMaterialRequestsNestedInput
    requester?: UserUpdateOneRequiredWithoutMaterialRequestsNestedInput
    approver?: UserUpdateOneWithoutMrApprovalsNestedInput
    items?: MaterialRequestItemUpdateManyWithoutMaterialRequestNestedInput
  }

  export type MaterialRequestUncheckedUpdateWithoutRfqsInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    requesterId?: IntFieldUpdateOperationsInput | number
    approverId?: NullableIntFieldUpdateOperationsInput | number | null
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumMrStatusFieldUpdateOperationsInput | $Enums.MrStatus
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: MaterialRequestItemUncheckedUpdateManyWithoutMaterialRequestNestedInput
  }

  export type UserUpsertWithoutRfqsCreatedInput = {
    update: XOR<UserUpdateWithoutRfqsCreatedInput, UserUncheckedUpdateWithoutRfqsCreatedInput>
    create: XOR<UserCreateWithoutRfqsCreatedInput, UserUncheckedCreateWithoutRfqsCreatedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRfqsCreatedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRfqsCreatedInput, UserUncheckedUpdateWithoutRfqsCreatedInput>
  }

  export type UserUpdateWithoutRfqsCreatedInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrders?: PurchaseOrderUpdateManyWithoutRequesterNestedInput
    poApprovals?: PurchaseOrderUpdateManyWithoutApproverNestedInput
    materialRequests?: MaterialRequestUpdateManyWithoutRequesterNestedInput
    mrApprovals?: MaterialRequestUpdateManyWithoutApproverNestedInput
    receivedItems?: ReceivingReportUpdateManyWithoutReceivedByNestedInput
    disbursements?: DisbursementUpdateManyWithoutProcessedByNestedInput
    projectMembers?: ProjectMemberUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRfqsCreatedInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutRequesterNestedInput
    poApprovals?: PurchaseOrderUncheckedUpdateManyWithoutApproverNestedInput
    materialRequests?: MaterialRequestUncheckedUpdateManyWithoutRequesterNestedInput
    mrApprovals?: MaterialRequestUncheckedUpdateManyWithoutApproverNestedInput
    receivedItems?: ReceivingReportUncheckedUpdateManyWithoutReceivedByNestedInput
    disbursements?: DisbursementUncheckedUpdateManyWithoutProcessedByNestedInput
    projectMembers?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
  }

  export type RFQItemUpsertWithWhereUniqueWithoutRfqInput = {
    where: RFQItemWhereUniqueInput
    update: XOR<RFQItemUpdateWithoutRfqInput, RFQItemUncheckedUpdateWithoutRfqInput>
    create: XOR<RFQItemCreateWithoutRfqInput, RFQItemUncheckedCreateWithoutRfqInput>
  }

  export type RFQItemUpdateWithWhereUniqueWithoutRfqInput = {
    where: RFQItemWhereUniqueInput
    data: XOR<RFQItemUpdateWithoutRfqInput, RFQItemUncheckedUpdateWithoutRfqInput>
  }

  export type RFQItemUpdateManyWithWhereWithoutRfqInput = {
    where: RFQItemScalarWhereInput
    data: XOR<RFQItemUpdateManyMutationInput, RFQItemUncheckedUpdateManyWithoutRfqInput>
  }

  export type RFQItemScalarWhereInput = {
    AND?: RFQItemScalarWhereInput | RFQItemScalarWhereInput[]
    OR?: RFQItemScalarWhereInput[]
    NOT?: RFQItemScalarWhereInput | RFQItemScalarWhereInput[]
    id?: IntFilter<"RFQItem"> | number
    rfqId?: IntFilter<"RFQItem"> | number
    materialName?: StringFilter<"RFQItem"> | string
    quantity?: DecimalFilter<"RFQItem"> | Decimal | DecimalJsLike | number | string
    unit?: StringFilter<"RFQItem"> | string
  }

  export type SupplierQuotationUpsertWithWhereUniqueWithoutRfqInput = {
    where: SupplierQuotationWhereUniqueInput
    update: XOR<SupplierQuotationUpdateWithoutRfqInput, SupplierQuotationUncheckedUpdateWithoutRfqInput>
    create: XOR<SupplierQuotationCreateWithoutRfqInput, SupplierQuotationUncheckedCreateWithoutRfqInput>
  }

  export type SupplierQuotationUpdateWithWhereUniqueWithoutRfqInput = {
    where: SupplierQuotationWhereUniqueInput
    data: XOR<SupplierQuotationUpdateWithoutRfqInput, SupplierQuotationUncheckedUpdateWithoutRfqInput>
  }

  export type SupplierQuotationUpdateManyWithWhereWithoutRfqInput = {
    where: SupplierQuotationScalarWhereInput
    data: XOR<SupplierQuotationUpdateManyMutationInput, SupplierQuotationUncheckedUpdateManyWithoutRfqInput>
  }

  export type SupplierQuotationScalarWhereInput = {
    AND?: SupplierQuotationScalarWhereInput | SupplierQuotationScalarWhereInput[]
    OR?: SupplierQuotationScalarWhereInput[]
    NOT?: SupplierQuotationScalarWhereInput | SupplierQuotationScalarWhereInput[]
    id?: IntFilter<"SupplierQuotation"> | number
    rfqId?: IntFilter<"SupplierQuotation"> | number
    supplierId?: IntFilter<"SupplierQuotation"> | number
    quoteDate?: DateTimeFilter<"SupplierQuotation"> | Date | string
    totalAmount?: DecimalFilter<"SupplierQuotation"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"SupplierQuotation"> | string
    isSelected?: BoolFilter<"SupplierQuotation"> | boolean
  }

  export type RFQCreateWithoutItemsInput = {
    title: string
    status?: $Enums.RfqStatus
    dueDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    materialRequest?: MaterialRequestCreateNestedOneWithoutRfqsInput
    createdBy: UserCreateNestedOneWithoutRfqsCreatedInput
    quotations?: SupplierQuotationCreateNestedManyWithoutRfqInput
  }

  export type RFQUncheckedCreateWithoutItemsInput = {
    id?: number
    mrId?: number | null
    createdById: number
    title: string
    status?: $Enums.RfqStatus
    dueDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    quotations?: SupplierQuotationUncheckedCreateNestedManyWithoutRfqInput
  }

  export type RFQCreateOrConnectWithoutItemsInput = {
    where: RFQWhereUniqueInput
    create: XOR<RFQCreateWithoutItemsInput, RFQUncheckedCreateWithoutItemsInput>
  }

  export type RFQUpsertWithoutItemsInput = {
    update: XOR<RFQUpdateWithoutItemsInput, RFQUncheckedUpdateWithoutItemsInput>
    create: XOR<RFQCreateWithoutItemsInput, RFQUncheckedCreateWithoutItemsInput>
    where?: RFQWhereInput
  }

  export type RFQUpdateToOneWithWhereWithoutItemsInput = {
    where?: RFQWhereInput
    data: XOR<RFQUpdateWithoutItemsInput, RFQUncheckedUpdateWithoutItemsInput>
  }

  export type RFQUpdateWithoutItemsInput = {
    title?: StringFieldUpdateOperationsInput | string
    status?: EnumRfqStatusFieldUpdateOperationsInput | $Enums.RfqStatus
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    materialRequest?: MaterialRequestUpdateOneWithoutRfqsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutRfqsCreatedNestedInput
    quotations?: SupplierQuotationUpdateManyWithoutRfqNestedInput
  }

  export type RFQUncheckedUpdateWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    mrId?: NullableIntFieldUpdateOperationsInput | number | null
    createdById?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    status?: EnumRfqStatusFieldUpdateOperationsInput | $Enums.RfqStatus
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quotations?: SupplierQuotationUncheckedUpdateManyWithoutRfqNestedInput
  }

  export type SupplierQuotationCreateWithoutSupplierInput = {
    quoteDate?: Date | string
    totalAmount?: Decimal | DecimalJsLike | number | string
    currency?: string
    isSelected?: boolean
    rfq: RFQCreateNestedOneWithoutQuotationsInput
    items?: QuotationItemCreateNestedManyWithoutSupplierQuotationInput
  }

  export type SupplierQuotationUncheckedCreateWithoutSupplierInput = {
    id?: number
    rfqId: number
    quoteDate?: Date | string
    totalAmount?: Decimal | DecimalJsLike | number | string
    currency?: string
    isSelected?: boolean
    items?: QuotationItemUncheckedCreateNestedManyWithoutSupplierQuotationInput
  }

  export type SupplierQuotationCreateOrConnectWithoutSupplierInput = {
    where: SupplierQuotationWhereUniqueInput
    create: XOR<SupplierQuotationCreateWithoutSupplierInput, SupplierQuotationUncheckedCreateWithoutSupplierInput>
  }

  export type SupplierQuotationCreateManySupplierInputEnvelope = {
    data: SupplierQuotationCreateManySupplierInput | SupplierQuotationCreateManySupplierInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseOrderCreateWithoutSupplierInput = {
    orderDate?: Date | string
    status?: $Enums.PoStatus
    remarks?: string | null
    totalAmount?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutPurchaseOrdersInput
    requester: UserCreateNestedOneWithoutPurchaseOrdersInput
    approver?: UserCreateNestedOneWithoutPoApprovalsInput
    items?: PurchaseOrderItemCreateNestedManyWithoutPurchaseOrderInput
    receiving?: ReceivingReportCreateNestedManyWithoutPurchaseOrderInput
    invoices?: SupplierInvoiceCreateNestedManyWithoutPurchaseOrderInput
    disbursements?: DisbursementCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseOrderUncheckedCreateWithoutSupplierInput = {
    id?: number
    orderDate?: Date | string
    projectId: number
    requesterId: number
    approverId?: number | null
    status?: $Enums.PoStatus
    remarks?: string | null
    totalAmount?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: PurchaseOrderItemUncheckedCreateNestedManyWithoutPurchaseOrderInput
    receiving?: ReceivingReportUncheckedCreateNestedManyWithoutPurchaseOrderInput
    invoices?: SupplierInvoiceUncheckedCreateNestedManyWithoutPurchaseOrderInput
    disbursements?: DisbursementUncheckedCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseOrderCreateOrConnectWithoutSupplierInput = {
    where: PurchaseOrderWhereUniqueInput
    create: XOR<PurchaseOrderCreateWithoutSupplierInput, PurchaseOrderUncheckedCreateWithoutSupplierInput>
  }

  export type PurchaseOrderCreateManySupplierInputEnvelope = {
    data: PurchaseOrderCreateManySupplierInput | PurchaseOrderCreateManySupplierInput[]
    skipDuplicates?: boolean
  }

  export type SupplierInvoiceCreateWithoutSupplierInput = {
    invoiceNumber: string
    invoiceDate: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    status?: string
    createdAt?: Date | string
    purchaseOrder?: PurchaseOrderCreateNestedOneWithoutInvoicesInput
    receivingReport?: ReceivingReportCreateNestedOneWithoutInvoicesInput
  }

  export type SupplierInvoiceUncheckedCreateWithoutSupplierInput = {
    id?: number
    invoiceNumber: string
    invoiceDate: Date | string
    purchaseOrderId?: number | null
    receivingReportId?: number | null
    totalAmount: Decimal | DecimalJsLike | number | string
    status?: string
    createdAt?: Date | string
  }

  export type SupplierInvoiceCreateOrConnectWithoutSupplierInput = {
    where: SupplierInvoiceWhereUniqueInput
    create: XOR<SupplierInvoiceCreateWithoutSupplierInput, SupplierInvoiceUncheckedCreateWithoutSupplierInput>
  }

  export type SupplierInvoiceCreateManySupplierInputEnvelope = {
    data: SupplierInvoiceCreateManySupplierInput | SupplierInvoiceCreateManySupplierInput[]
    skipDuplicates?: boolean
  }

  export type SupplierQuotationUpsertWithWhereUniqueWithoutSupplierInput = {
    where: SupplierQuotationWhereUniqueInput
    update: XOR<SupplierQuotationUpdateWithoutSupplierInput, SupplierQuotationUncheckedUpdateWithoutSupplierInput>
    create: XOR<SupplierQuotationCreateWithoutSupplierInput, SupplierQuotationUncheckedCreateWithoutSupplierInput>
  }

  export type SupplierQuotationUpdateWithWhereUniqueWithoutSupplierInput = {
    where: SupplierQuotationWhereUniqueInput
    data: XOR<SupplierQuotationUpdateWithoutSupplierInput, SupplierQuotationUncheckedUpdateWithoutSupplierInput>
  }

  export type SupplierQuotationUpdateManyWithWhereWithoutSupplierInput = {
    where: SupplierQuotationScalarWhereInput
    data: XOR<SupplierQuotationUpdateManyMutationInput, SupplierQuotationUncheckedUpdateManyWithoutSupplierInput>
  }

  export type PurchaseOrderUpsertWithWhereUniqueWithoutSupplierInput = {
    where: PurchaseOrderWhereUniqueInput
    update: XOR<PurchaseOrderUpdateWithoutSupplierInput, PurchaseOrderUncheckedUpdateWithoutSupplierInput>
    create: XOR<PurchaseOrderCreateWithoutSupplierInput, PurchaseOrderUncheckedCreateWithoutSupplierInput>
  }

  export type PurchaseOrderUpdateWithWhereUniqueWithoutSupplierInput = {
    where: PurchaseOrderWhereUniqueInput
    data: XOR<PurchaseOrderUpdateWithoutSupplierInput, PurchaseOrderUncheckedUpdateWithoutSupplierInput>
  }

  export type PurchaseOrderUpdateManyWithWhereWithoutSupplierInput = {
    where: PurchaseOrderScalarWhereInput
    data: XOR<PurchaseOrderUpdateManyMutationInput, PurchaseOrderUncheckedUpdateManyWithoutSupplierInput>
  }

  export type SupplierInvoiceUpsertWithWhereUniqueWithoutSupplierInput = {
    where: SupplierInvoiceWhereUniqueInput
    update: XOR<SupplierInvoiceUpdateWithoutSupplierInput, SupplierInvoiceUncheckedUpdateWithoutSupplierInput>
    create: XOR<SupplierInvoiceCreateWithoutSupplierInput, SupplierInvoiceUncheckedCreateWithoutSupplierInput>
  }

  export type SupplierInvoiceUpdateWithWhereUniqueWithoutSupplierInput = {
    where: SupplierInvoiceWhereUniqueInput
    data: XOR<SupplierInvoiceUpdateWithoutSupplierInput, SupplierInvoiceUncheckedUpdateWithoutSupplierInput>
  }

  export type SupplierInvoiceUpdateManyWithWhereWithoutSupplierInput = {
    where: SupplierInvoiceScalarWhereInput
    data: XOR<SupplierInvoiceUpdateManyMutationInput, SupplierInvoiceUncheckedUpdateManyWithoutSupplierInput>
  }

  export type SupplierInvoiceScalarWhereInput = {
    AND?: SupplierInvoiceScalarWhereInput | SupplierInvoiceScalarWhereInput[]
    OR?: SupplierInvoiceScalarWhereInput[]
    NOT?: SupplierInvoiceScalarWhereInput | SupplierInvoiceScalarWhereInput[]
    id?: IntFilter<"SupplierInvoice"> | number
    invoiceNumber?: StringFilter<"SupplierInvoice"> | string
    invoiceDate?: DateTimeFilter<"SupplierInvoice"> | Date | string
    supplierId?: IntFilter<"SupplierInvoice"> | number
    purchaseOrderId?: IntNullableFilter<"SupplierInvoice"> | number | null
    receivingReportId?: IntNullableFilter<"SupplierInvoice"> | number | null
    totalAmount?: DecimalFilter<"SupplierInvoice"> | Decimal | DecimalJsLike | number | string
    status?: StringFilter<"SupplierInvoice"> | string
    createdAt?: DateTimeFilter<"SupplierInvoice"> | Date | string
  }

  export type InventoryItemCreateWithoutWarehouseInput = {
    materialName: string
    quantity: Decimal | DecimalJsLike | number | string
    unit: string
    lastUpdated?: Date | string
    project?: ProjectCreateNestedOneWithoutInventoryInput
  }

  export type InventoryItemUncheckedCreateWithoutWarehouseInput = {
    id?: number
    materialName: string
    projectId?: number | null
    quantity: Decimal | DecimalJsLike | number | string
    unit: string
    lastUpdated?: Date | string
  }

  export type InventoryItemCreateOrConnectWithoutWarehouseInput = {
    where: InventoryItemWhereUniqueInput
    create: XOR<InventoryItemCreateWithoutWarehouseInput, InventoryItemUncheckedCreateWithoutWarehouseInput>
  }

  export type InventoryItemCreateManyWarehouseInputEnvelope = {
    data: InventoryItemCreateManyWarehouseInput | InventoryItemCreateManyWarehouseInput[]
    skipDuplicates?: boolean
  }

  export type InventoryItemUpsertWithWhereUniqueWithoutWarehouseInput = {
    where: InventoryItemWhereUniqueInput
    update: XOR<InventoryItemUpdateWithoutWarehouseInput, InventoryItemUncheckedUpdateWithoutWarehouseInput>
    create: XOR<InventoryItemCreateWithoutWarehouseInput, InventoryItemUncheckedCreateWithoutWarehouseInput>
  }

  export type InventoryItemUpdateWithWhereUniqueWithoutWarehouseInput = {
    where: InventoryItemWhereUniqueInput
    data: XOR<InventoryItemUpdateWithoutWarehouseInput, InventoryItemUncheckedUpdateWithoutWarehouseInput>
  }

  export type InventoryItemUpdateManyWithWhereWithoutWarehouseInput = {
    where: InventoryItemScalarWhereInput
    data: XOR<InventoryItemUpdateManyMutationInput, InventoryItemUncheckedUpdateManyWithoutWarehouseInput>
  }

  export type RFQCreateWithoutQuotationsInput = {
    title: string
    status?: $Enums.RfqStatus
    dueDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    materialRequest?: MaterialRequestCreateNestedOneWithoutRfqsInput
    createdBy: UserCreateNestedOneWithoutRfqsCreatedInput
    items?: RFQItemCreateNestedManyWithoutRfqInput
  }

  export type RFQUncheckedCreateWithoutQuotationsInput = {
    id?: number
    mrId?: number | null
    createdById: number
    title: string
    status?: $Enums.RfqStatus
    dueDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: RFQItemUncheckedCreateNestedManyWithoutRfqInput
  }

  export type RFQCreateOrConnectWithoutQuotationsInput = {
    where: RFQWhereUniqueInput
    create: XOR<RFQCreateWithoutQuotationsInput, RFQUncheckedCreateWithoutQuotationsInput>
  }

  export type SupplierCreateWithoutQuotationsInput = {
    name: string
    contactPerson?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    rating?: number | null
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutSupplierInput
    invoices?: SupplierInvoiceCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUncheckedCreateWithoutQuotationsInput = {
    id?: number
    name: string
    contactPerson?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    rating?: number | null
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutSupplierInput
    invoices?: SupplierInvoiceUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type SupplierCreateOrConnectWithoutQuotationsInput = {
    where: SupplierWhereUniqueInput
    create: XOR<SupplierCreateWithoutQuotationsInput, SupplierUncheckedCreateWithoutQuotationsInput>
  }

  export type QuotationItemCreateWithoutSupplierQuotationInput = {
    materialName: string
    quantity: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    remarks?: string | null
  }

  export type QuotationItemUncheckedCreateWithoutSupplierQuotationInput = {
    id?: number
    materialName: string
    quantity: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    remarks?: string | null
  }

  export type QuotationItemCreateOrConnectWithoutSupplierQuotationInput = {
    where: QuotationItemWhereUniqueInput
    create: XOR<QuotationItemCreateWithoutSupplierQuotationInput, QuotationItemUncheckedCreateWithoutSupplierQuotationInput>
  }

  export type QuotationItemCreateManySupplierQuotationInputEnvelope = {
    data: QuotationItemCreateManySupplierQuotationInput | QuotationItemCreateManySupplierQuotationInput[]
    skipDuplicates?: boolean
  }

  export type RFQUpsertWithoutQuotationsInput = {
    update: XOR<RFQUpdateWithoutQuotationsInput, RFQUncheckedUpdateWithoutQuotationsInput>
    create: XOR<RFQCreateWithoutQuotationsInput, RFQUncheckedCreateWithoutQuotationsInput>
    where?: RFQWhereInput
  }

  export type RFQUpdateToOneWithWhereWithoutQuotationsInput = {
    where?: RFQWhereInput
    data: XOR<RFQUpdateWithoutQuotationsInput, RFQUncheckedUpdateWithoutQuotationsInput>
  }

  export type RFQUpdateWithoutQuotationsInput = {
    title?: StringFieldUpdateOperationsInput | string
    status?: EnumRfqStatusFieldUpdateOperationsInput | $Enums.RfqStatus
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    materialRequest?: MaterialRequestUpdateOneWithoutRfqsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutRfqsCreatedNestedInput
    items?: RFQItemUpdateManyWithoutRfqNestedInput
  }

  export type RFQUncheckedUpdateWithoutQuotationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    mrId?: NullableIntFieldUpdateOperationsInput | number | null
    createdById?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    status?: EnumRfqStatusFieldUpdateOperationsInput | $Enums.RfqStatus
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: RFQItemUncheckedUpdateManyWithoutRfqNestedInput
  }

  export type SupplierUpsertWithoutQuotationsInput = {
    update: XOR<SupplierUpdateWithoutQuotationsInput, SupplierUncheckedUpdateWithoutQuotationsInput>
    create: XOR<SupplierCreateWithoutQuotationsInput, SupplierUncheckedCreateWithoutQuotationsInput>
    where?: SupplierWhereInput
  }

  export type SupplierUpdateToOneWithWhereWithoutQuotationsInput = {
    where?: SupplierWhereInput
    data: XOR<SupplierUpdateWithoutQuotationsInput, SupplierUncheckedUpdateWithoutQuotationsInput>
  }

  export type SupplierUpdateWithoutQuotationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    purchaseOrders?: PurchaseOrderUpdateManyWithoutSupplierNestedInput
    invoices?: SupplierInvoiceUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierUncheckedUpdateWithoutQuotationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutSupplierNestedInput
    invoices?: SupplierInvoiceUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type QuotationItemUpsertWithWhereUniqueWithoutSupplierQuotationInput = {
    where: QuotationItemWhereUniqueInput
    update: XOR<QuotationItemUpdateWithoutSupplierQuotationInput, QuotationItemUncheckedUpdateWithoutSupplierQuotationInput>
    create: XOR<QuotationItemCreateWithoutSupplierQuotationInput, QuotationItemUncheckedCreateWithoutSupplierQuotationInput>
  }

  export type QuotationItemUpdateWithWhereUniqueWithoutSupplierQuotationInput = {
    where: QuotationItemWhereUniqueInput
    data: XOR<QuotationItemUpdateWithoutSupplierQuotationInput, QuotationItemUncheckedUpdateWithoutSupplierQuotationInput>
  }

  export type QuotationItemUpdateManyWithWhereWithoutSupplierQuotationInput = {
    where: QuotationItemScalarWhereInput
    data: XOR<QuotationItemUpdateManyMutationInput, QuotationItemUncheckedUpdateManyWithoutSupplierQuotationInput>
  }

  export type QuotationItemScalarWhereInput = {
    AND?: QuotationItemScalarWhereInput | QuotationItemScalarWhereInput[]
    OR?: QuotationItemScalarWhereInput[]
    NOT?: QuotationItemScalarWhereInput | QuotationItemScalarWhereInput[]
    id?: IntFilter<"QuotationItem"> | number
    supplierQuotationId?: IntFilter<"QuotationItem"> | number
    materialName?: StringFilter<"QuotationItem"> | string
    quantity?: DecimalFilter<"QuotationItem"> | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFilter<"QuotationItem"> | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFilter<"QuotationItem"> | Decimal | DecimalJsLike | number | string
    remarks?: StringNullableFilter<"QuotationItem"> | string | null
  }

  export type SupplierQuotationCreateWithoutItemsInput = {
    quoteDate?: Date | string
    totalAmount?: Decimal | DecimalJsLike | number | string
    currency?: string
    isSelected?: boolean
    rfq: RFQCreateNestedOneWithoutQuotationsInput
    supplier: SupplierCreateNestedOneWithoutQuotationsInput
  }

  export type SupplierQuotationUncheckedCreateWithoutItemsInput = {
    id?: number
    rfqId: number
    supplierId: number
    quoteDate?: Date | string
    totalAmount?: Decimal | DecimalJsLike | number | string
    currency?: string
    isSelected?: boolean
  }

  export type SupplierQuotationCreateOrConnectWithoutItemsInput = {
    where: SupplierQuotationWhereUniqueInput
    create: XOR<SupplierQuotationCreateWithoutItemsInput, SupplierQuotationUncheckedCreateWithoutItemsInput>
  }

  export type SupplierQuotationUpsertWithoutItemsInput = {
    update: XOR<SupplierQuotationUpdateWithoutItemsInput, SupplierQuotationUncheckedUpdateWithoutItemsInput>
    create: XOR<SupplierQuotationCreateWithoutItemsInput, SupplierQuotationUncheckedCreateWithoutItemsInput>
    where?: SupplierQuotationWhereInput
  }

  export type SupplierQuotationUpdateToOneWithWhereWithoutItemsInput = {
    where?: SupplierQuotationWhereInput
    data: XOR<SupplierQuotationUpdateWithoutItemsInput, SupplierQuotationUncheckedUpdateWithoutItemsInput>
  }

  export type SupplierQuotationUpdateWithoutItemsInput = {
    quoteDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    isSelected?: BoolFieldUpdateOperationsInput | boolean
    rfq?: RFQUpdateOneRequiredWithoutQuotationsNestedInput
    supplier?: SupplierUpdateOneRequiredWithoutQuotationsNestedInput
  }

  export type SupplierQuotationUncheckedUpdateWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    rfqId?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
    quoteDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    isSelected?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProjectCreateWithoutPurchaseOrdersInput = {
    name: string
    location?: string | null
    duration?: string | null
    budget: Decimal | DecimalJsLike | number | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    totalFloorArea?: Decimal | DecimalJsLike | number | string | null
    carportArea?: Decimal | DecimalJsLike | number | string | null
    client?: ClientCreateNestedOneWithoutProjectsInput
    transactions?: FinancialTransactionCreateNestedManyWithoutProjectInput
    inventory?: InventoryItemCreateNestedManyWithoutProjectInput
    teamMembers?: ProjectMemberCreateNestedManyWithoutProjectInput
    boqItems?: BoqItemCreateNestedManyWithoutProjectInput
    materialRequests?: MaterialRequestCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutPurchaseOrdersInput = {
    id?: number
    clientId?: number | null
    name: string
    location?: string | null
    duration?: string | null
    budget: Decimal | DecimalJsLike | number | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    totalFloorArea?: Decimal | DecimalJsLike | number | string | null
    carportArea?: Decimal | DecimalJsLike | number | string | null
    transactions?: FinancialTransactionUncheckedCreateNestedManyWithoutProjectInput
    inventory?: InventoryItemUncheckedCreateNestedManyWithoutProjectInput
    teamMembers?: ProjectMemberUncheckedCreateNestedManyWithoutProjectInput
    boqItems?: BoqItemUncheckedCreateNestedManyWithoutProjectInput
    materialRequests?: MaterialRequestUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutPurchaseOrdersInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutPurchaseOrdersInput, ProjectUncheckedCreateWithoutPurchaseOrdersInput>
  }

  export type SupplierCreateWithoutPurchaseOrdersInput = {
    name: string
    contactPerson?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    rating?: number | null
    quotations?: SupplierQuotationCreateNestedManyWithoutSupplierInput
    invoices?: SupplierInvoiceCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUncheckedCreateWithoutPurchaseOrdersInput = {
    id?: number
    name: string
    contactPerson?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    rating?: number | null
    quotations?: SupplierQuotationUncheckedCreateNestedManyWithoutSupplierInput
    invoices?: SupplierInvoiceUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type SupplierCreateOrConnectWithoutPurchaseOrdersInput = {
    where: SupplierWhereUniqueInput
    create: XOR<SupplierCreateWithoutPurchaseOrdersInput, SupplierUncheckedCreateWithoutPurchaseOrdersInput>
  }

  export type UserCreateWithoutPurchaseOrdersInput = {
    email: string
    name: string
    password: string
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    poApprovals?: PurchaseOrderCreateNestedManyWithoutApproverInput
    materialRequests?: MaterialRequestCreateNestedManyWithoutRequesterInput
    mrApprovals?: MaterialRequestCreateNestedManyWithoutApproverInput
    rfqsCreated?: RFQCreateNestedManyWithoutCreatedByInput
    receivedItems?: ReceivingReportCreateNestedManyWithoutReceivedByInput
    disbursements?: DisbursementCreateNestedManyWithoutProcessedByInput
    projectMembers?: ProjectMemberCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPurchaseOrdersInput = {
    id?: number
    email: string
    name: string
    password: string
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    poApprovals?: PurchaseOrderUncheckedCreateNestedManyWithoutApproverInput
    materialRequests?: MaterialRequestUncheckedCreateNestedManyWithoutRequesterInput
    mrApprovals?: MaterialRequestUncheckedCreateNestedManyWithoutApproverInput
    rfqsCreated?: RFQUncheckedCreateNestedManyWithoutCreatedByInput
    receivedItems?: ReceivingReportUncheckedCreateNestedManyWithoutReceivedByInput
    disbursements?: DisbursementUncheckedCreateNestedManyWithoutProcessedByInput
    projectMembers?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPurchaseOrdersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPurchaseOrdersInput, UserUncheckedCreateWithoutPurchaseOrdersInput>
  }

  export type UserCreateWithoutPoApprovalsInput = {
    email: string
    name: string
    password: string
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutRequesterInput
    materialRequests?: MaterialRequestCreateNestedManyWithoutRequesterInput
    mrApprovals?: MaterialRequestCreateNestedManyWithoutApproverInput
    rfqsCreated?: RFQCreateNestedManyWithoutCreatedByInput
    receivedItems?: ReceivingReportCreateNestedManyWithoutReceivedByInput
    disbursements?: DisbursementCreateNestedManyWithoutProcessedByInput
    projectMembers?: ProjectMemberCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPoApprovalsInput = {
    id?: number
    email: string
    name: string
    password: string
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutRequesterInput
    materialRequests?: MaterialRequestUncheckedCreateNestedManyWithoutRequesterInput
    mrApprovals?: MaterialRequestUncheckedCreateNestedManyWithoutApproverInput
    rfqsCreated?: RFQUncheckedCreateNestedManyWithoutCreatedByInput
    receivedItems?: ReceivingReportUncheckedCreateNestedManyWithoutReceivedByInput
    disbursements?: DisbursementUncheckedCreateNestedManyWithoutProcessedByInput
    projectMembers?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPoApprovalsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPoApprovalsInput, UserUncheckedCreateWithoutPoApprovalsInput>
  }

  export type PurchaseOrderItemCreateWithoutPurchaseOrderInput = {
    materialName: string
    description?: string | null
    quantity: Decimal | DecimalJsLike | number | string
    unit: string
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
  }

  export type PurchaseOrderItemUncheckedCreateWithoutPurchaseOrderInput = {
    id?: number
    materialName: string
    description?: string | null
    quantity: Decimal | DecimalJsLike | number | string
    unit: string
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
  }

  export type PurchaseOrderItemCreateOrConnectWithoutPurchaseOrderInput = {
    where: PurchaseOrderItemWhereUniqueInput
    create: XOR<PurchaseOrderItemCreateWithoutPurchaseOrderInput, PurchaseOrderItemUncheckedCreateWithoutPurchaseOrderInput>
  }

  export type PurchaseOrderItemCreateManyPurchaseOrderInputEnvelope = {
    data: PurchaseOrderItemCreateManyPurchaseOrderInput | PurchaseOrderItemCreateManyPurchaseOrderInput[]
    skipDuplicates?: boolean
  }

  export type ReceivingReportCreateWithoutPurchaseOrderInput = {
    receivedDate?: Date | string
    deliveryNoteNo?: string | null
    notes?: string | null
    receivedBy: UserCreateNestedOneWithoutReceivedItemsInput
    items?: ReceivingItemCreateNestedManyWithoutReceivingReportInput
    invoices?: SupplierInvoiceCreateNestedManyWithoutReceivingReportInput
  }

  export type ReceivingReportUncheckedCreateWithoutPurchaseOrderInput = {
    id?: number
    receivedById: number
    receivedDate?: Date | string
    deliveryNoteNo?: string | null
    notes?: string | null
    items?: ReceivingItemUncheckedCreateNestedManyWithoutReceivingReportInput
    invoices?: SupplierInvoiceUncheckedCreateNestedManyWithoutReceivingReportInput
  }

  export type ReceivingReportCreateOrConnectWithoutPurchaseOrderInput = {
    where: ReceivingReportWhereUniqueInput
    create: XOR<ReceivingReportCreateWithoutPurchaseOrderInput, ReceivingReportUncheckedCreateWithoutPurchaseOrderInput>
  }

  export type ReceivingReportCreateManyPurchaseOrderInputEnvelope = {
    data: ReceivingReportCreateManyPurchaseOrderInput | ReceivingReportCreateManyPurchaseOrderInput[]
    skipDuplicates?: boolean
  }

  export type SupplierInvoiceCreateWithoutPurchaseOrderInput = {
    invoiceNumber: string
    invoiceDate: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    status?: string
    createdAt?: Date | string
    supplier: SupplierCreateNestedOneWithoutInvoicesInput
    receivingReport?: ReceivingReportCreateNestedOneWithoutInvoicesInput
  }

  export type SupplierInvoiceUncheckedCreateWithoutPurchaseOrderInput = {
    id?: number
    invoiceNumber: string
    invoiceDate: Date | string
    supplierId: number
    receivingReportId?: number | null
    totalAmount: Decimal | DecimalJsLike | number | string
    status?: string
    createdAt?: Date | string
  }

  export type SupplierInvoiceCreateOrConnectWithoutPurchaseOrderInput = {
    where: SupplierInvoiceWhereUniqueInput
    create: XOR<SupplierInvoiceCreateWithoutPurchaseOrderInput, SupplierInvoiceUncheckedCreateWithoutPurchaseOrderInput>
  }

  export type SupplierInvoiceCreateManyPurchaseOrderInputEnvelope = {
    data: SupplierInvoiceCreateManyPurchaseOrderInput | SupplierInvoiceCreateManyPurchaseOrderInput[]
    skipDuplicates?: boolean
  }

  export type DisbursementCreateWithoutPurchaseOrderInput = {
    amount: Decimal | DecimalJsLike | number | string
    paymentDate?: Date | string
    method: $Enums.PaymentMethod
    referenceNumber?: string | null
    status?: string
    processedBy: UserCreateNestedOneWithoutDisbursementsInput
  }

  export type DisbursementUncheckedCreateWithoutPurchaseOrderInput = {
    id?: number
    processedById: number
    amount: Decimal | DecimalJsLike | number | string
    paymentDate?: Date | string
    method: $Enums.PaymentMethod
    referenceNumber?: string | null
    status?: string
  }

  export type DisbursementCreateOrConnectWithoutPurchaseOrderInput = {
    where: DisbursementWhereUniqueInput
    create: XOR<DisbursementCreateWithoutPurchaseOrderInput, DisbursementUncheckedCreateWithoutPurchaseOrderInput>
  }

  export type DisbursementCreateManyPurchaseOrderInputEnvelope = {
    data: DisbursementCreateManyPurchaseOrderInput | DisbursementCreateManyPurchaseOrderInput[]
    skipDuplicates?: boolean
  }

  export type ProjectUpsertWithoutPurchaseOrdersInput = {
    update: XOR<ProjectUpdateWithoutPurchaseOrdersInput, ProjectUncheckedUpdateWithoutPurchaseOrdersInput>
    create: XOR<ProjectCreateWithoutPurchaseOrdersInput, ProjectUncheckedCreateWithoutPurchaseOrdersInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutPurchaseOrdersInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutPurchaseOrdersInput, ProjectUncheckedUpdateWithoutPurchaseOrdersInput>
  }

  export type ProjectUpdateWithoutPurchaseOrdersInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalFloorArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    carportArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    client?: ClientUpdateOneWithoutProjectsNestedInput
    transactions?: FinancialTransactionUpdateManyWithoutProjectNestedInput
    inventory?: InventoryItemUpdateManyWithoutProjectNestedInput
    teamMembers?: ProjectMemberUpdateManyWithoutProjectNestedInput
    boqItems?: BoqItemUpdateManyWithoutProjectNestedInput
    materialRequests?: MaterialRequestUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutPurchaseOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalFloorArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    carportArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    transactions?: FinancialTransactionUncheckedUpdateManyWithoutProjectNestedInput
    inventory?: InventoryItemUncheckedUpdateManyWithoutProjectNestedInput
    teamMembers?: ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
    boqItems?: BoqItemUncheckedUpdateManyWithoutProjectNestedInput
    materialRequests?: MaterialRequestUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type SupplierUpsertWithoutPurchaseOrdersInput = {
    update: XOR<SupplierUpdateWithoutPurchaseOrdersInput, SupplierUncheckedUpdateWithoutPurchaseOrdersInput>
    create: XOR<SupplierCreateWithoutPurchaseOrdersInput, SupplierUncheckedCreateWithoutPurchaseOrdersInput>
    where?: SupplierWhereInput
  }

  export type SupplierUpdateToOneWithWhereWithoutPurchaseOrdersInput = {
    where?: SupplierWhereInput
    data: XOR<SupplierUpdateWithoutPurchaseOrdersInput, SupplierUncheckedUpdateWithoutPurchaseOrdersInput>
  }

  export type SupplierUpdateWithoutPurchaseOrdersInput = {
    name?: StringFieldUpdateOperationsInput | string
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    quotations?: SupplierQuotationUpdateManyWithoutSupplierNestedInput
    invoices?: SupplierInvoiceUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierUncheckedUpdateWithoutPurchaseOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    quotations?: SupplierQuotationUncheckedUpdateManyWithoutSupplierNestedInput
    invoices?: SupplierInvoiceUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type UserUpsertWithoutPurchaseOrdersInput = {
    update: XOR<UserUpdateWithoutPurchaseOrdersInput, UserUncheckedUpdateWithoutPurchaseOrdersInput>
    create: XOR<UserCreateWithoutPurchaseOrdersInput, UserUncheckedCreateWithoutPurchaseOrdersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPurchaseOrdersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPurchaseOrdersInput, UserUncheckedUpdateWithoutPurchaseOrdersInput>
  }

  export type UserUpdateWithoutPurchaseOrdersInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    poApprovals?: PurchaseOrderUpdateManyWithoutApproverNestedInput
    materialRequests?: MaterialRequestUpdateManyWithoutRequesterNestedInput
    mrApprovals?: MaterialRequestUpdateManyWithoutApproverNestedInput
    rfqsCreated?: RFQUpdateManyWithoutCreatedByNestedInput
    receivedItems?: ReceivingReportUpdateManyWithoutReceivedByNestedInput
    disbursements?: DisbursementUpdateManyWithoutProcessedByNestedInput
    projectMembers?: ProjectMemberUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPurchaseOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    poApprovals?: PurchaseOrderUncheckedUpdateManyWithoutApproverNestedInput
    materialRequests?: MaterialRequestUncheckedUpdateManyWithoutRequesterNestedInput
    mrApprovals?: MaterialRequestUncheckedUpdateManyWithoutApproverNestedInput
    rfqsCreated?: RFQUncheckedUpdateManyWithoutCreatedByNestedInput
    receivedItems?: ReceivingReportUncheckedUpdateManyWithoutReceivedByNestedInput
    disbursements?: DisbursementUncheckedUpdateManyWithoutProcessedByNestedInput
    projectMembers?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutPoApprovalsInput = {
    update: XOR<UserUpdateWithoutPoApprovalsInput, UserUncheckedUpdateWithoutPoApprovalsInput>
    create: XOR<UserCreateWithoutPoApprovalsInput, UserUncheckedCreateWithoutPoApprovalsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPoApprovalsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPoApprovalsInput, UserUncheckedUpdateWithoutPoApprovalsInput>
  }

  export type UserUpdateWithoutPoApprovalsInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrders?: PurchaseOrderUpdateManyWithoutRequesterNestedInput
    materialRequests?: MaterialRequestUpdateManyWithoutRequesterNestedInput
    mrApprovals?: MaterialRequestUpdateManyWithoutApproverNestedInput
    rfqsCreated?: RFQUpdateManyWithoutCreatedByNestedInput
    receivedItems?: ReceivingReportUpdateManyWithoutReceivedByNestedInput
    disbursements?: DisbursementUpdateManyWithoutProcessedByNestedInput
    projectMembers?: ProjectMemberUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPoApprovalsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutRequesterNestedInput
    materialRequests?: MaterialRequestUncheckedUpdateManyWithoutRequesterNestedInput
    mrApprovals?: MaterialRequestUncheckedUpdateManyWithoutApproverNestedInput
    rfqsCreated?: RFQUncheckedUpdateManyWithoutCreatedByNestedInput
    receivedItems?: ReceivingReportUncheckedUpdateManyWithoutReceivedByNestedInput
    disbursements?: DisbursementUncheckedUpdateManyWithoutProcessedByNestedInput
    projectMembers?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PurchaseOrderItemUpsertWithWhereUniqueWithoutPurchaseOrderInput = {
    where: PurchaseOrderItemWhereUniqueInput
    update: XOR<PurchaseOrderItemUpdateWithoutPurchaseOrderInput, PurchaseOrderItemUncheckedUpdateWithoutPurchaseOrderInput>
    create: XOR<PurchaseOrderItemCreateWithoutPurchaseOrderInput, PurchaseOrderItemUncheckedCreateWithoutPurchaseOrderInput>
  }

  export type PurchaseOrderItemUpdateWithWhereUniqueWithoutPurchaseOrderInput = {
    where: PurchaseOrderItemWhereUniqueInput
    data: XOR<PurchaseOrderItemUpdateWithoutPurchaseOrderInput, PurchaseOrderItemUncheckedUpdateWithoutPurchaseOrderInput>
  }

  export type PurchaseOrderItemUpdateManyWithWhereWithoutPurchaseOrderInput = {
    where: PurchaseOrderItemScalarWhereInput
    data: XOR<PurchaseOrderItemUpdateManyMutationInput, PurchaseOrderItemUncheckedUpdateManyWithoutPurchaseOrderInput>
  }

  export type PurchaseOrderItemScalarWhereInput = {
    AND?: PurchaseOrderItemScalarWhereInput | PurchaseOrderItemScalarWhereInput[]
    OR?: PurchaseOrderItemScalarWhereInput[]
    NOT?: PurchaseOrderItemScalarWhereInput | PurchaseOrderItemScalarWhereInput[]
    id?: IntFilter<"PurchaseOrderItem"> | number
    purchaseOrderId?: IntFilter<"PurchaseOrderItem"> | number
    materialName?: StringFilter<"PurchaseOrderItem"> | string
    description?: StringNullableFilter<"PurchaseOrderItem"> | string | null
    quantity?: DecimalFilter<"PurchaseOrderItem"> | Decimal | DecimalJsLike | number | string
    unit?: StringFilter<"PurchaseOrderItem"> | string
    unitPrice?: DecimalFilter<"PurchaseOrderItem"> | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFilter<"PurchaseOrderItem"> | Decimal | DecimalJsLike | number | string
  }

  export type ReceivingReportUpsertWithWhereUniqueWithoutPurchaseOrderInput = {
    where: ReceivingReportWhereUniqueInput
    update: XOR<ReceivingReportUpdateWithoutPurchaseOrderInput, ReceivingReportUncheckedUpdateWithoutPurchaseOrderInput>
    create: XOR<ReceivingReportCreateWithoutPurchaseOrderInput, ReceivingReportUncheckedCreateWithoutPurchaseOrderInput>
  }

  export type ReceivingReportUpdateWithWhereUniqueWithoutPurchaseOrderInput = {
    where: ReceivingReportWhereUniqueInput
    data: XOR<ReceivingReportUpdateWithoutPurchaseOrderInput, ReceivingReportUncheckedUpdateWithoutPurchaseOrderInput>
  }

  export type ReceivingReportUpdateManyWithWhereWithoutPurchaseOrderInput = {
    where: ReceivingReportScalarWhereInput
    data: XOR<ReceivingReportUpdateManyMutationInput, ReceivingReportUncheckedUpdateManyWithoutPurchaseOrderInput>
  }

  export type SupplierInvoiceUpsertWithWhereUniqueWithoutPurchaseOrderInput = {
    where: SupplierInvoiceWhereUniqueInput
    update: XOR<SupplierInvoiceUpdateWithoutPurchaseOrderInput, SupplierInvoiceUncheckedUpdateWithoutPurchaseOrderInput>
    create: XOR<SupplierInvoiceCreateWithoutPurchaseOrderInput, SupplierInvoiceUncheckedCreateWithoutPurchaseOrderInput>
  }

  export type SupplierInvoiceUpdateWithWhereUniqueWithoutPurchaseOrderInput = {
    where: SupplierInvoiceWhereUniqueInput
    data: XOR<SupplierInvoiceUpdateWithoutPurchaseOrderInput, SupplierInvoiceUncheckedUpdateWithoutPurchaseOrderInput>
  }

  export type SupplierInvoiceUpdateManyWithWhereWithoutPurchaseOrderInput = {
    where: SupplierInvoiceScalarWhereInput
    data: XOR<SupplierInvoiceUpdateManyMutationInput, SupplierInvoiceUncheckedUpdateManyWithoutPurchaseOrderInput>
  }

  export type DisbursementUpsertWithWhereUniqueWithoutPurchaseOrderInput = {
    where: DisbursementWhereUniqueInput
    update: XOR<DisbursementUpdateWithoutPurchaseOrderInput, DisbursementUncheckedUpdateWithoutPurchaseOrderInput>
    create: XOR<DisbursementCreateWithoutPurchaseOrderInput, DisbursementUncheckedCreateWithoutPurchaseOrderInput>
  }

  export type DisbursementUpdateWithWhereUniqueWithoutPurchaseOrderInput = {
    where: DisbursementWhereUniqueInput
    data: XOR<DisbursementUpdateWithoutPurchaseOrderInput, DisbursementUncheckedUpdateWithoutPurchaseOrderInput>
  }

  export type DisbursementUpdateManyWithWhereWithoutPurchaseOrderInput = {
    where: DisbursementScalarWhereInput
    data: XOR<DisbursementUpdateManyMutationInput, DisbursementUncheckedUpdateManyWithoutPurchaseOrderInput>
  }

  export type PurchaseOrderCreateWithoutItemsInput = {
    orderDate?: Date | string
    status?: $Enums.PoStatus
    remarks?: string | null
    totalAmount?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutPurchaseOrdersInput
    supplier?: SupplierCreateNestedOneWithoutPurchaseOrdersInput
    requester: UserCreateNestedOneWithoutPurchaseOrdersInput
    approver?: UserCreateNestedOneWithoutPoApprovalsInput
    receiving?: ReceivingReportCreateNestedManyWithoutPurchaseOrderInput
    invoices?: SupplierInvoiceCreateNestedManyWithoutPurchaseOrderInput
    disbursements?: DisbursementCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseOrderUncheckedCreateWithoutItemsInput = {
    id?: number
    orderDate?: Date | string
    projectId: number
    supplierId?: number | null
    requesterId: number
    approverId?: number | null
    status?: $Enums.PoStatus
    remarks?: string | null
    totalAmount?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    receiving?: ReceivingReportUncheckedCreateNestedManyWithoutPurchaseOrderInput
    invoices?: SupplierInvoiceUncheckedCreateNestedManyWithoutPurchaseOrderInput
    disbursements?: DisbursementUncheckedCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseOrderCreateOrConnectWithoutItemsInput = {
    where: PurchaseOrderWhereUniqueInput
    create: XOR<PurchaseOrderCreateWithoutItemsInput, PurchaseOrderUncheckedCreateWithoutItemsInput>
  }

  export type PurchaseOrderUpsertWithoutItemsInput = {
    update: XOR<PurchaseOrderUpdateWithoutItemsInput, PurchaseOrderUncheckedUpdateWithoutItemsInput>
    create: XOR<PurchaseOrderCreateWithoutItemsInput, PurchaseOrderUncheckedCreateWithoutItemsInput>
    where?: PurchaseOrderWhereInput
  }

  export type PurchaseOrderUpdateToOneWithWhereWithoutItemsInput = {
    where?: PurchaseOrderWhereInput
    data: XOR<PurchaseOrderUpdateWithoutItemsInput, PurchaseOrderUncheckedUpdateWithoutItemsInput>
  }

  export type PurchaseOrderUpdateWithoutItemsInput = {
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumPoStatusFieldUpdateOperationsInput | $Enums.PoStatus
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutPurchaseOrdersNestedInput
    supplier?: SupplierUpdateOneWithoutPurchaseOrdersNestedInput
    requester?: UserUpdateOneRequiredWithoutPurchaseOrdersNestedInput
    approver?: UserUpdateOneWithoutPoApprovalsNestedInput
    receiving?: ReceivingReportUpdateManyWithoutPurchaseOrderNestedInput
    invoices?: SupplierInvoiceUpdateManyWithoutPurchaseOrderNestedInput
    disbursements?: DisbursementUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type PurchaseOrderUncheckedUpdateWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: IntFieldUpdateOperationsInput | number
    supplierId?: NullableIntFieldUpdateOperationsInput | number | null
    requesterId?: IntFieldUpdateOperationsInput | number
    approverId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumPoStatusFieldUpdateOperationsInput | $Enums.PoStatus
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receiving?: ReceivingReportUncheckedUpdateManyWithoutPurchaseOrderNestedInput
    invoices?: SupplierInvoiceUncheckedUpdateManyWithoutPurchaseOrderNestedInput
    disbursements?: DisbursementUncheckedUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type PurchaseOrderCreateWithoutReceivingInput = {
    orderDate?: Date | string
    status?: $Enums.PoStatus
    remarks?: string | null
    totalAmount?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutPurchaseOrdersInput
    supplier?: SupplierCreateNestedOneWithoutPurchaseOrdersInput
    requester: UserCreateNestedOneWithoutPurchaseOrdersInput
    approver?: UserCreateNestedOneWithoutPoApprovalsInput
    items?: PurchaseOrderItemCreateNestedManyWithoutPurchaseOrderInput
    invoices?: SupplierInvoiceCreateNestedManyWithoutPurchaseOrderInput
    disbursements?: DisbursementCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseOrderUncheckedCreateWithoutReceivingInput = {
    id?: number
    orderDate?: Date | string
    projectId: number
    supplierId?: number | null
    requesterId: number
    approverId?: number | null
    status?: $Enums.PoStatus
    remarks?: string | null
    totalAmount?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: PurchaseOrderItemUncheckedCreateNestedManyWithoutPurchaseOrderInput
    invoices?: SupplierInvoiceUncheckedCreateNestedManyWithoutPurchaseOrderInput
    disbursements?: DisbursementUncheckedCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseOrderCreateOrConnectWithoutReceivingInput = {
    where: PurchaseOrderWhereUniqueInput
    create: XOR<PurchaseOrderCreateWithoutReceivingInput, PurchaseOrderUncheckedCreateWithoutReceivingInput>
  }

  export type UserCreateWithoutReceivedItemsInput = {
    email: string
    name: string
    password: string
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutRequesterInput
    poApprovals?: PurchaseOrderCreateNestedManyWithoutApproverInput
    materialRequests?: MaterialRequestCreateNestedManyWithoutRequesterInput
    mrApprovals?: MaterialRequestCreateNestedManyWithoutApproverInput
    rfqsCreated?: RFQCreateNestedManyWithoutCreatedByInput
    disbursements?: DisbursementCreateNestedManyWithoutProcessedByInput
    projectMembers?: ProjectMemberCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReceivedItemsInput = {
    id?: number
    email: string
    name: string
    password: string
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutRequesterInput
    poApprovals?: PurchaseOrderUncheckedCreateNestedManyWithoutApproverInput
    materialRequests?: MaterialRequestUncheckedCreateNestedManyWithoutRequesterInput
    mrApprovals?: MaterialRequestUncheckedCreateNestedManyWithoutApproverInput
    rfqsCreated?: RFQUncheckedCreateNestedManyWithoutCreatedByInput
    disbursements?: DisbursementUncheckedCreateNestedManyWithoutProcessedByInput
    projectMembers?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReceivedItemsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReceivedItemsInput, UserUncheckedCreateWithoutReceivedItemsInput>
  }

  export type ReceivingItemCreateWithoutReceivingReportInput = {
    materialName: string
    quantityReceived: Decimal | DecimalJsLike | number | string
    status?: string
  }

  export type ReceivingItemUncheckedCreateWithoutReceivingReportInput = {
    id?: number
    materialName: string
    quantityReceived: Decimal | DecimalJsLike | number | string
    status?: string
  }

  export type ReceivingItemCreateOrConnectWithoutReceivingReportInput = {
    where: ReceivingItemWhereUniqueInput
    create: XOR<ReceivingItemCreateWithoutReceivingReportInput, ReceivingItemUncheckedCreateWithoutReceivingReportInput>
  }

  export type ReceivingItemCreateManyReceivingReportInputEnvelope = {
    data: ReceivingItemCreateManyReceivingReportInput | ReceivingItemCreateManyReceivingReportInput[]
    skipDuplicates?: boolean
  }

  export type SupplierInvoiceCreateWithoutReceivingReportInput = {
    invoiceNumber: string
    invoiceDate: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    status?: string
    createdAt?: Date | string
    supplier: SupplierCreateNestedOneWithoutInvoicesInput
    purchaseOrder?: PurchaseOrderCreateNestedOneWithoutInvoicesInput
  }

  export type SupplierInvoiceUncheckedCreateWithoutReceivingReportInput = {
    id?: number
    invoiceNumber: string
    invoiceDate: Date | string
    supplierId: number
    purchaseOrderId?: number | null
    totalAmount: Decimal | DecimalJsLike | number | string
    status?: string
    createdAt?: Date | string
  }

  export type SupplierInvoiceCreateOrConnectWithoutReceivingReportInput = {
    where: SupplierInvoiceWhereUniqueInput
    create: XOR<SupplierInvoiceCreateWithoutReceivingReportInput, SupplierInvoiceUncheckedCreateWithoutReceivingReportInput>
  }

  export type SupplierInvoiceCreateManyReceivingReportInputEnvelope = {
    data: SupplierInvoiceCreateManyReceivingReportInput | SupplierInvoiceCreateManyReceivingReportInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseOrderUpsertWithoutReceivingInput = {
    update: XOR<PurchaseOrderUpdateWithoutReceivingInput, PurchaseOrderUncheckedUpdateWithoutReceivingInput>
    create: XOR<PurchaseOrderCreateWithoutReceivingInput, PurchaseOrderUncheckedCreateWithoutReceivingInput>
    where?: PurchaseOrderWhereInput
  }

  export type PurchaseOrderUpdateToOneWithWhereWithoutReceivingInput = {
    where?: PurchaseOrderWhereInput
    data: XOR<PurchaseOrderUpdateWithoutReceivingInput, PurchaseOrderUncheckedUpdateWithoutReceivingInput>
  }

  export type PurchaseOrderUpdateWithoutReceivingInput = {
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumPoStatusFieldUpdateOperationsInput | $Enums.PoStatus
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutPurchaseOrdersNestedInput
    supplier?: SupplierUpdateOneWithoutPurchaseOrdersNestedInput
    requester?: UserUpdateOneRequiredWithoutPurchaseOrdersNestedInput
    approver?: UserUpdateOneWithoutPoApprovalsNestedInput
    items?: PurchaseOrderItemUpdateManyWithoutPurchaseOrderNestedInput
    invoices?: SupplierInvoiceUpdateManyWithoutPurchaseOrderNestedInput
    disbursements?: DisbursementUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type PurchaseOrderUncheckedUpdateWithoutReceivingInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: IntFieldUpdateOperationsInput | number
    supplierId?: NullableIntFieldUpdateOperationsInput | number | null
    requesterId?: IntFieldUpdateOperationsInput | number
    approverId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumPoStatusFieldUpdateOperationsInput | $Enums.PoStatus
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: PurchaseOrderItemUncheckedUpdateManyWithoutPurchaseOrderNestedInput
    invoices?: SupplierInvoiceUncheckedUpdateManyWithoutPurchaseOrderNestedInput
    disbursements?: DisbursementUncheckedUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type UserUpsertWithoutReceivedItemsInput = {
    update: XOR<UserUpdateWithoutReceivedItemsInput, UserUncheckedUpdateWithoutReceivedItemsInput>
    create: XOR<UserCreateWithoutReceivedItemsInput, UserUncheckedCreateWithoutReceivedItemsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReceivedItemsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReceivedItemsInput, UserUncheckedUpdateWithoutReceivedItemsInput>
  }

  export type UserUpdateWithoutReceivedItemsInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrders?: PurchaseOrderUpdateManyWithoutRequesterNestedInput
    poApprovals?: PurchaseOrderUpdateManyWithoutApproverNestedInput
    materialRequests?: MaterialRequestUpdateManyWithoutRequesterNestedInput
    mrApprovals?: MaterialRequestUpdateManyWithoutApproverNestedInput
    rfqsCreated?: RFQUpdateManyWithoutCreatedByNestedInput
    disbursements?: DisbursementUpdateManyWithoutProcessedByNestedInput
    projectMembers?: ProjectMemberUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReceivedItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutRequesterNestedInput
    poApprovals?: PurchaseOrderUncheckedUpdateManyWithoutApproverNestedInput
    materialRequests?: MaterialRequestUncheckedUpdateManyWithoutRequesterNestedInput
    mrApprovals?: MaterialRequestUncheckedUpdateManyWithoutApproverNestedInput
    rfqsCreated?: RFQUncheckedUpdateManyWithoutCreatedByNestedInput
    disbursements?: DisbursementUncheckedUpdateManyWithoutProcessedByNestedInput
    projectMembers?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ReceivingItemUpsertWithWhereUniqueWithoutReceivingReportInput = {
    where: ReceivingItemWhereUniqueInput
    update: XOR<ReceivingItemUpdateWithoutReceivingReportInput, ReceivingItemUncheckedUpdateWithoutReceivingReportInput>
    create: XOR<ReceivingItemCreateWithoutReceivingReportInput, ReceivingItemUncheckedCreateWithoutReceivingReportInput>
  }

  export type ReceivingItemUpdateWithWhereUniqueWithoutReceivingReportInput = {
    where: ReceivingItemWhereUniqueInput
    data: XOR<ReceivingItemUpdateWithoutReceivingReportInput, ReceivingItemUncheckedUpdateWithoutReceivingReportInput>
  }

  export type ReceivingItemUpdateManyWithWhereWithoutReceivingReportInput = {
    where: ReceivingItemScalarWhereInput
    data: XOR<ReceivingItemUpdateManyMutationInput, ReceivingItemUncheckedUpdateManyWithoutReceivingReportInput>
  }

  export type ReceivingItemScalarWhereInput = {
    AND?: ReceivingItemScalarWhereInput | ReceivingItemScalarWhereInput[]
    OR?: ReceivingItemScalarWhereInput[]
    NOT?: ReceivingItemScalarWhereInput | ReceivingItemScalarWhereInput[]
    id?: IntFilter<"ReceivingItem"> | number
    receivingReportId?: IntFilter<"ReceivingItem"> | number
    materialName?: StringFilter<"ReceivingItem"> | string
    quantityReceived?: DecimalFilter<"ReceivingItem"> | Decimal | DecimalJsLike | number | string
    status?: StringFilter<"ReceivingItem"> | string
  }

  export type SupplierInvoiceUpsertWithWhereUniqueWithoutReceivingReportInput = {
    where: SupplierInvoiceWhereUniqueInput
    update: XOR<SupplierInvoiceUpdateWithoutReceivingReportInput, SupplierInvoiceUncheckedUpdateWithoutReceivingReportInput>
    create: XOR<SupplierInvoiceCreateWithoutReceivingReportInput, SupplierInvoiceUncheckedCreateWithoutReceivingReportInput>
  }

  export type SupplierInvoiceUpdateWithWhereUniqueWithoutReceivingReportInput = {
    where: SupplierInvoiceWhereUniqueInput
    data: XOR<SupplierInvoiceUpdateWithoutReceivingReportInput, SupplierInvoiceUncheckedUpdateWithoutReceivingReportInput>
  }

  export type SupplierInvoiceUpdateManyWithWhereWithoutReceivingReportInput = {
    where: SupplierInvoiceScalarWhereInput
    data: XOR<SupplierInvoiceUpdateManyMutationInput, SupplierInvoiceUncheckedUpdateManyWithoutReceivingReportInput>
  }

  export type ReceivingReportCreateWithoutItemsInput = {
    receivedDate?: Date | string
    deliveryNoteNo?: string | null
    notes?: string | null
    purchaseOrder: PurchaseOrderCreateNestedOneWithoutReceivingInput
    receivedBy: UserCreateNestedOneWithoutReceivedItemsInput
    invoices?: SupplierInvoiceCreateNestedManyWithoutReceivingReportInput
  }

  export type ReceivingReportUncheckedCreateWithoutItemsInput = {
    id?: number
    purchaseOrderId: number
    receivedById: number
    receivedDate?: Date | string
    deliveryNoteNo?: string | null
    notes?: string | null
    invoices?: SupplierInvoiceUncheckedCreateNestedManyWithoutReceivingReportInput
  }

  export type ReceivingReportCreateOrConnectWithoutItemsInput = {
    where: ReceivingReportWhereUniqueInput
    create: XOR<ReceivingReportCreateWithoutItemsInput, ReceivingReportUncheckedCreateWithoutItemsInput>
  }

  export type ReceivingReportUpsertWithoutItemsInput = {
    update: XOR<ReceivingReportUpdateWithoutItemsInput, ReceivingReportUncheckedUpdateWithoutItemsInput>
    create: XOR<ReceivingReportCreateWithoutItemsInput, ReceivingReportUncheckedCreateWithoutItemsInput>
    where?: ReceivingReportWhereInput
  }

  export type ReceivingReportUpdateToOneWithWhereWithoutItemsInput = {
    where?: ReceivingReportWhereInput
    data: XOR<ReceivingReportUpdateWithoutItemsInput, ReceivingReportUncheckedUpdateWithoutItemsInput>
  }

  export type ReceivingReportUpdateWithoutItemsInput = {
    receivedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryNoteNo?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseOrder?: PurchaseOrderUpdateOneRequiredWithoutReceivingNestedInput
    receivedBy?: UserUpdateOneRequiredWithoutReceivedItemsNestedInput
    invoices?: SupplierInvoiceUpdateManyWithoutReceivingReportNestedInput
  }

  export type ReceivingReportUncheckedUpdateWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    purchaseOrderId?: IntFieldUpdateOperationsInput | number
    receivedById?: IntFieldUpdateOperationsInput | number
    receivedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryNoteNo?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    invoices?: SupplierInvoiceUncheckedUpdateManyWithoutReceivingReportNestedInput
  }

  export type ProjectCreateWithoutInventoryInput = {
    name: string
    location?: string | null
    duration?: string | null
    budget: Decimal | DecimalJsLike | number | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    totalFloorArea?: Decimal | DecimalJsLike | number | string | null
    carportArea?: Decimal | DecimalJsLike | number | string | null
    client?: ClientCreateNestedOneWithoutProjectsInput
    transactions?: FinancialTransactionCreateNestedManyWithoutProjectInput
    teamMembers?: ProjectMemberCreateNestedManyWithoutProjectInput
    boqItems?: BoqItemCreateNestedManyWithoutProjectInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutProjectInput
    materialRequests?: MaterialRequestCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutInventoryInput = {
    id?: number
    clientId?: number | null
    name: string
    location?: string | null
    duration?: string | null
    budget: Decimal | DecimalJsLike | number | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    totalFloorArea?: Decimal | DecimalJsLike | number | string | null
    carportArea?: Decimal | DecimalJsLike | number | string | null
    transactions?: FinancialTransactionUncheckedCreateNestedManyWithoutProjectInput
    teamMembers?: ProjectMemberUncheckedCreateNestedManyWithoutProjectInput
    boqItems?: BoqItemUncheckedCreateNestedManyWithoutProjectInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutProjectInput
    materialRequests?: MaterialRequestUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutInventoryInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutInventoryInput, ProjectUncheckedCreateWithoutInventoryInput>
  }

  export type WarehouseCreateWithoutInventoryInput = {
    name: string
    location?: string | null
    type?: string
  }

  export type WarehouseUncheckedCreateWithoutInventoryInput = {
    id?: number
    name: string
    location?: string | null
    type?: string
  }

  export type WarehouseCreateOrConnectWithoutInventoryInput = {
    where: WarehouseWhereUniqueInput
    create: XOR<WarehouseCreateWithoutInventoryInput, WarehouseUncheckedCreateWithoutInventoryInput>
  }

  export type ProjectUpsertWithoutInventoryInput = {
    update: XOR<ProjectUpdateWithoutInventoryInput, ProjectUncheckedUpdateWithoutInventoryInput>
    create: XOR<ProjectCreateWithoutInventoryInput, ProjectUncheckedCreateWithoutInventoryInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutInventoryInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutInventoryInput, ProjectUncheckedUpdateWithoutInventoryInput>
  }

  export type ProjectUpdateWithoutInventoryInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalFloorArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    carportArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    client?: ClientUpdateOneWithoutProjectsNestedInput
    transactions?: FinancialTransactionUpdateManyWithoutProjectNestedInput
    teamMembers?: ProjectMemberUpdateManyWithoutProjectNestedInput
    boqItems?: BoqItemUpdateManyWithoutProjectNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutProjectNestedInput
    materialRequests?: MaterialRequestUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutInventoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalFloorArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    carportArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    transactions?: FinancialTransactionUncheckedUpdateManyWithoutProjectNestedInput
    teamMembers?: ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
    boqItems?: BoqItemUncheckedUpdateManyWithoutProjectNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutProjectNestedInput
    materialRequests?: MaterialRequestUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type WarehouseUpsertWithoutInventoryInput = {
    update: XOR<WarehouseUpdateWithoutInventoryInput, WarehouseUncheckedUpdateWithoutInventoryInput>
    create: XOR<WarehouseCreateWithoutInventoryInput, WarehouseUncheckedCreateWithoutInventoryInput>
    where?: WarehouseWhereInput
  }

  export type WarehouseUpdateToOneWithWhereWithoutInventoryInput = {
    where?: WarehouseWhereInput
    data: XOR<WarehouseUpdateWithoutInventoryInput, WarehouseUncheckedUpdateWithoutInventoryInput>
  }

  export type WarehouseUpdateWithoutInventoryInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
  }

  export type WarehouseUncheckedUpdateWithoutInventoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
  }

  export type SupplierCreateWithoutInvoicesInput = {
    name: string
    contactPerson?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    rating?: number | null
    quotations?: SupplierQuotationCreateNestedManyWithoutSupplierInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUncheckedCreateWithoutInvoicesInput = {
    id?: number
    name: string
    contactPerson?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    rating?: number | null
    quotations?: SupplierQuotationUncheckedCreateNestedManyWithoutSupplierInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type SupplierCreateOrConnectWithoutInvoicesInput = {
    where: SupplierWhereUniqueInput
    create: XOR<SupplierCreateWithoutInvoicesInput, SupplierUncheckedCreateWithoutInvoicesInput>
  }

  export type PurchaseOrderCreateWithoutInvoicesInput = {
    orderDate?: Date | string
    status?: $Enums.PoStatus
    remarks?: string | null
    totalAmount?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutPurchaseOrdersInput
    supplier?: SupplierCreateNestedOneWithoutPurchaseOrdersInput
    requester: UserCreateNestedOneWithoutPurchaseOrdersInput
    approver?: UserCreateNestedOneWithoutPoApprovalsInput
    items?: PurchaseOrderItemCreateNestedManyWithoutPurchaseOrderInput
    receiving?: ReceivingReportCreateNestedManyWithoutPurchaseOrderInput
    disbursements?: DisbursementCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseOrderUncheckedCreateWithoutInvoicesInput = {
    id?: number
    orderDate?: Date | string
    projectId: number
    supplierId?: number | null
    requesterId: number
    approverId?: number | null
    status?: $Enums.PoStatus
    remarks?: string | null
    totalAmount?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: PurchaseOrderItemUncheckedCreateNestedManyWithoutPurchaseOrderInput
    receiving?: ReceivingReportUncheckedCreateNestedManyWithoutPurchaseOrderInput
    disbursements?: DisbursementUncheckedCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseOrderCreateOrConnectWithoutInvoicesInput = {
    where: PurchaseOrderWhereUniqueInput
    create: XOR<PurchaseOrderCreateWithoutInvoicesInput, PurchaseOrderUncheckedCreateWithoutInvoicesInput>
  }

  export type ReceivingReportCreateWithoutInvoicesInput = {
    receivedDate?: Date | string
    deliveryNoteNo?: string | null
    notes?: string | null
    purchaseOrder: PurchaseOrderCreateNestedOneWithoutReceivingInput
    receivedBy: UserCreateNestedOneWithoutReceivedItemsInput
    items?: ReceivingItemCreateNestedManyWithoutReceivingReportInput
  }

  export type ReceivingReportUncheckedCreateWithoutInvoicesInput = {
    id?: number
    purchaseOrderId: number
    receivedById: number
    receivedDate?: Date | string
    deliveryNoteNo?: string | null
    notes?: string | null
    items?: ReceivingItemUncheckedCreateNestedManyWithoutReceivingReportInput
  }

  export type ReceivingReportCreateOrConnectWithoutInvoicesInput = {
    where: ReceivingReportWhereUniqueInput
    create: XOR<ReceivingReportCreateWithoutInvoicesInput, ReceivingReportUncheckedCreateWithoutInvoicesInput>
  }

  export type SupplierUpsertWithoutInvoicesInput = {
    update: XOR<SupplierUpdateWithoutInvoicesInput, SupplierUncheckedUpdateWithoutInvoicesInput>
    create: XOR<SupplierCreateWithoutInvoicesInput, SupplierUncheckedCreateWithoutInvoicesInput>
    where?: SupplierWhereInput
  }

  export type SupplierUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: SupplierWhereInput
    data: XOR<SupplierUpdateWithoutInvoicesInput, SupplierUncheckedUpdateWithoutInvoicesInput>
  }

  export type SupplierUpdateWithoutInvoicesInput = {
    name?: StringFieldUpdateOperationsInput | string
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    quotations?: SupplierQuotationUpdateManyWithoutSupplierNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierUncheckedUpdateWithoutInvoicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    quotations?: SupplierQuotationUncheckedUpdateManyWithoutSupplierNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type PurchaseOrderUpsertWithoutInvoicesInput = {
    update: XOR<PurchaseOrderUpdateWithoutInvoicesInput, PurchaseOrderUncheckedUpdateWithoutInvoicesInput>
    create: XOR<PurchaseOrderCreateWithoutInvoicesInput, PurchaseOrderUncheckedCreateWithoutInvoicesInput>
    where?: PurchaseOrderWhereInput
  }

  export type PurchaseOrderUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: PurchaseOrderWhereInput
    data: XOR<PurchaseOrderUpdateWithoutInvoicesInput, PurchaseOrderUncheckedUpdateWithoutInvoicesInput>
  }

  export type PurchaseOrderUpdateWithoutInvoicesInput = {
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumPoStatusFieldUpdateOperationsInput | $Enums.PoStatus
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutPurchaseOrdersNestedInput
    supplier?: SupplierUpdateOneWithoutPurchaseOrdersNestedInput
    requester?: UserUpdateOneRequiredWithoutPurchaseOrdersNestedInput
    approver?: UserUpdateOneWithoutPoApprovalsNestedInput
    items?: PurchaseOrderItemUpdateManyWithoutPurchaseOrderNestedInput
    receiving?: ReceivingReportUpdateManyWithoutPurchaseOrderNestedInput
    disbursements?: DisbursementUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type PurchaseOrderUncheckedUpdateWithoutInvoicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: IntFieldUpdateOperationsInput | number
    supplierId?: NullableIntFieldUpdateOperationsInput | number | null
    requesterId?: IntFieldUpdateOperationsInput | number
    approverId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumPoStatusFieldUpdateOperationsInput | $Enums.PoStatus
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: PurchaseOrderItemUncheckedUpdateManyWithoutPurchaseOrderNestedInput
    receiving?: ReceivingReportUncheckedUpdateManyWithoutPurchaseOrderNestedInput
    disbursements?: DisbursementUncheckedUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type ReceivingReportUpsertWithoutInvoicesInput = {
    update: XOR<ReceivingReportUpdateWithoutInvoicesInput, ReceivingReportUncheckedUpdateWithoutInvoicesInput>
    create: XOR<ReceivingReportCreateWithoutInvoicesInput, ReceivingReportUncheckedCreateWithoutInvoicesInput>
    where?: ReceivingReportWhereInput
  }

  export type ReceivingReportUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: ReceivingReportWhereInput
    data: XOR<ReceivingReportUpdateWithoutInvoicesInput, ReceivingReportUncheckedUpdateWithoutInvoicesInput>
  }

  export type ReceivingReportUpdateWithoutInvoicesInput = {
    receivedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryNoteNo?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseOrder?: PurchaseOrderUpdateOneRequiredWithoutReceivingNestedInput
    receivedBy?: UserUpdateOneRequiredWithoutReceivedItemsNestedInput
    items?: ReceivingItemUpdateManyWithoutReceivingReportNestedInput
  }

  export type ReceivingReportUncheckedUpdateWithoutInvoicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    purchaseOrderId?: IntFieldUpdateOperationsInput | number
    receivedById?: IntFieldUpdateOperationsInput | number
    receivedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryNoteNo?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    items?: ReceivingItemUncheckedUpdateManyWithoutReceivingReportNestedInput
  }

  export type PurchaseOrderCreateWithoutDisbursementsInput = {
    orderDate?: Date | string
    status?: $Enums.PoStatus
    remarks?: string | null
    totalAmount?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutPurchaseOrdersInput
    supplier?: SupplierCreateNestedOneWithoutPurchaseOrdersInput
    requester: UserCreateNestedOneWithoutPurchaseOrdersInput
    approver?: UserCreateNestedOneWithoutPoApprovalsInput
    items?: PurchaseOrderItemCreateNestedManyWithoutPurchaseOrderInput
    receiving?: ReceivingReportCreateNestedManyWithoutPurchaseOrderInput
    invoices?: SupplierInvoiceCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseOrderUncheckedCreateWithoutDisbursementsInput = {
    id?: number
    orderDate?: Date | string
    projectId: number
    supplierId?: number | null
    requesterId: number
    approverId?: number | null
    status?: $Enums.PoStatus
    remarks?: string | null
    totalAmount?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: PurchaseOrderItemUncheckedCreateNestedManyWithoutPurchaseOrderInput
    receiving?: ReceivingReportUncheckedCreateNestedManyWithoutPurchaseOrderInput
    invoices?: SupplierInvoiceUncheckedCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseOrderCreateOrConnectWithoutDisbursementsInput = {
    where: PurchaseOrderWhereUniqueInput
    create: XOR<PurchaseOrderCreateWithoutDisbursementsInput, PurchaseOrderUncheckedCreateWithoutDisbursementsInput>
  }

  export type UserCreateWithoutDisbursementsInput = {
    email: string
    name: string
    password: string
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutRequesterInput
    poApprovals?: PurchaseOrderCreateNestedManyWithoutApproverInput
    materialRequests?: MaterialRequestCreateNestedManyWithoutRequesterInput
    mrApprovals?: MaterialRequestCreateNestedManyWithoutApproverInput
    rfqsCreated?: RFQCreateNestedManyWithoutCreatedByInput
    receivedItems?: ReceivingReportCreateNestedManyWithoutReceivedByInput
    projectMembers?: ProjectMemberCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDisbursementsInput = {
    id?: number
    email: string
    name: string
    password: string
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutRequesterInput
    poApprovals?: PurchaseOrderUncheckedCreateNestedManyWithoutApproverInput
    materialRequests?: MaterialRequestUncheckedCreateNestedManyWithoutRequesterInput
    mrApprovals?: MaterialRequestUncheckedCreateNestedManyWithoutApproverInput
    rfqsCreated?: RFQUncheckedCreateNestedManyWithoutCreatedByInput
    receivedItems?: ReceivingReportUncheckedCreateNestedManyWithoutReceivedByInput
    projectMembers?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDisbursementsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDisbursementsInput, UserUncheckedCreateWithoutDisbursementsInput>
  }

  export type PurchaseOrderUpsertWithoutDisbursementsInput = {
    update: XOR<PurchaseOrderUpdateWithoutDisbursementsInput, PurchaseOrderUncheckedUpdateWithoutDisbursementsInput>
    create: XOR<PurchaseOrderCreateWithoutDisbursementsInput, PurchaseOrderUncheckedCreateWithoutDisbursementsInput>
    where?: PurchaseOrderWhereInput
  }

  export type PurchaseOrderUpdateToOneWithWhereWithoutDisbursementsInput = {
    where?: PurchaseOrderWhereInput
    data: XOR<PurchaseOrderUpdateWithoutDisbursementsInput, PurchaseOrderUncheckedUpdateWithoutDisbursementsInput>
  }

  export type PurchaseOrderUpdateWithoutDisbursementsInput = {
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumPoStatusFieldUpdateOperationsInput | $Enums.PoStatus
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutPurchaseOrdersNestedInput
    supplier?: SupplierUpdateOneWithoutPurchaseOrdersNestedInput
    requester?: UserUpdateOneRequiredWithoutPurchaseOrdersNestedInput
    approver?: UserUpdateOneWithoutPoApprovalsNestedInput
    items?: PurchaseOrderItemUpdateManyWithoutPurchaseOrderNestedInput
    receiving?: ReceivingReportUpdateManyWithoutPurchaseOrderNestedInput
    invoices?: SupplierInvoiceUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type PurchaseOrderUncheckedUpdateWithoutDisbursementsInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: IntFieldUpdateOperationsInput | number
    supplierId?: NullableIntFieldUpdateOperationsInput | number | null
    requesterId?: IntFieldUpdateOperationsInput | number
    approverId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumPoStatusFieldUpdateOperationsInput | $Enums.PoStatus
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: PurchaseOrderItemUncheckedUpdateManyWithoutPurchaseOrderNestedInput
    receiving?: ReceivingReportUncheckedUpdateManyWithoutPurchaseOrderNestedInput
    invoices?: SupplierInvoiceUncheckedUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type UserUpsertWithoutDisbursementsInput = {
    update: XOR<UserUpdateWithoutDisbursementsInput, UserUncheckedUpdateWithoutDisbursementsInput>
    create: XOR<UserCreateWithoutDisbursementsInput, UserUncheckedCreateWithoutDisbursementsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDisbursementsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDisbursementsInput, UserUncheckedUpdateWithoutDisbursementsInput>
  }

  export type UserUpdateWithoutDisbursementsInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrders?: PurchaseOrderUpdateManyWithoutRequesterNestedInput
    poApprovals?: PurchaseOrderUpdateManyWithoutApproverNestedInput
    materialRequests?: MaterialRequestUpdateManyWithoutRequesterNestedInput
    mrApprovals?: MaterialRequestUpdateManyWithoutApproverNestedInput
    rfqsCreated?: RFQUpdateManyWithoutCreatedByNestedInput
    receivedItems?: ReceivingReportUpdateManyWithoutReceivedByNestedInput
    projectMembers?: ProjectMemberUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDisbursementsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutRequesterNestedInput
    poApprovals?: PurchaseOrderUncheckedUpdateManyWithoutApproverNestedInput
    materialRequests?: MaterialRequestUncheckedUpdateManyWithoutRequesterNestedInput
    mrApprovals?: MaterialRequestUncheckedUpdateManyWithoutApproverNestedInput
    rfqsCreated?: RFQUncheckedUpdateManyWithoutCreatedByNestedInput
    receivedItems?: ReceivingReportUncheckedUpdateManyWithoutReceivedByNestedInput
    projectMembers?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProjectCreateWithoutTransactionsInput = {
    name: string
    location?: string | null
    duration?: string | null
    budget: Decimal | DecimalJsLike | number | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    totalFloorArea?: Decimal | DecimalJsLike | number | string | null
    carportArea?: Decimal | DecimalJsLike | number | string | null
    client?: ClientCreateNestedOneWithoutProjectsInput
    inventory?: InventoryItemCreateNestedManyWithoutProjectInput
    teamMembers?: ProjectMemberCreateNestedManyWithoutProjectInput
    boqItems?: BoqItemCreateNestedManyWithoutProjectInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutProjectInput
    materialRequests?: MaterialRequestCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutTransactionsInput = {
    id?: number
    clientId?: number | null
    name: string
    location?: string | null
    duration?: string | null
    budget: Decimal | DecimalJsLike | number | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    totalFloorArea?: Decimal | DecimalJsLike | number | string | null
    carportArea?: Decimal | DecimalJsLike | number | string | null
    inventory?: InventoryItemUncheckedCreateNestedManyWithoutProjectInput
    teamMembers?: ProjectMemberUncheckedCreateNestedManyWithoutProjectInput
    boqItems?: BoqItemUncheckedCreateNestedManyWithoutProjectInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutProjectInput
    materialRequests?: MaterialRequestUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutTransactionsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutTransactionsInput, ProjectUncheckedCreateWithoutTransactionsInput>
  }

  export type ProjectUpsertWithoutTransactionsInput = {
    update: XOR<ProjectUpdateWithoutTransactionsInput, ProjectUncheckedUpdateWithoutTransactionsInput>
    create: XOR<ProjectCreateWithoutTransactionsInput, ProjectUncheckedCreateWithoutTransactionsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutTransactionsInput, ProjectUncheckedUpdateWithoutTransactionsInput>
  }

  export type ProjectUpdateWithoutTransactionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalFloorArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    carportArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    client?: ClientUpdateOneWithoutProjectsNestedInput
    inventory?: InventoryItemUpdateManyWithoutProjectNestedInput
    teamMembers?: ProjectMemberUpdateManyWithoutProjectNestedInput
    boqItems?: BoqItemUpdateManyWithoutProjectNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutProjectNestedInput
    materialRequests?: MaterialRequestUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutTransactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalFloorArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    carportArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    inventory?: InventoryItemUncheckedUpdateManyWithoutProjectNestedInput
    teamMembers?: ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
    boqItems?: BoqItemUncheckedUpdateManyWithoutProjectNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutProjectNestedInput
    materialRequests?: MaterialRequestUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type PurchaseOrderCreateManyRequesterInput = {
    id?: number
    orderDate?: Date | string
    projectId: number
    supplierId?: number | null
    approverId?: number | null
    status?: $Enums.PoStatus
    remarks?: string | null
    totalAmount?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseOrderCreateManyApproverInput = {
    id?: number
    orderDate?: Date | string
    projectId: number
    supplierId?: number | null
    requesterId: number
    status?: $Enums.PoStatus
    remarks?: string | null
    totalAmount?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MaterialRequestCreateManyRequesterInput = {
    id?: number
    projectId: number
    approverId?: number | null
    requestDate?: Date | string
    status?: $Enums.MrStatus
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MaterialRequestCreateManyApproverInput = {
    id?: number
    projectId: number
    requesterId: number
    requestDate?: Date | string
    status?: $Enums.MrStatus
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RFQCreateManyCreatedByInput = {
    id?: number
    mrId?: number | null
    title: string
    status?: $Enums.RfqStatus
    dueDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReceivingReportCreateManyReceivedByInput = {
    id?: number
    purchaseOrderId: number
    receivedDate?: Date | string
    deliveryNoteNo?: string | null
    notes?: string | null
  }

  export type DisbursementCreateManyProcessedByInput = {
    id?: number
    purchaseOrderId?: number | null
    amount: Decimal | DecimalJsLike | number | string
    paymentDate?: Date | string
    method: $Enums.PaymentMethod
    referenceNumber?: string | null
    status?: string
  }

  export type ProjectMemberCreateManyUserInput = {
    id?: number
    projectId: number
    role: string
    assignedAt?: Date | string
  }

  export type PurchaseOrderUpdateWithoutRequesterInput = {
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumPoStatusFieldUpdateOperationsInput | $Enums.PoStatus
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutPurchaseOrdersNestedInput
    supplier?: SupplierUpdateOneWithoutPurchaseOrdersNestedInput
    approver?: UserUpdateOneWithoutPoApprovalsNestedInput
    items?: PurchaseOrderItemUpdateManyWithoutPurchaseOrderNestedInput
    receiving?: ReceivingReportUpdateManyWithoutPurchaseOrderNestedInput
    invoices?: SupplierInvoiceUpdateManyWithoutPurchaseOrderNestedInput
    disbursements?: DisbursementUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type PurchaseOrderUncheckedUpdateWithoutRequesterInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: IntFieldUpdateOperationsInput | number
    supplierId?: NullableIntFieldUpdateOperationsInput | number | null
    approverId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumPoStatusFieldUpdateOperationsInput | $Enums.PoStatus
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: PurchaseOrderItemUncheckedUpdateManyWithoutPurchaseOrderNestedInput
    receiving?: ReceivingReportUncheckedUpdateManyWithoutPurchaseOrderNestedInput
    invoices?: SupplierInvoiceUncheckedUpdateManyWithoutPurchaseOrderNestedInput
    disbursements?: DisbursementUncheckedUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type PurchaseOrderUncheckedUpdateManyWithoutRequesterInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: IntFieldUpdateOperationsInput | number
    supplierId?: NullableIntFieldUpdateOperationsInput | number | null
    approverId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumPoStatusFieldUpdateOperationsInput | $Enums.PoStatus
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderUpdateWithoutApproverInput = {
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumPoStatusFieldUpdateOperationsInput | $Enums.PoStatus
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutPurchaseOrdersNestedInput
    supplier?: SupplierUpdateOneWithoutPurchaseOrdersNestedInput
    requester?: UserUpdateOneRequiredWithoutPurchaseOrdersNestedInput
    items?: PurchaseOrderItemUpdateManyWithoutPurchaseOrderNestedInput
    receiving?: ReceivingReportUpdateManyWithoutPurchaseOrderNestedInput
    invoices?: SupplierInvoiceUpdateManyWithoutPurchaseOrderNestedInput
    disbursements?: DisbursementUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type PurchaseOrderUncheckedUpdateWithoutApproverInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: IntFieldUpdateOperationsInput | number
    supplierId?: NullableIntFieldUpdateOperationsInput | number | null
    requesterId?: IntFieldUpdateOperationsInput | number
    status?: EnumPoStatusFieldUpdateOperationsInput | $Enums.PoStatus
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: PurchaseOrderItemUncheckedUpdateManyWithoutPurchaseOrderNestedInput
    receiving?: ReceivingReportUncheckedUpdateManyWithoutPurchaseOrderNestedInput
    invoices?: SupplierInvoiceUncheckedUpdateManyWithoutPurchaseOrderNestedInput
    disbursements?: DisbursementUncheckedUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type PurchaseOrderUncheckedUpdateManyWithoutApproverInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: IntFieldUpdateOperationsInput | number
    supplierId?: NullableIntFieldUpdateOperationsInput | number | null
    requesterId?: IntFieldUpdateOperationsInput | number
    status?: EnumPoStatusFieldUpdateOperationsInput | $Enums.PoStatus
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialRequestUpdateWithoutRequesterInput = {
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumMrStatusFieldUpdateOperationsInput | $Enums.MrStatus
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutMaterialRequestsNestedInput
    approver?: UserUpdateOneWithoutMrApprovalsNestedInput
    items?: MaterialRequestItemUpdateManyWithoutMaterialRequestNestedInput
    rfqs?: RFQUpdateManyWithoutMaterialRequestNestedInput
  }

  export type MaterialRequestUncheckedUpdateWithoutRequesterInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    approverId?: NullableIntFieldUpdateOperationsInput | number | null
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumMrStatusFieldUpdateOperationsInput | $Enums.MrStatus
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: MaterialRequestItemUncheckedUpdateManyWithoutMaterialRequestNestedInput
    rfqs?: RFQUncheckedUpdateManyWithoutMaterialRequestNestedInput
  }

  export type MaterialRequestUncheckedUpdateManyWithoutRequesterInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    approverId?: NullableIntFieldUpdateOperationsInput | number | null
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumMrStatusFieldUpdateOperationsInput | $Enums.MrStatus
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialRequestUpdateWithoutApproverInput = {
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumMrStatusFieldUpdateOperationsInput | $Enums.MrStatus
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutMaterialRequestsNestedInput
    requester?: UserUpdateOneRequiredWithoutMaterialRequestsNestedInput
    items?: MaterialRequestItemUpdateManyWithoutMaterialRequestNestedInput
    rfqs?: RFQUpdateManyWithoutMaterialRequestNestedInput
  }

  export type MaterialRequestUncheckedUpdateWithoutApproverInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    requesterId?: IntFieldUpdateOperationsInput | number
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumMrStatusFieldUpdateOperationsInput | $Enums.MrStatus
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: MaterialRequestItemUncheckedUpdateManyWithoutMaterialRequestNestedInput
    rfqs?: RFQUncheckedUpdateManyWithoutMaterialRequestNestedInput
  }

  export type MaterialRequestUncheckedUpdateManyWithoutApproverInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    requesterId?: IntFieldUpdateOperationsInput | number
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumMrStatusFieldUpdateOperationsInput | $Enums.MrStatus
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RFQUpdateWithoutCreatedByInput = {
    title?: StringFieldUpdateOperationsInput | string
    status?: EnumRfqStatusFieldUpdateOperationsInput | $Enums.RfqStatus
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    materialRequest?: MaterialRequestUpdateOneWithoutRfqsNestedInput
    items?: RFQItemUpdateManyWithoutRfqNestedInput
    quotations?: SupplierQuotationUpdateManyWithoutRfqNestedInput
  }

  export type RFQUncheckedUpdateWithoutCreatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    mrId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    status?: EnumRfqStatusFieldUpdateOperationsInput | $Enums.RfqStatus
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: RFQItemUncheckedUpdateManyWithoutRfqNestedInput
    quotations?: SupplierQuotationUncheckedUpdateManyWithoutRfqNestedInput
  }

  export type RFQUncheckedUpdateManyWithoutCreatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    mrId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    status?: EnumRfqStatusFieldUpdateOperationsInput | $Enums.RfqStatus
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReceivingReportUpdateWithoutReceivedByInput = {
    receivedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryNoteNo?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseOrder?: PurchaseOrderUpdateOneRequiredWithoutReceivingNestedInput
    items?: ReceivingItemUpdateManyWithoutReceivingReportNestedInput
    invoices?: SupplierInvoiceUpdateManyWithoutReceivingReportNestedInput
  }

  export type ReceivingReportUncheckedUpdateWithoutReceivedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    purchaseOrderId?: IntFieldUpdateOperationsInput | number
    receivedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryNoteNo?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    items?: ReceivingItemUncheckedUpdateManyWithoutReceivingReportNestedInput
    invoices?: SupplierInvoiceUncheckedUpdateManyWithoutReceivingReportNestedInput
  }

  export type ReceivingReportUncheckedUpdateManyWithoutReceivedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    purchaseOrderId?: IntFieldUpdateOperationsInput | number
    receivedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryNoteNo?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DisbursementUpdateWithoutProcessedByInput = {
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    purchaseOrder?: PurchaseOrderUpdateOneWithoutDisbursementsNestedInput
  }

  export type DisbursementUncheckedUpdateWithoutProcessedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    purchaseOrderId?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type DisbursementUncheckedUpdateManyWithoutProcessedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    purchaseOrderId?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectMemberUpdateWithoutUserInput = {
    role?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutTeamMembersNestedInput
  }

  export type ProjectMemberUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectMemberUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectCreateManyClientInput = {
    id?: number
    name: string
    location?: string | null
    duration?: string | null
    budget: Decimal | DecimalJsLike | number | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    totalFloorArea?: Decimal | DecimalJsLike | number | string | null
    carportArea?: Decimal | DecimalJsLike | number | string | null
  }

  export type ProjectUpdateWithoutClientInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalFloorArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    carportArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    transactions?: FinancialTransactionUpdateManyWithoutProjectNestedInput
    inventory?: InventoryItemUpdateManyWithoutProjectNestedInput
    teamMembers?: ProjectMemberUpdateManyWithoutProjectNestedInput
    boqItems?: BoqItemUpdateManyWithoutProjectNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutProjectNestedInput
    materialRequests?: MaterialRequestUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalFloorArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    carportArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    transactions?: FinancialTransactionUncheckedUpdateManyWithoutProjectNestedInput
    inventory?: InventoryItemUncheckedUpdateManyWithoutProjectNestedInput
    teamMembers?: ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
    boqItems?: BoqItemUncheckedUpdateManyWithoutProjectNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutProjectNestedInput
    materialRequests?: MaterialRequestUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateManyWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalFloorArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    carportArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type FinancialTransactionCreateManyProjectInput = {
    id?: number
    date?: Date | string
    type: string
    category: string
    description?: string | null
    amount: Decimal | DecimalJsLike | number | string
    reference?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type InventoryItemCreateManyProjectInput = {
    id?: number
    materialName: string
    warehouseId?: number | null
    quantity: Decimal | DecimalJsLike | number | string
    unit: string
    lastUpdated?: Date | string
  }

  export type ProjectMemberCreateManyProjectInput = {
    id?: number
    userId: number
    role: string
    assignedAt?: Date | string
  }

  export type BoqItemCreateManyProjectInput = {
    id?: number
    itemDescription: string
    unit: string
    materialUnitPrice: Decimal | DecimalJsLike | number | string
    laborUnitPrice?: Decimal | DecimalJsLike | number | string
    quantity: Decimal | DecimalJsLike | number | string
    isCarport?: boolean
  }

  export type PurchaseOrderCreateManyProjectInput = {
    id?: number
    orderDate?: Date | string
    supplierId?: number | null
    requesterId: number
    approverId?: number | null
    status?: $Enums.PoStatus
    remarks?: string | null
    totalAmount?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MaterialRequestCreateManyProjectInput = {
    id?: number
    requesterId: number
    approverId?: number | null
    requestDate?: Date | string
    status?: $Enums.MrStatus
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FinancialTransactionUpdateWithoutProjectInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type FinancialTransactionUncheckedUpdateWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type FinancialTransactionUncheckedUpdateManyWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type InventoryItemUpdateWithoutProjectInput = {
    materialName?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    warehouse?: WarehouseUpdateOneWithoutInventoryNestedInput
  }

  export type InventoryItemUncheckedUpdateWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    materialName?: StringFieldUpdateOperationsInput | string
    warehouseId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryItemUncheckedUpdateManyWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    materialName?: StringFieldUpdateOperationsInput | string
    warehouseId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectMemberUpdateWithoutProjectInput = {
    role?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProjectMembersNestedInput
  }

  export type ProjectMemberUncheckedUpdateWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectMemberUncheckedUpdateManyWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BoqItemUpdateWithoutProjectInput = {
    itemDescription?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    materialUnitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    laborUnitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isCarport?: BoolFieldUpdateOperationsInput | boolean
    boqComponents?: BoqItemComponentUpdateManyWithoutBoqItemNestedInput
  }

  export type BoqItemUncheckedUpdateWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemDescription?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    materialUnitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    laborUnitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isCarport?: BoolFieldUpdateOperationsInput | boolean
    boqComponents?: BoqItemComponentUncheckedUpdateManyWithoutBoqItemNestedInput
  }

  export type BoqItemUncheckedUpdateManyWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemDescription?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    materialUnitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    laborUnitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isCarport?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PurchaseOrderUpdateWithoutProjectInput = {
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumPoStatusFieldUpdateOperationsInput | $Enums.PoStatus
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplier?: SupplierUpdateOneWithoutPurchaseOrdersNestedInput
    requester?: UserUpdateOneRequiredWithoutPurchaseOrdersNestedInput
    approver?: UserUpdateOneWithoutPoApprovalsNestedInput
    items?: PurchaseOrderItemUpdateManyWithoutPurchaseOrderNestedInput
    receiving?: ReceivingReportUpdateManyWithoutPurchaseOrderNestedInput
    invoices?: SupplierInvoiceUpdateManyWithoutPurchaseOrderNestedInput
    disbursements?: DisbursementUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type PurchaseOrderUncheckedUpdateWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    supplierId?: NullableIntFieldUpdateOperationsInput | number | null
    requesterId?: IntFieldUpdateOperationsInput | number
    approverId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumPoStatusFieldUpdateOperationsInput | $Enums.PoStatus
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: PurchaseOrderItemUncheckedUpdateManyWithoutPurchaseOrderNestedInput
    receiving?: ReceivingReportUncheckedUpdateManyWithoutPurchaseOrderNestedInput
    invoices?: SupplierInvoiceUncheckedUpdateManyWithoutPurchaseOrderNestedInput
    disbursements?: DisbursementUncheckedUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type PurchaseOrderUncheckedUpdateManyWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    supplierId?: NullableIntFieldUpdateOperationsInput | number | null
    requesterId?: IntFieldUpdateOperationsInput | number
    approverId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumPoStatusFieldUpdateOperationsInput | $Enums.PoStatus
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialRequestUpdateWithoutProjectInput = {
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumMrStatusFieldUpdateOperationsInput | $Enums.MrStatus
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requester?: UserUpdateOneRequiredWithoutMaterialRequestsNestedInput
    approver?: UserUpdateOneWithoutMrApprovalsNestedInput
    items?: MaterialRequestItemUpdateManyWithoutMaterialRequestNestedInput
    rfqs?: RFQUpdateManyWithoutMaterialRequestNestedInput
  }

  export type MaterialRequestUncheckedUpdateWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    requesterId?: IntFieldUpdateOperationsInput | number
    approverId?: NullableIntFieldUpdateOperationsInput | number | null
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumMrStatusFieldUpdateOperationsInput | $Enums.MrStatus
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: MaterialRequestItemUncheckedUpdateManyWithoutMaterialRequestNestedInput
    rfqs?: RFQUncheckedUpdateManyWithoutMaterialRequestNestedInput
  }

  export type MaterialRequestUncheckedUpdateManyWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    requesterId?: IntFieldUpdateOperationsInput | number
    approverId?: NullableIntFieldUpdateOperationsInput | number | null
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumMrStatusFieldUpdateOperationsInput | $Enums.MrStatus
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BoqItemComponentCreateManyBoqItemInput = {
    id?: number
    resourceType: $Enums.ResourceType
    name: string
    quantityFactor: Decimal | DecimalJsLike | number | string
    unitRate: Decimal | DecimalJsLike | number | string
    totalComponentCost: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BoqItemComponentUpdateWithoutBoqItemInput = {
    resourceType?: EnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType
    name?: StringFieldUpdateOperationsInput | string
    quantityFactor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalComponentCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BoqItemComponentUncheckedUpdateWithoutBoqItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    resourceType?: EnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType
    name?: StringFieldUpdateOperationsInput | string
    quantityFactor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalComponentCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BoqItemComponentUncheckedUpdateManyWithoutBoqItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    resourceType?: EnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType
    name?: StringFieldUpdateOperationsInput | string
    quantityFactor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalComponentCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialRequestItemCreateManyMaterialRequestInput = {
    id?: number
    itemDescription: string
    description?: string | null
    quantity: Decimal | DecimalJsLike | number | string
    materialUnitPrice?: Decimal | DecimalJsLike | number | string
    laborUnitPrice?: Decimal | DecimalJsLike | number | string
    unit: string
  }

  export type RFQCreateManyMaterialRequestInput = {
    id?: number
    createdById: number
    title: string
    status?: $Enums.RfqStatus
    dueDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MaterialRequestItemUpdateWithoutMaterialRequestInput = {
    itemDescription?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    materialUnitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    laborUnitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
  }

  export type MaterialRequestItemUncheckedUpdateWithoutMaterialRequestInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemDescription?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    materialUnitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    laborUnitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
  }

  export type MaterialRequestItemUncheckedUpdateManyWithoutMaterialRequestInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemDescription?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    materialUnitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    laborUnitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
  }

  export type RFQUpdateWithoutMaterialRequestInput = {
    title?: StringFieldUpdateOperationsInput | string
    status?: EnumRfqStatusFieldUpdateOperationsInput | $Enums.RfqStatus
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutRfqsCreatedNestedInput
    items?: RFQItemUpdateManyWithoutRfqNestedInput
    quotations?: SupplierQuotationUpdateManyWithoutRfqNestedInput
  }

  export type RFQUncheckedUpdateWithoutMaterialRequestInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdById?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    status?: EnumRfqStatusFieldUpdateOperationsInput | $Enums.RfqStatus
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: RFQItemUncheckedUpdateManyWithoutRfqNestedInput
    quotations?: SupplierQuotationUncheckedUpdateManyWithoutRfqNestedInput
  }

  export type RFQUncheckedUpdateManyWithoutMaterialRequestInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdById?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    status?: EnumRfqStatusFieldUpdateOperationsInput | $Enums.RfqStatus
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RFQItemCreateManyRfqInput = {
    id?: number
    materialName: string
    quantity: Decimal | DecimalJsLike | number | string
    unit: string
  }

  export type SupplierQuotationCreateManyRfqInput = {
    id?: number
    supplierId: number
    quoteDate?: Date | string
    totalAmount?: Decimal | DecimalJsLike | number | string
    currency?: string
    isSelected?: boolean
  }

  export type RFQItemUpdateWithoutRfqInput = {
    materialName?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
  }

  export type RFQItemUncheckedUpdateWithoutRfqInput = {
    id?: IntFieldUpdateOperationsInput | number
    materialName?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
  }

  export type RFQItemUncheckedUpdateManyWithoutRfqInput = {
    id?: IntFieldUpdateOperationsInput | number
    materialName?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
  }

  export type SupplierQuotationUpdateWithoutRfqInput = {
    quoteDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    isSelected?: BoolFieldUpdateOperationsInput | boolean
    supplier?: SupplierUpdateOneRequiredWithoutQuotationsNestedInput
    items?: QuotationItemUpdateManyWithoutSupplierQuotationNestedInput
  }

  export type SupplierQuotationUncheckedUpdateWithoutRfqInput = {
    id?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
    quoteDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    isSelected?: BoolFieldUpdateOperationsInput | boolean
    items?: QuotationItemUncheckedUpdateManyWithoutSupplierQuotationNestedInput
  }

  export type SupplierQuotationUncheckedUpdateManyWithoutRfqInput = {
    id?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
    quoteDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    isSelected?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SupplierQuotationCreateManySupplierInput = {
    id?: number
    rfqId: number
    quoteDate?: Date | string
    totalAmount?: Decimal | DecimalJsLike | number | string
    currency?: string
    isSelected?: boolean
  }

  export type PurchaseOrderCreateManySupplierInput = {
    id?: number
    orderDate?: Date | string
    projectId: number
    requesterId: number
    approverId?: number | null
    status?: $Enums.PoStatus
    remarks?: string | null
    totalAmount?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupplierInvoiceCreateManySupplierInput = {
    id?: number
    invoiceNumber: string
    invoiceDate: Date | string
    purchaseOrderId?: number | null
    receivingReportId?: number | null
    totalAmount: Decimal | DecimalJsLike | number | string
    status?: string
    createdAt?: Date | string
  }

  export type SupplierQuotationUpdateWithoutSupplierInput = {
    quoteDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    isSelected?: BoolFieldUpdateOperationsInput | boolean
    rfq?: RFQUpdateOneRequiredWithoutQuotationsNestedInput
    items?: QuotationItemUpdateManyWithoutSupplierQuotationNestedInput
  }

  export type SupplierQuotationUncheckedUpdateWithoutSupplierInput = {
    id?: IntFieldUpdateOperationsInput | number
    rfqId?: IntFieldUpdateOperationsInput | number
    quoteDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    isSelected?: BoolFieldUpdateOperationsInput | boolean
    items?: QuotationItemUncheckedUpdateManyWithoutSupplierQuotationNestedInput
  }

  export type SupplierQuotationUncheckedUpdateManyWithoutSupplierInput = {
    id?: IntFieldUpdateOperationsInput | number
    rfqId?: IntFieldUpdateOperationsInput | number
    quoteDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    isSelected?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PurchaseOrderUpdateWithoutSupplierInput = {
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumPoStatusFieldUpdateOperationsInput | $Enums.PoStatus
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutPurchaseOrdersNestedInput
    requester?: UserUpdateOneRequiredWithoutPurchaseOrdersNestedInput
    approver?: UserUpdateOneWithoutPoApprovalsNestedInput
    items?: PurchaseOrderItemUpdateManyWithoutPurchaseOrderNestedInput
    receiving?: ReceivingReportUpdateManyWithoutPurchaseOrderNestedInput
    invoices?: SupplierInvoiceUpdateManyWithoutPurchaseOrderNestedInput
    disbursements?: DisbursementUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type PurchaseOrderUncheckedUpdateWithoutSupplierInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: IntFieldUpdateOperationsInput | number
    requesterId?: IntFieldUpdateOperationsInput | number
    approverId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumPoStatusFieldUpdateOperationsInput | $Enums.PoStatus
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: PurchaseOrderItemUncheckedUpdateManyWithoutPurchaseOrderNestedInput
    receiving?: ReceivingReportUncheckedUpdateManyWithoutPurchaseOrderNestedInput
    invoices?: SupplierInvoiceUncheckedUpdateManyWithoutPurchaseOrderNestedInput
    disbursements?: DisbursementUncheckedUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type PurchaseOrderUncheckedUpdateManyWithoutSupplierInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: IntFieldUpdateOperationsInput | number
    requesterId?: IntFieldUpdateOperationsInput | number
    approverId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumPoStatusFieldUpdateOperationsInput | $Enums.PoStatus
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierInvoiceUpdateWithoutSupplierInput = {
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrder?: PurchaseOrderUpdateOneWithoutInvoicesNestedInput
    receivingReport?: ReceivingReportUpdateOneWithoutInvoicesNestedInput
  }

  export type SupplierInvoiceUncheckedUpdateWithoutSupplierInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrderId?: NullableIntFieldUpdateOperationsInput | number | null
    receivingReportId?: NullableIntFieldUpdateOperationsInput | number | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierInvoiceUncheckedUpdateManyWithoutSupplierInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrderId?: NullableIntFieldUpdateOperationsInput | number | null
    receivingReportId?: NullableIntFieldUpdateOperationsInput | number | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryItemCreateManyWarehouseInput = {
    id?: number
    materialName: string
    projectId?: number | null
    quantity: Decimal | DecimalJsLike | number | string
    unit: string
    lastUpdated?: Date | string
  }

  export type InventoryItemUpdateWithoutWarehouseInput = {
    materialName?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneWithoutInventoryNestedInput
  }

  export type InventoryItemUncheckedUpdateWithoutWarehouseInput = {
    id?: IntFieldUpdateOperationsInput | number
    materialName?: StringFieldUpdateOperationsInput | string
    projectId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryItemUncheckedUpdateManyWithoutWarehouseInput = {
    id?: IntFieldUpdateOperationsInput | number
    materialName?: StringFieldUpdateOperationsInput | string
    projectId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuotationItemCreateManySupplierQuotationInput = {
    id?: number
    materialName: string
    quantity: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    remarks?: string | null
  }

  export type QuotationItemUpdateWithoutSupplierQuotationInput = {
    materialName?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QuotationItemUncheckedUpdateWithoutSupplierQuotationInput = {
    id?: IntFieldUpdateOperationsInput | number
    materialName?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QuotationItemUncheckedUpdateManyWithoutSupplierQuotationInput = {
    id?: IntFieldUpdateOperationsInput | number
    materialName?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PurchaseOrderItemCreateManyPurchaseOrderInput = {
    id?: number
    materialName: string
    description?: string | null
    quantity: Decimal | DecimalJsLike | number | string
    unit: string
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
  }

  export type ReceivingReportCreateManyPurchaseOrderInput = {
    id?: number
    receivedById: number
    receivedDate?: Date | string
    deliveryNoteNo?: string | null
    notes?: string | null
  }

  export type SupplierInvoiceCreateManyPurchaseOrderInput = {
    id?: number
    invoiceNumber: string
    invoiceDate: Date | string
    supplierId: number
    receivingReportId?: number | null
    totalAmount: Decimal | DecimalJsLike | number | string
    status?: string
    createdAt?: Date | string
  }

  export type DisbursementCreateManyPurchaseOrderInput = {
    id?: number
    processedById: number
    amount: Decimal | DecimalJsLike | number | string
    paymentDate?: Date | string
    method: $Enums.PaymentMethod
    referenceNumber?: string | null
    status?: string
  }

  export type PurchaseOrderItemUpdateWithoutPurchaseOrderInput = {
    materialName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type PurchaseOrderItemUncheckedUpdateWithoutPurchaseOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    materialName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type PurchaseOrderItemUncheckedUpdateManyWithoutPurchaseOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    materialName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type ReceivingReportUpdateWithoutPurchaseOrderInput = {
    receivedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryNoteNo?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    receivedBy?: UserUpdateOneRequiredWithoutReceivedItemsNestedInput
    items?: ReceivingItemUpdateManyWithoutReceivingReportNestedInput
    invoices?: SupplierInvoiceUpdateManyWithoutReceivingReportNestedInput
  }

  export type ReceivingReportUncheckedUpdateWithoutPurchaseOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    receivedById?: IntFieldUpdateOperationsInput | number
    receivedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryNoteNo?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    items?: ReceivingItemUncheckedUpdateManyWithoutReceivingReportNestedInput
    invoices?: SupplierInvoiceUncheckedUpdateManyWithoutReceivingReportNestedInput
  }

  export type ReceivingReportUncheckedUpdateManyWithoutPurchaseOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    receivedById?: IntFieldUpdateOperationsInput | number
    receivedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryNoteNo?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SupplierInvoiceUpdateWithoutPurchaseOrderInput = {
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplier?: SupplierUpdateOneRequiredWithoutInvoicesNestedInput
    receivingReport?: ReceivingReportUpdateOneWithoutInvoicesNestedInput
  }

  export type SupplierInvoiceUncheckedUpdateWithoutPurchaseOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    supplierId?: IntFieldUpdateOperationsInput | number
    receivingReportId?: NullableIntFieldUpdateOperationsInput | number | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierInvoiceUncheckedUpdateManyWithoutPurchaseOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    supplierId?: IntFieldUpdateOperationsInput | number
    receivingReportId?: NullableIntFieldUpdateOperationsInput | number | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DisbursementUpdateWithoutPurchaseOrderInput = {
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    processedBy?: UserUpdateOneRequiredWithoutDisbursementsNestedInput
  }

  export type DisbursementUncheckedUpdateWithoutPurchaseOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    processedById?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type DisbursementUncheckedUpdateManyWithoutPurchaseOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    processedById?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type ReceivingItemCreateManyReceivingReportInput = {
    id?: number
    materialName: string
    quantityReceived: Decimal | DecimalJsLike | number | string
    status?: string
  }

  export type SupplierInvoiceCreateManyReceivingReportInput = {
    id?: number
    invoiceNumber: string
    invoiceDate: Date | string
    supplierId: number
    purchaseOrderId?: number | null
    totalAmount: Decimal | DecimalJsLike | number | string
    status?: string
    createdAt?: Date | string
  }

  export type ReceivingItemUpdateWithoutReceivingReportInput = {
    materialName?: StringFieldUpdateOperationsInput | string
    quantityReceived?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type ReceivingItemUncheckedUpdateWithoutReceivingReportInput = {
    id?: IntFieldUpdateOperationsInput | number
    materialName?: StringFieldUpdateOperationsInput | string
    quantityReceived?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type ReceivingItemUncheckedUpdateManyWithoutReceivingReportInput = {
    id?: IntFieldUpdateOperationsInput | number
    materialName?: StringFieldUpdateOperationsInput | string
    quantityReceived?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type SupplierInvoiceUpdateWithoutReceivingReportInput = {
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplier?: SupplierUpdateOneRequiredWithoutInvoicesNestedInput
    purchaseOrder?: PurchaseOrderUpdateOneWithoutInvoicesNestedInput
  }

  export type SupplierInvoiceUncheckedUpdateWithoutReceivingReportInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    supplierId?: IntFieldUpdateOperationsInput | number
    purchaseOrderId?: NullableIntFieldUpdateOperationsInput | number | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierInvoiceUncheckedUpdateManyWithoutReceivingReportInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    supplierId?: IntFieldUpdateOperationsInput | number
    purchaseOrderId?: NullableIntFieldUpdateOperationsInput | number | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClientCountOutputTypeDefaultArgs instead
     */
    export type ClientCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClientCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProjectCountOutputTypeDefaultArgs instead
     */
    export type ProjectCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProjectCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BoqItemCountOutputTypeDefaultArgs instead
     */
    export type BoqItemCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BoqItemCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MaterialRequestCountOutputTypeDefaultArgs instead
     */
    export type MaterialRequestCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MaterialRequestCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RFQCountOutputTypeDefaultArgs instead
     */
    export type RFQCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RFQCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SupplierCountOutputTypeDefaultArgs instead
     */
    export type SupplierCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SupplierCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WarehouseCountOutputTypeDefaultArgs instead
     */
    export type WarehouseCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WarehouseCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SupplierQuotationCountOutputTypeDefaultArgs instead
     */
    export type SupplierQuotationCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SupplierQuotationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PurchaseOrderCountOutputTypeDefaultArgs instead
     */
    export type PurchaseOrderCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PurchaseOrderCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReceivingReportCountOutputTypeDefaultArgs instead
     */
    export type ReceivingReportCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReceivingReportCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CompanyDefaultArgs instead
     */
    export type CompanyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CompanyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClientDefaultArgs instead
     */
    export type ClientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClientDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProjectDefaultArgs instead
     */
    export type ProjectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProjectDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProjectMemberDefaultArgs instead
     */
    export type ProjectMemberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProjectMemberDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BoqItemDefaultArgs instead
     */
    export type BoqItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BoqItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BoqItemComponentDefaultArgs instead
     */
    export type BoqItemComponentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BoqItemComponentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MaterialRequestDefaultArgs instead
     */
    export type MaterialRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MaterialRequestDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MaterialRequestItemDefaultArgs instead
     */
    export type MaterialRequestItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MaterialRequestItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RFQDefaultArgs instead
     */
    export type RFQArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RFQDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RFQItemDefaultArgs instead
     */
    export type RFQItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RFQItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SupplierDefaultArgs instead
     */
    export type SupplierArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SupplierDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MaterialDefaultArgs instead
     */
    export type MaterialArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MaterialDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UnitDefaultArgs instead
     */
    export type UnitArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UnitDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CategoryDefaultArgs instead
     */
    export type CategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CategoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WarehouseDefaultArgs instead
     */
    export type WarehouseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WarehouseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SupplierQuotationDefaultArgs instead
     */
    export type SupplierQuotationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SupplierQuotationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use QuotationItemDefaultArgs instead
     */
    export type QuotationItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = QuotationItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PurchaseOrderDefaultArgs instead
     */
    export type PurchaseOrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PurchaseOrderDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PurchaseOrderItemDefaultArgs instead
     */
    export type PurchaseOrderItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PurchaseOrderItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReceivingReportDefaultArgs instead
     */
    export type ReceivingReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReceivingReportDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReceivingItemDefaultArgs instead
     */
    export type ReceivingItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReceivingItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InventoryItemDefaultArgs instead
     */
    export type InventoryItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InventoryItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WorkflowRuleDefaultArgs instead
     */
    export type WorkflowRuleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WorkflowRuleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SupplierInvoiceDefaultArgs instead
     */
    export type SupplierInvoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SupplierInvoiceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DisbursementDefaultArgs instead
     */
    export type DisbursementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DisbursementDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FinancialTransactionDefaultArgs instead
     */
    export type FinancialTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FinancialTransactionDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}